---
title: "Workflows"
description: "Learn how to build durable workflows with regular programming languages and built-in resilience patterns."
icon: "diagram-subtask"
---

Workflows orchestrate complex business processes that span multiple steps, services, and time periods. Restate workflows are written as regular functions in your programming language, with automatic durability, state management, and event handling built in.

In this guide, you'll learn how to:
- Write workflows as regular functions with automatic durability
- Handle long-running processes with state and event patterns
- Deploy steps inline or services that can scale independently
- Build resilient, observable workflows without external dependencies

## Getting Started
A Restate application is composed of two main components:
- **Restate Server**: The core engine that manages durable execution and orchestrates services. It acts as a message broker or reverse proxy in front of your services.
- **Your Services**: Your workflows and business logic, implemented as service handlers using the Restate SDK to perform durable operations.

<img src="/img/tour/app_layout.svg" alt="Application Structure"/>

A basic signup workflow looks like this:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/getstarted/workflow.ts?collapse_prequel"} 
export const signupWorkflow = restate.workflow({
  name: "user-signup",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key; // workflow ID = user ID

      // Write to database
      const success = await ctx.run("create", () => createUser(userId, user));
      if (!success) return { success };

      // Call APIs
      await ctx.run("activate", () => activateUser(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },
  },
});
```
A workflow has a name and a list of handlers.
The `run` handler is the main entry point that executes the workflow logic.

An execution of the workflow is identified by a unique key (in this case, the user ID)
and uses Restate's `WorkflowContext` to make steps durable.

<Accordion title={"Run the example"}>
[Install Restate](/develop/local_dev) and launch it:
```bash
restate-server
```
Run the example:
```bash
restate example typescript-tour-of-workflows && cd typescript-tour-of-workflows
npm run dev
```

Then, tell Restate where your workflow is running:
```bash
restate deployments register http://localhost:9080
```
</Accordion>

## Submitting Workflows
The workflow can be submitted over HTTP, Kafka, programmatically, or via the UI.

To submit the workflow via HTTP send the request to `restate-ingress/workflow-name/key/run`, in our case:
```bash
curl localhost:8080/user-signup/johndoe/run \
  --json '{"name": "John Doe", "email": "john@mail.com"}'
```

<Info>
    Restate deduplicates workflow executions on the key, here `johndoe`.
    Make sure you use another key, if you want to try a request multiple times.
</Info>

<AccordionGroup>
    <Accordion title={"Programmatic invocation"}>
        You can invoke a workflow programmatically with the Restate SDK:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/client.ts#submit"} 
const restateClient = clients.connect({ url: "http://localhost:8080" });

const handle = await restateClient
  .workflowClient(signupWorkflow, id)
  .workflowSubmit({ name, email });
const result = await restateClient.result(handle);
```

        The workflow gets submitted and afterwards you can retrieve the result by attaching to it.

        Run the client script via:
        ```bash
        npm run client
        ```
    </Accordion>
    <Accordion title={"Scheduling for later"}>
        You can schedule a workflow to run at a later time by specifying a delay:
        ```bash
        curl localhost:8080/user-signup/petewhite/run/send?delay=5m \
            --json '{"name": "Pete White", "age": 25}'
        ```
        There is no limit to how long you can delay a workflow (works for months, even years).

        Have a look at the SDK docs to learn how to schedule workflows programmatically ([TS](/operate/invocation/clients/typescript-sdk) / [Java](/operate/invocation/clients/java-sdk) / [Go](/operate/invocation/clients/go-sdk)).
    </Accordion>
    <Accordion title={"Attach to ongoing workflow"}>
        If a workflow is already ongoing, you can also attach to it to get the result once it finishes:
        ```bash
        curl localhost:8080/restate/workflow/user-signup/johndoe/attach
        ```
        Have a look at the SDK docs to learn how to attach to workflows programmatically ([TS](/operate/invocation/clients/typescript-sdk) / [Java](/operate/invocation/clients/java-sdk) / [Go](/operate/invocation/clients/go-sdk)).
    </Accordion>
</AccordionGroup>

## Durable Execution

Restate uses Durable Execution to ensure your business logic survives any failure and resumes exactly where it left off. Unlike traditional workflow systems that require separate orchestrator infrastructure and worker management, Restate lets you deploy your workflows the same way you deploy your application code.

You write a workflow as a regular function. You use the Restate SDK to persist the steps your workflow completes in the Restate Server.

If your workflow crashes or restarts, the execution replays from the journal to restore state and continue processing:

<img src="/img/tour/durable_execution_microservices.gif" alt="Durable Workflow Execution" />

To persist a workflow step, you use the `WorkflowContext` actions:
- **Durable Steps**: `ctx.run()` ensures non-deterministic operations like database writes or external API calls are persisted
- **Progress Recovery**: If the workflow crashes after user creation, it resumes at the email step
- Full execution traces for debugging and monitoring

<Accordion title={"Try it out"}>
Send a request for Alice:
```bash
curl localhost:8080/user-signup/alicedoe/run \
--json '{"name": "Alice", "email": "alice@mail.com"}'
```
Go to the UI at `http://localhost:9070`, on the invocations page, and click on the invocation ID of the retrying invocation:
<Frame>
<img src="/img/tour/workflows/workflow_retries.png" alt="Workflow Retries"/>
</Frame>
You see how the invocation went through the steps of the workflow, and how it is stuck on retrying to send the welcome email.

To fix the problem, remove the line `failOnAlice` from the `sendWelcomeEmail` function in the `utils.ts` file:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/utils.ts#here"} 
export function sendWelcomeEmail(user: User) {
  failOnAlice(user.name, "send welcome email");
  console.log(`Welcome email sent: ${user.email}`);
}
```
Once you restart the service, the workflow finishes successfully:
<Frame>
<img src="/img/tour/workflows/workflow_fixed.png" alt="Workflow Success"/>
</Frame>
</Accordion>

## In-line Steps vs. Separate Activities

Restate workflows can execute operations inline or delegate to separate services, giving you flexibility in how you structure your applications.

- **In-line Steps** - Execute directly in the workflow, for example `ctx.run`.
- **Separate Activities** - Call dedicated services for independent scaling, separation of concerns, or different concurrency requirements.

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/activities/workflow.ts#activities"} 
// Move user DB interaction to dedicated service
const success = await ctx.serviceClient(userService).createUser({ userId, user });
if (!success) return { success };

// Execute other steps inline
await ctx.run("activate", () => activateUser(userId));
await ctx.run("welcome", () => sendWelcomeEmail(user));
```

You can also use this to nest workflows. The main workflow can call other workflows as activities.

Workflows are just one of the service types Restate supports. The other service types are:
- [Services](/basics/services): collections of independent handlers which get executed with Durable Execution.
- [Virtual Objects](/basics/services): stateful services that can be used to manage state and concurrency across multiple invocations.

<Info>
To learn more, follow at the [Microservice Orchestration Tour]("/tour/microservice-orchestration").
</Info>

<Accordion title={"Try it out"}>

    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-activities/carl/run \
        --json '{"name": "Carl", "email": "carl@mail.com"}'
    ```

    In the UI, you can see how the invocation called another service called user service:
    <Frame>
        <img src="/img/tour/workflows/activities.png" alt="Workflow Success"/>
    </Frame>

</Accordion>

## Workflow Patterns

Restate provides powerful patterns for building complex workflows using familiar programming constructs.


### Querying Workflow State
Workflows can store state in Restate, which can be queried later by other handlers:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/queries/workflow.ts?collapse_prequel"} 
export const signupWithQueries = restate.workflow({
  name: "signup-with-queries",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key;

      ctx.set("user", user);
      const success = await ctx.run("create", () => createUser(userId, user));
      if (!success) {
        ctx.set("status", "failed");
        return { success };
      }
      ctx.set("status", "created");

      await ctx.run("activate", () => activateUser(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },

    getStatus: async (ctx: WorkflowSharedContext) => {
      return {
        status: await ctx.get("status"),
        user: await ctx.get("user"),
      };
    },
  },
});
```
Key characteristics:
- State is isolated per workflow execution.
- State lives up to the duration of the workflow retention ([default one day](/operate/configuration/services#retention-policies)).
- State is queryable from other handlers or the Restate UI.

<Frame>
    <img src="/img/tour/workflows/queries.png" alt="Workflow Queries"/>
</Frame>

<Accordion title="Try it out">
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-queries/janedoe/run \
        --json '{"name": "Jane Doe", "email": "jane@mail.com"}'
    ```
    In the UI, look at the state tab and filter on the `signup-with-queries` workflow.
</Accordion>

### Signaling

Pause workflow execution waiting for external events using durable promises:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/signals/workflow.ts?collapse_prequel"} 
export const signupWithSignals = restate.workflow({
  name: "signup-with-signals",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key;

      // Generate verification secret and send email
      const secret = ctx.rand.uuidv4();
      await ctx.run("verify", () => sendVerificationEmail(userId, user, secret));

      // Wait for user to click verification link
      const clickedSecret = await ctx.promise<string>("email-verified");
      return { success: clickedSecret === secret };
    },
    verifyEmail: async (ctx: WorkflowSharedContext, req: { secret: string }) => {
      // Resolve the promise to continue the main workflow
      await ctx.promise<string>("email-verified").resolve(req.secret);
    },
  },
});
```

The promise can survive restarts and crashes, and can be recovered on another process.

You can use `ctx.promise()` to handle asynchronous events without complex message queues or external state management.

Promises can be resolved before the workflow waits for them, avoiding complex synchronization issues.

<Accordion title={"Try it out"}>
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-signals/johndoe/run \
        --json '{"name": "John Doe", "email": "john@mail.com"}'
    ```
    In the UI, you can see the workflow waiting for the `email-verified` promise to be resolved.
    <Frame>
        <img src="/img/tour/workflows/signals.png" alt="Workflow Queries"/>
    </Frame>

    Try killing the service and restarting it. The workflow will continue waiting for the promise to be resolved.

    To resolve the promise, **copy over the curl request from the service logs**, which looks like this:
    ```bash
    curl localhost:8080/signup-with-signals/johndoe/verifyEmail \
        --json '{"secret": "the-secret-from-email"}'
    ```

    Now the UI will show the workflow completed successfully.
</Accordion>

### Workflow Events

You can also use promises the other way around: to send events from the workflow and wait on them in one of the other handlers:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/events/workflow.ts?collapse_prequel"} 
export const signupWithEvents = restate.workflow({
  name: "signup-with-events",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key;

      const success = await ctx.run("create", () => createUser(userId, user));
      if (!success) {
        await ctx.promise<string>("user-created").reject("Creation failed.");
        return { success };
      }
      await ctx.promise<string>("user-created").resolve("User created.");

      await ctx.run("activate", () => activateUser(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },

    waitForUserCreation: async (ctx: WorkflowSharedContext) => {
      return ctx.promise<string>("user-created");
    },
  },
});
```

Here, external clients can wait for the user to be created in the database.

These handlers can be called up to the workflow's retention period ([default one day](/operate/configuration/services#retention-policies)).

<Accordion title={"Try it out"}>
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-events/johndoe/run \
        --json '{"name": "John Doe", "email": "john@mail.com"}'
    ```

    Then wait for the user creation event:
    ```bash
    curl localhost:8080/signup-with-events/johndoe/waitForUserCreation
    ```

    You will get a response like `"User created."`
</Accordion>

### Timers and Scheduling

Use durable timers for long-running workflows with timeouts and retries:

```ts expandable {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/timers/workflow.ts?collapse_prequel"} 
export const signupWithTimers = restate.workflow({
  name: "signup-with-timers",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key;

      const secret = ctx.rand.uuidv4();
      await ctx.run("verify", () => sendVerificationEmail(userId, user, secret));

      const clickedPromise = ctx.promise<string>("email-verified").get();
      const verificationTimeout = ctx.sleep({ days: 1 });
      while (true) {
        const reminderTimer = ctx.sleep({ seconds: 15 });

        // Wait for email verification, reminder timer or timeout
        const result = await RestatePromise.race([
          clickedPromise.map(() => "verified"),
          reminderTimer.map(() => "reminder"),
          verificationTimeout.map(() => "timeout"),
        ]);

        switch (result) {
          case "verified":
            const clickedSecret = await ctx.promise<string>("email-verified");
            return { success: clickedSecret === secret };
          case "reminder":
            await ctx.run("remind", () => sendReminderEmail(user));
            break;
          case "timeout":
            throw new TerminalError("Email verification timed out after 24 hours");
        }
      }
    },
    verifyEmail: async (ctx: WorkflowSharedContext, req: { secret: string }) => {
      await ctx.promise<string>("email-verified").resolve(req.secret);
    },
  },
});
```

Because Restate lets you write workflows as regular functions, you can use your language's native constructs like `while` loops, `if` statements, and `switch` cases to control flow.
This makes it easy to implement complex logic with timers, loops, and conditional execution.

<Accordion title={"Try it out"}>
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-timers/johndoe/run \
        --json '{"name": "John Doe", "email": "john@mail.com"}'
    ```

    See in the UI how the workflow is waiting for the email verification to be resolved, and sends reminder emails every 15 seconds:

    <Frame>
        <img src="/img/tour/workflows/timers.png" alt="Workflow Timers"/>
    </Frame>

    Try killing the service and restarting it. The workflow will continue sending reminders as if it never stopped.

    To resolve the promise, **copy over the curl request from the service logs**, which looks like this:
    ```bash
    curl localhost:8080/signup-with-timers/johndoe/verifyEmail \
        --json '{"secret": "the-secret-from-email"}'
    ```

    Now the UI will show the workflow completed successfully.
</Accordion>

### Parallel Execution

The timers example ran three operations in parallel: two timers and awaiting a promise.

Restate supports different ways of waiting for parallel operations to complete and takes care of retries and recovery for you.

Have a look at the Concurrent Tasks docs for your SDK to learn more ([TS](/develop/ts/concurrent-tasks) / [Java / Kotlin](/develop/java/concurrent-tasks) / [Python](/develop/python/concurrent-tasks) / [Go](/develop/go/concurrent-tasks)).

## Error Handling

Workflows need robust error handling to deal with failures across distributed systems. Restate distinguishes between two types of errors that require different handling strategies.

### Transient vs Terminal Errors

**Transient errors** are temporary failures that can be retried:
- Network timeouts
- Service unavailability  
- Rate limiting
- Infrastructure issues

**Terminal errors** are permanent failures that should not be retried:
- Invalid input data
- Business rule violations


### Configuring Retry Behavior

Configure custom retry policies for specific operations to avoid blocking the workflow:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/retries/workflow.ts#retries"} 
try {
  const policy = {
    maxRetryAttempts: 3,
    initialRetryIntervalMillis: 1000,
  };
  await ctx.run("welcome", () => sendWelcomeEmail(user), policy);
} catch (error) {
  console.error("Failed to send welcome email after retries:", error);
}
```

<Accordion title={"Try it out"}>
    Submit the workflow for Alice:
    ```bash
    curl localhost:8080/signup-with-retries/alice/run \
        --json '{"name": "Alice", "email": "alice@mail.com"}'
    ```

    In the UI, you can see how the workflow is waiting for the `welcome` step to finish, and how it retries sending the welcome email up to 3 times across three seconds:
    <Frame>
        <img src="/img/tour/workflows/retry-policy.png" alt="Workflow Retries"/>
    </Frame>
    After three attempts, the workflow continues without failing:
    <Frame>
        <img src="/img/tour/workflows/retry-policy-failed.png" alt="Workflow Retries"/>
    </Frame>

</Accordion>

## Sagas and rollback

Sagas are a design pattern for handling transactions that span multiple services. They break complex processes into a sequence of steps, each with a corresponding **compensating action** to undo the work if failures occur later.

When a step in your workflow fails, sagas ensure system consistency by running compensation actions for all previously completed steps in reverse order.

Build compensating actions for each step and execute them in reverse order on failure:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/sagas/workflow.ts?collapse_prequel"} 
export const signupWithSagas = restate.workflow({
  name: "signup-with-sagas",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key;
      const compensations = [];

      try {
        compensations.push(() => ctx.run("delete", () => deleteUser(userId)));
        await ctx.run("create", () => createUser(userId, user));

        compensations.push(() => ctx.run("deactivate", () => deactivateUser(userId)));
        await ctx.run("activate", () => activateUser(userId));

        compensations.push(() => ctx.run("unsubscribe", () => cancelSubscription(user)));
        await ctx.run("subscribe", () => subscribeToPaidPlan(user));
      } catch (e) {
        if (e instanceof restate.TerminalError) {
          for (const compensation of compensations.reverse()) {
            await compensation();
          }
        }
        return { success: false };
      }
      return { success: true };
    },
  },
});
```

Key Benefits:

- **Automatic Rollback**: Failed workflows automatically undo completed steps
- **Consistency**: System remains in a valid state even after partial failures  
- **Resilience**: Compensation actions are also durable and will retry on failure
- **Observability**: Full execution trace shows both forward and compensation steps

<Accordion title={"Try it out"}>
    Submit the workflow for Alice:
    ```bash
    curl localhost:8080/signup-with-sagas/alice/run \
        --json '{"name": "Alice", "email": "alice@mail.com"}'
    ```

    Alice is not able to get a subscription, so the workflow will fail and run compensations:
    <Frame>
        <img src="/img/tour/workflows/sagas.png" alt="Workflow Sagas"/>
    </Frame>
</Accordion>


## Cancellation

You can cancel user signup workflows via HTTP, CLI, UI, or programmatically from other services.

When you cancel a workflow, Restate stops the execution by throwing a Terminal Error.
This allows your handler to run compensating actions or clean up resources.

<Accordion title={"Try it out"}>

Start the workflow asynchronously with `/send`:
```bash
curl localhost:8080/signup-with-signals/eve/run/send \
    --json '{"name": "Eve", "email": "eve@mail.com"}'
```
This returns the invocation ID, which you can use to cancel the workflow later via the CLI or HTTP request:
<CodeGroup>
    ```bash CLI
    restate invocations cancel --kill inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
    ```
    ```bash curl
    curl -X DELETE http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
    ```
</CodeGroup>

You can see the cancellation in the UI:

<Frame>
    <img src="/img/tour/workflows/cancellation.png" alt="Workflow Cancellation"/>
</Frame>

</Accordion>

Check out the SDK docs, to learn how to programmatically cancel a workflow from another service ([TS](/develop/ts/service-communication#cancel-an-invocation) / [Java / Kotlin](/develop/java/service-communication#cancel-an-invocation)  / [Python](/develop/python/service-communication#cancel-an-invocation)/ [Go](/develop/go/service-communication#cancel-an-invocation)).


## Serverless Deployment

Restate lets you run your workflows and services on serverless platforms like AWS Lambda or Google Cloud Run.

Restate automatically suspends workflows when they are waiting for events or timers, and resumes them when the event occurs or the timer expires.
This means you can run long-running workflows on function-as-a-service platforms without paying for the wait time.

Turning your signup workflow into a serverless function is as simple as adapting the endpoint:
```typescript {"CODE_LOAD::ts/src/tour/workflows/serving_lambda.ts#lambda"} 
import * as restate from "@restatedev/restate-sdk/lambda";
export const handler = restate
  .endpoint()
  .bind(signupWorkflow)
  .handler();
```

Learn more from the [serving section](/develop/ts/serving).

## Summary

Restate workflows provide:

- **Natural Programming**: Write workflows as regular functions in your preferred language
- **Automatic Durability**: Built-in resilience without infrastructure complexity
- **Flexible Patterns**: State management, events, timers, and parallel execution
- **Modern Deployment**: Strong serverless support and simple single-binary deployment

With Restate, you can build complex, long-running workflows using familiar programming patterns while getting the durability you need.