---
title: "Workflows"
description: "Learn how to build durable workflows with regular programming languages and built-in resilience patterns."
icon: "diagram-subtask"
---

Workflows orchestrate complex business processes that span multiple steps, services, and time periods. Restate workflows are written as regular functions in your programming language, with automatic durability, state management, and event handling built in.

In this guide, you'll learn how to:
- Write workflows as regular functions with automatic durability
- Handle long-running processes with state and event patterns
- Deploy steps inline or services that can scale independently
- Build resilient, observable workflows without external dependencies

## Getting Started
A Restate application is composed of two main components:
- **Restate Server**: The core engine that manages durable execution and orchestrates services. It acts as a message broker or reverse proxy in front of your services.
- **Your Services**: Your workflows and business logic, implemented as service handlers using the Restate SDK to perform durable operations.

<img src="/img/tour/app_layout.svg" alt="Application Structure"/>

### Worfklow Definition

You can define a workflow as follows:

```ts expandable {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/getstarted/workflow.ts?collapse_prequel"} 
export const signupWorkflow = restate.workflow({
  name: "user-signup",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      // workflow ID = user ID; workflow runs once per user
      const userId = ctx.key;

      const success = await ctx.run("create", () => createUserInDB(user));

      if (!success) {
        return { success };
      }

      await ctx.run("activate", () => callActivateUserAPI(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },
  },
  options: {journalRetention: {hours: 4}}
});
```
The example shows a user signup workflow that creates a user entry in a database, then calls an API, and then sends an email.

A workflow has a name and a list of handlers.
The `run` handler is the main entry point that executes the workflow logic.
Other handlers are optional and can interact with the `run` handler.

An execution of the workflow is identified by a unique key (in this case, the user ID or username).

### Running the Workflow

<Steps>
    <Step title={"Install Restate Server & CLI"}>
        Follow the [instructions](/develop/local_dev) to install the Restate Server and CLI on your machine.
    </Step>
    <Step title={"Launch Restate Server"}>
        ```bash
        restate-server
        ```
    </Step>
    <Step title={"Get the example code"}>
        ```bash
        restate example typescript-tour-of-workflows && cd typescript-tour-of-workflows
        ```
    </Step>
    <Step title={"Run the service"}>
        ```bash
        npm run dev
        ```
        The service is now listening on port `9080`.
    </Step>
    <Step title={"Register the workflow via the UI"}>
        Open the Restate UI at `http://localhost:9070` and register the workflow deployment at `http://localhost:9080`.

        Or with the CLI:
        ```bash
        restate deployments register http://localhost:9080
        ```
        You will see a registered workflow per section of this tour.
    </Step>
</Steps>



## Submitting Workflows
The workflow can be submitted over HTTP, Kafka, programmatically, or via the UI.

To submit the workflow via HTTP send the request to `restate-ingress/workflow-name/key/run`, in our case:
```bash
curl localhost:8080/user-signup/johndoe/run \
  --json '{"name": "John Doe", "email": "john@mail.com"}'
```

Restate will deduplicate workflow executions based on the key, here username `johndoe`.

Or programmatically with the Restate SDK from other Restate services:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/client.ts"} 
import * as clients from "@restatedev/restate-sdk-clients";
import {signupWorkflow} from "./getstarted/workflow";

async function submitWorkflow({id, name, email}: {id: string, name: string, email: string}) {
  const restateClient = clients.connect({url: "http://localhost:8080"});

  const handle = await restateClient
      .workflowClient(signupWorkflow, id)
      .workflowSubmit({name, email});
  return await restateClient.result(handle);
}

submitWorkflow({id: "user-123", name: "John Doe", email: "john@mail.com"})
```

The workflow gets submitted and afterwards you can retrieve the result by attaching to it.

Run the client script via:
```bash
npm run client
```

<AccordionGroup>
    <Accordion title={"Scheduling for later"}>
        You can schedule a workflow to run at a later time by specifying a delay:
        ```bash
        curl localhost:8080/user-signup/petewhite/run/send?delay=5m \
            --json '{"name": "Pete White", "age": 25}'
        ```
        There is no limit to how long you can delay a workflow (works for months, even years).

        Have a look at the SDK docs to learn how to schedule workflows programmatically ([TS](/operate/invocation/clients/typescript-sdk) / [Java](/operate/invocation/clients/java-sdk) / [Go](/operate/invocation/clients/go-sdk)).
    </Accordion>
    <Accordion title={"Attach to ongoing workflow"}>
        If a workflow is already ongoing, you can also attach to it to get the result once it finishes:
        ```bash
        curl localhost:8080/restate/workflow/user-signup/johndoe/attach
        ```
        Have a look at the SDK docs to learn how to attach to workflows programmatically ([TS](/operate/invocation/clients/typescript-sdk) / [Java](/operate/invocation/clients/java-sdk) / [Go](/operate/invocation/clients/go-sdk)).
    </Accordion>
</AccordionGroup>

## Durable Execution

Restate workflows use durable execution to ensure your business logic survives any failure and resumes exactly where it left off. Unlike traditional workflow systems that require separate orchestrator infrastructure and worker management, Restate lets you deploy your workflows the same way you deploy your application code.

You write a workflow as a regular function. You use the Restate SDK to persist the steps your workflow completes in the Restate Server.

If your workflow crashes or restarts, the execution replays from the journal to restore state and continue processing:

<img src="/img/tour/durable_execution_microservices.gif" alt="Durable Workflow Execution" />

To have access to Durable Execution, you need to use the `WorkflowContext` object provided by the Restate SDK:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/getstarted/workflow.ts?collapse_prequel"} 
export const signupWorkflow = restate.workflow({
  name: "user-signup",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      // workflow ID = user ID; workflow runs once per user
      const userId = ctx.key;

      const success = await ctx.run("create", () => createUserInDB(user));

      if (!success) {
        return { success };
      }

      await ctx.run("activate", () => callActivateUserAPI(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },
  },
  options: {journalRetention: {hours: 4}}
});
```

The `WorkflowContext` object lets us do durable operations like:
- **Durable Steps**: `ctx.run()` ensures non-deterministic operations like database writes or external API calls are persisted
- **Progress Recovery**: If the workflow crashes after user creation, it resumes at the email step
- Full execution traces for debugging and monitoring

### Try it out

<Steps>
    <Step title={"Send a request for Alice"}>
        ```bash
        curl localhost:8080/user-signup/alicedoe/run \
          --json '{"name": "Alice", "email": "alice@mail.com"}'
        ```
    </Step>
    <Step title={"Troubleshooting"}>
        Go to the UI at `http://localhost:9070`, on the invocations page, and click on the invocation ID of the retrying invocation:
        <Frame>
        <img src="/img/tour/workflows/workflow_retries.png" alt="Workflow Retries"/>
        </Frame>
        You see how the invocation went through the steps of the workflow, and how it is stuck on retrying to send the welcome email.
    </Step>
    <Step title={"Fix the issue"}>
        To fix the problem, remove the line `failOnAlice` from the `sendWelcomeEmail` function in the `utils.ts` file, and restart your service:

        ```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/utils.ts#here"} 
export function sendWelcomeEmail(user: { name: string; email: string }) {
  // failOnAlice(user.name)
  console.log(`Welcome email sent: ${user.email}`);
}
```
    </Step>
    <Step title={"Succesfull completion"}>
        Once we have done this, we see the workflow finished successfully:
        <Frame>
        <img src="/img/tour/workflows/workflow_fixed.png" alt="Workflow Success"/>
        </Frame>
    </Step>
</Steps>

## In-line Steps vs. Separate Activities

Restate workflows can execute operations inline or delegate to separate services, giving you flexibility in how you structure your applications.

- **In-line Steps** - Execute directly in the workflow, for example `ctx.run`.
- **Separate Activities** - Call dedicated services for independent scaling, separation of concerns, or different concurrency requirements.

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/activities/workflow.ts?collapse_prequel"} 
export const signupWithActivities = restate.workflow({
  name: "signup-with-activities",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;

      // Move user DB interaction to dedicated service
      const success = await ctx
        .serviceClient(userService)
        .createUser({ id: ctx.key, ...user });

      if (!success) {
        return { success };
      }

      await ctx.run("activate", () => callActivateUserAPI(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },
  },
  options: {journalRetention: {hours: 4}}
});
```

The user creation has been pulled out into a separate user service, which handles all queries to the user database.
This user service is also a Restate service, so we can invoke it using the `ctx.serviceClient()` method.

You can also use this to nest workflows. The main workflow can call other workflows as activities.

Workflows are just one of the service types Restate supports. The other service types are:
- [Services](/basics/services): collections of independent handlers which get executed with Durable Execution.
- [Virtual Objects](/basics/services): stateful services that can be used to manage state and concurrency across multiple invocations.

<Info>
    Restate can be used for more than just workflows.
    You can implement any service as a Restate service.
    Have a look at the [Microservice Orchestration Tour]("/tour/microservice-orchestration") to learn how to build microservices with Restate.
</Info>

<Accordion title={"Try it out"}>

    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-activities/carl/run \
        --json '{"name": "Carl", "email": "carl@mail.com"}'
    ```

    In the UI, you can see how the invocation called another service called user service:
    <Frame>
        <img src="/img/tour/workflows/activities.png" alt="Workflow Success"/>
    </Frame>

</Accordion>

## Workflow Patterns

Restate provides powerful patterns for building complex workflows using familiar programming constructs.


### Querying Workflow State
Workflows can store state in Restate, which can be queried later by other handlers:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/queries/workflow.ts?collapse_prequel"} 
export const signupWithQueries = restate.workflow({
  name: "signup-with-queries",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;

      const success = await ctx.run("create", () => createUserInDB(user));

      if (!success) {
        ctx.set("status", { status: "verification-failed", user });
        return { success };
      }

      ctx.set("status", { status: "user-created", user });
      await ctx.run("activate", () => callActivateUserAPI(userId));
      ctx.set("status", {
        status: "user-activated",
        user,
        completedAt: await ctx.date.toJSON(),
      });
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },

    getStatus: async (ctx: restate.WorkflowSharedContext) => {
      return await ctx.get("status");
    },
  },
  options: {journalRetention: {hours: 4}}
});
```
Key characteristics:
- State is isolated per workflow execution.
- State lives up to the duration of the workflow retention ([default one day](/operate/configuration/services#retention-policies)).
- State is queryable from the Restate UI.

<Frame>
    <img src="/img/tour/workflows/queries.png" alt="Workflow Queries"/>
</Frame>

<Accordion title="Try it out">
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-queries/janedoe/run \
        --json '{"name": "Jane Doe", "email": "jane@mail.com"}'
    ```
    In the UI, look at the state tab and filter on the `signup-with-queries` workflow.
</Accordion>

### Signaling

Workflows can pause execution waiting for external events.

In this example, the workflow sends a verification email with a link the user needs to click. It then waits for the click, which resolves the promise and allows the workflow to continue.

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/signals/workflow.ts?collapse_prequel"} 
export const signupWithSignals = restate.workflow({
  name: "signup-with-signals",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;

      // Generate verification secret and send email
      const verificationSecret = ctx.rand.uuidv4();
      await ctx.run("verify", () => sendVerificationEmail(userId, user, verificationSecret));

      // Wait for user to click verification link
      const clickedSecret = await ctx.promise<string>("email-verified");

      const success = clickedSecret === verificationSecret;
      if (!success) {
        return { success };
      }

      await ctx.run("activate", () => callActivateUserAPI(userId));
      return { success };
    },
    verifyEmail: async (
      ctx: restate.WorkflowSharedContext,
      request: { secret: string },
    ) => {
      // Resolve the promise to continue the main workflow
      await ctx.promise<string>("email-verified").resolve(request.secret);
    },
  },
  options: {journalRetention: {hours: 4}}
});
```
The `verifyEmail` handler gets called when the user clicks the link, allowing the workflow to continue.

The promise can survive restarts and crashes, and can be recovered on another process.

You can use `ctx.promise()` to handle asynchronous events without complex message queues or external state management.

Promises can be resolved before the workflow waits for them, avoiding complex synchronization issues.

<Accordion title={"Try it out"}>
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-signals/johndoe/run \
        --json '{"name": "John Doe", "email": "john@mail.com"}'
    ```
    In the UI, you can see the workflow waiting for the `email-verified` promise to be resolved.
    <Frame>
        <img src="/img/tour/workflows/signals.png" alt="Workflow Queries"/>
    </Frame>

    Try killing the service and restarting it. The workflow will continue waiting for the promise to be resolved.

    To resolve the promise, **copy over the curl request from the service logs**, which looks like this:
    ```bash
    curl localhost:8080/signup-with-signals/johndoe/verifyEmail \
        --json '{"secret": "the-secret-from-email"}'
    ```

    Now the UI will show the workflow completed successfully.
</Accordion>

### Workflow Events

You can also use promises the other way around: to send events from the workflow and wait on them in one of the other handlers:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/events/workflow.ts?collapse_prequel"} 
export const signupWithEvents = restate.workflow({
  name: "signup-with-events",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;

      const success = await ctx.run("create", () => createUserInDB(user));

      if (!success) {
        await ctx
          .promise<string>("user-created")
          .reject("User couldn't be created.");
        return { success };
      }

      await ctx.promise<string>("user-created").resolve("User created.");
      await ctx.run("activate", () => callActivateUserAPI(userId));
      await ctx.promise<boolean>("user-activated").resolve(true);
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      return { success };
    },

    waitForUserCreation: async (ctx: restate.WorkflowSharedContext) => {
      return ctx.promise<string>("user-created");
    },

    waitForUserActivation: async (ctx: restate.WorkflowSharedContext) => {
      return ctx.promise<boolean>("user-activated");
    },
  },
  options: {journalRetention: {hours: 4}}
});
```

External clients can now call the `waitForUserCreation` or `waitForUserActivation` handlers to wait for specific events in the signup process before proceeding with other operations.

These handlers can be called up to the workflow's retention period ([default one day](/operate/configuration/services#retention-policies)).

<Accordion title={"Try it out"}>
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-events/johndoe/run \
        --json '{"name": "John Doe", "email": "john@mail.com"}'
    ```

    Then wait for the user creation event:
    ```bash
    curl localhost:8080/signup-with-events/johndoe/waitForUserCreation
    ```

    You will get a response like `"User created."`
</Accordion>

### Timers and Scheduling

Restate supports long-running workflows (days, weeks,... ) that wait for specific durations or timeouts using built-in durable timers.

These durable timers are stored and tracked by the Restate Server. They survive crashes and restarts.

For example, we can let our signup workflow send reminder emails every 4 hours, and wait for at most 24 hours for the user to verify their email, then time out if the user does not respond.
For the sake of the demo, we use a 15-second reminder timeout.

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/timers/workflow.ts?collapse_prequel"} 
export const signupWithTimers = restate.workflow({
  name: "signup-with-timers",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;

      const verificationSecret = ctx.rand.uuidv4();
      await ctx.run("verify", () => sendVerificationEmail(userId, user, verificationSecret));

      const clickedPromise = ctx.promise<string>("email-verified").get();
      const verificationTimeout = ctx.sleep({ days: 1 });
      while (true) {
        const reminderTimer = ctx.sleep({ seconds: 15 });

        // Wait for either email verification, reminder timeout, or verification timeout
        const result = await RestatePromise.race([
          clickedPromise.map(() => "verified"),
          reminderTimer.map(() => "reminder"),
          verificationTimeout.map(() => "timeout"),
        ]);

        switch (result) {
          case "verified":
            const clickedSecret = await ctx.promise<string>("email-verified");
            return { success: clickedSecret === verificationSecret };
          case "reminder":
            await ctx.run("remind", () => sendReminderEmail(user, verificationSecret));
            break;

          case "timeout":
            throw new restate.TerminalError(
              "Email verification timed out after 24 hours",
            );
        }
      }
    },
    verifyEmail: async (
      ctx: restate.WorkflowSharedContext,
      request: { secret: string },
    ) => {
      // Resolve the promise to continue the main workflow
      await ctx.promise<string>("email-verified").resolve(request.secret);
    },
  },
  options: {journalRetention: {hours: 4}}
});
```

Because Restate lets you write workflows as regular functions, you can use your language's native constructs like `while` loops, `if` statements, and `switch` cases to control flow.
This makes it easy to implement complex logic with timers, loops, and conditional execution.

<Accordion title={"Try it out"}>
    Submit the workflow:
    ```bash
    curl localhost:8080/signup-with-timers/johndoe/run \
        --json '{"name": "John Doe", "email": "john@mail.com"}'
    ```

    See in the UI how the workflow is waiting for the email verification to be resolved, and sends reminder emails every 15 seconds:

    <Frame>
        <img src="/img/tour/workflows/timers.png" alt="Workflow Timers"/>
    </Frame>

    Try killing the service and restarting it. The workflow will continue sending reminders as if it never stopped.

    To resolve the promise, **copy over the curl request from the service logs**, which looks like this:
    ```bash
    curl localhost:8080/signup-with-timers/johndoe/verifyEmail \
        --json '{"secret": "the-secret-from-email"}'
    ```

    Now the UI will show the workflow completed successfully.
</Accordion>

### Parallel Execution

The timers example ran three operations in parallel: two timers and awaiting a promise.

Restate supports different ways of waiting for parallel operations to complete and takes care of retries and recovery for you.

Have a look at the Concurrent Tasks docs for your SDK to learn more ([TS](/develop/ts/concurrent-tasks) / [Java / Kotlin](/develop/java/concurrent-tasks) / [Python](/develop/python/concurrent-tasks) / [Go](/develop/go/concurrent-tasks)).

## Error Handling

Workflows need robust error handling to deal with failures across distributed systems. Restate distinguishes between two types of errors that require different handling strategies.

### Transient vs Terminal Errors

**Transient errors** are temporary failures that can be retried:
- Network timeouts
- Service unavailability  
- Rate limiting
- Infrastructure issues

**Terminal errors** are permanent failures that should not be retried:
- Invalid input data
- Business rule violations


### Configuring Retry Behavior

For transient errors, you can customize retry policies for specific operations.

For example, imagine you don't want to block the workflow on sending the welcome email if the email service is down.
Then, you can retry sending the welcome email up to 3 times with a minimum interval of one second between retries.
If the email still didn't go through, then the run block will throw a Terminal Error.
We catch the error and continue the workflow without failing it:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/retries/workflow.ts?collapse_prequel"} 
export const signupWithRetries = restate.workflow({
  name: "signup-with-retries",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;

      const success = await ctx.run("create", () => createUserInDB(user));

      if (!success) {
        return { success };
      }

      await ctx.run("activate", () => callActivateUserAPI(userId));

      try {
        // Don't let the workflow get stuck if the email service is down
        const emailRetryPolicy = {
          maxRetryAttempts: 3,
          maxRetryInterval: { seconds: 10 },
        };
        await ctx.run(
          "welcome",
          () => sendWelcomeEmail(user),
          emailRetryPolicy,
        );
      } catch (error) {
        console.error("Failed to send welcome email after retries:", error);
        return { success: true };
      }
      return { success };
    },
  },
  options: {journalRetention: {hours: 4}}
});
```

<Accordion title={"Try it out"}>
    Submit the workflow for Alice:
    ```bash
    curl localhost:8080/signup-with-retries/alice/run \
        --json '{"name": "Alice", "email": "alice@mail.com"}'
    ```

    In the UI, you can see how the workflow is waiting for the `welcome` step to finish, and how it retries sending the welcome email up to 3 times across three seconds:
    <Frame>
        <img src="/img/tour/workflows/retry-policy.png" alt="Workflow Retries"/>
    </Frame>
    After three attempts, the workflow continues without failing:
    <Frame>
        <img src="/img/tour/workflows/retry-policy-failed.png" alt="Workflow Retries"/>
    </Frame>

</Accordion>

## Sagas and rollback

Sagas are a design pattern for handling transactions that span multiple services. They break complex processes into a sequence of steps, each with a corresponding **compensating action** to undo the work if failures occur later.

When a step in your workflow fails, sagas ensure system consistency by running compensation actions for all previously completed steps in reverse order.

Implementing sagas in Restate is straightforward. You keep a list of compensating actions and execute them in reverse order if an error occurs.
Restate's replay mechanism ensures that after failures, the list of compensations can be recovered and executed till completion:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-workflows-typescript/src/sagas/workflow.ts?collapse_prequel"} 
export const signupWithSagas = restate.workflow({
  name: "signup-with-sagas",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string },
    ) => {
      const userId = ctx.key;
      const compensations = [];

      try {
        compensations.push(() => ctx.run("delete", () => deleteUserInDB(user)));
        await ctx.run("create", () => createUserInDB(user));

        compensations.push(() =>
          ctx.run("deactivate", () => callDeactivateUserAPI(userId)),
        );
        await ctx.run("activate", () => callActivateUserAPI(userId));

        compensations.push(() =>
          ctx.run("unsubscribe", () => cancelSubscription(user)),
        );
        await ctx.run("subscribe", () => subscribeToPaidPlan(user));
      } catch (e) {
        if (e instanceof restate.TerminalError) {
          for (const compensation of compensations.reverse()) {
            await compensation();
          }
        }
        return { success: false };
      }
      return { success: true };
    },
  },
  options: {journalRetention: {hours: 4}}
});
```

Key Benefits:

- **Automatic Rollback**: Failed workflows automatically undo completed steps
- **Consistency**: System remains in a valid state even after partial failures  
- **Resilience**: Compensation actions are also durable and will retry on failure
- **Observability**: Full execution trace shows both forward and compensation steps

<Accordion title={"Try it out"}>
    Submit the workflow for Alice:
    ```bash
    curl localhost:8080/signup-with-sagas/alice/run \
        --json '{"name": "Alice", "email": "alice@mail.com"}'
    ```

    Alice is not able to get a subscription, so the workflow will fail and run compensations:
    <Frame>
        <img src="/img/tour/workflows/sagas.png" alt="Workflow Sagas"/>
    </Frame>
</Accordion>


## Cancellation

You can cancel user signup workflows via HTTP, CLI, UI, or programmatically from other services.

When you cancel a workflow, Restate stops the execution by throwing a Terminal Error.
This allows your handler to run compensating actions or clean up resources.

<Accordion title={"Try it out"}>

Start the workflow asynchronously with `/send`:
```bash
curl localhost:8080/signup-with-signals/eve/run/send \
    --json '{"name": "Eve", "email": "eve@mail.com"}'
```
This returns the invocation ID, which you can use to cancel the workflow later via the CLI or HTTP request:
<CodeGroup>
    ```bash CLI
    restate invocations cancel --kill inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
    ```
    ```bash curl
    curl -X DELETE http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz
    ```
</CodeGroup>

You can see the cancellation in the UI:

<Frame>
    <img src="/img/tour/workflows/cancellation.png" alt="Workflow Cancellation"/>
</Frame>

</Accordion>

Check out the SDK docs, to learn how to programmatically cancel a workflow from another service ([TS](/develop/ts/service-communication#cancel-an-invocation) / [Java / Kotlin](/develop/java/service-communication#cancel-an-invocation)  / [Python](/develop/python/service-communication#cancel-an-invocation)/ [Go](/develop/go/service-communication#cancel-an-invocation)).


## Serverless Deployment

Restate lets you run your workflows and services on serverless platforms like AWS Lambda or Google Cloud Run.

Restate automatically suspends workflows when they are waiting for events or timers, and resumes them when the event occurs or the timer expires.
This means you can run long-running workflows on function-as-a-service platforms without paying for the wait time.

Turning your signup workflow into a serverless function is as simple as adapting the endpoint:
```typescript
// Deploy to AWS Lambda
export const handler = restate.endpoint()
    .bind(signupWorkflow)
    .bind(OnboardingWorkflow)
    .bind(userService)
    .handler();
```

The durable execution model means workflows can pause and resume across function invocations without losing progress, making serverless an ideal deployment target.

Learn more from the [serving section](/develop/ts/serving).

## Summary

Restate workflows provide:

- **Natural Programming**: Write workflows as regular functions in your preferred language
- **Automatic Durability**: Built-in resilience without infrastructure complexity
- **Flexible Patterns**: State management, events, timers, and parallel execution
- **Modern Deployment**: Strong serverless support and simple single-binary deployment

With Restate, you can build complex, long-running workflows using familiar programming patterns while getting the durability you need.