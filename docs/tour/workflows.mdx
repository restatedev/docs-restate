---
title: "Workflows"
description: "Learn how to build durable workflows with regular programming languages and built-in resilience patterns."
icon: "diagram-subtask"
---

Workflows orchestrate complex business processes that span multiple steps, services, and time periods. Restate workflows are written as regular functions in your programming language, with automatic durability, state management, and event handling built in.

In this guide, you'll learn how to:
- Write workflows as regular functions with automatic durability
- Handle long-running processes with state and event patterns
- Deploy workflows inline or as separate services
- Build resilient, observable workflows without external dependencies

## Durable Execution

Restate workflows use durable execution to ensure your business logic survives any failure and resumes exactly where it left off. Unlike traditional workflow systems that require separate orchestrator infrastructure and worker management, Restate makes every function call automatically durable.

### How It Works

When you write a workflow as a regular function, Restate automatically journals every operation. If your workflow crashes or restarts, the execution replays from the journal to restore state and continue processing:

<img src="/img/tour/durable_execution_workflows.gif" alt="Durable Workflow Execution" />

### User Signup Workflow Example

Here's a complete signup workflow that demonstrates durable execution with external events:

```ts
const signupWorkflow = restate.workflow({
  name: "user-signup",
  handlers: {
    run: async (
      ctx: restate.WorkflowContext,
      user: { name: string; email: string }
    ) => {
      // workflow ID = user ID; workflow runs once per user
      const userId = ctx.key;

      await ctx.run(() => createUserEntry(user));

      const secret = ctx.rand.uuidv4();
      await ctx.run(() => sendEmailWithLink({ userId, user, secret }));

      const clickSecret = await ctx.promise<string>("link-clicked");
      return clickSecret === secret;
    },

    click: async (
      ctx: restate.WorkflowSharedContext,
      request: { secret: string }
    ) => {
      await ctx.promise<string>("link-clicked").resolve(request.secret);
    },
  },
});
```

**Key Features:**
- **Deterministic Operations**: `ctx.random()` generates the same UUID on replay
- **Durable External Calls**: `ctx.run()` ensures external systems are called exactly once
- **Automatic State Persistence**: `ctx.set()` changes survive crashes
- **Event Integration**: Promises pause execution until external events occur

This approach eliminates the need for explicit checkpointing, state machines, or complex retry logic that traditional workflow systems require.

## Workflow Patterns

Restate provides powerful patterns for building complex workflows using familiar programming constructs.

### Signaling

Workflows maintain durable state and can pause execution waiting for external events:

```python
{CODE_LOAD::python/src/develop/workflows/signup.py#mark_3}
```

**Durable Promises** let you handle external events without complex message correlation or state management systems. Each workflow instance automatically receives events targeted to its unique ID.

### Querying the workflow

Events with promise

or K/V state

### Timers and Scheduling

Built-in durable timers survive crashes and restarts:

```java
// Wait for a duration
ctx.timer(Duration.ofHours(24)).await();

// Timeout pattern
var approval = ctx.promise("user-approval", String.class);
var timeout = ctx.timer(Duration.ofDays(7));

var result = Select.select()
    .when(approval, approved -> "Approved: " + approved)
    .when(timeout, unused -> "Timed out")
    .await();
```

Unlike external scheduler systems, these timers are part of your workflow's execution and automatically cleaned up when workflows complete.

### Parallel Execution

Execute multiple operations concurrently using your language's native patterns:

```typescript
// Start operations in parallel
const [payment, inventory, shipping] = await Promise.all([
  ctx.run(() => paymentService.charge(order.total)),
  ctx.run(() => inventoryService.reserve(order.items)),
  ctx.run(() => shippingService.schedule(order.address))
]);

// Process results
return {
  success: payment.success && inventory.success,
  trackingId: shipping.trackingId
};
```

This provides the benefits of parallel execution without the complexity of managing task queues or worker coordination.

## Service Integration

Restate workflows can execute operations inline or delegate to separate services, giving you flexibility in how you structure your applications.

### Inline vs Service Handlers

**Inline Operations** - Execute directly in the workflow:
```java
@Workflow
public void processOrder(WorkflowContext ctx, Order order) {
  // Direct inline execution
  var result = ctx.run(() -> paymentClient.charge(order.total));
  return result;
}
```

**Service Handler Delegation** - Call separate services for independent scaling:
```typescript
// Call dedicated service
const paymentResult = await ctx.serviceClient(PaymentService)
    .processPayment({ orderId: order.id, amount: order.total });
```

This flexibility allows you to optimize for different scenarios - inline for simple operations, separate services for compute-intensive tasks or independent scaling requirements.

### Workflow Composition

Workflows can call other workflows to compose complex business processes:

```java
// Call child workflow
var userVerified = ctx.workflowClient(UserVerificationWorkflow, order.userId)
    .run({ userId: order.userId })
    .await();

if (!userVerified) {
  throw new TerminalException("Verification failed");
}
```

## Deployment and Observability

Restate workflows are designed for modern deployment patterns with built-in observability.

### Serverless Deployment

Workflows run naturally on serverless platforms without cold start penalties or state loss:

```typescript
// Deploy to AWS Lambda, Google Cloud Functions, etc.
export const handler = restate.lambdaHandler([
  signupWorkflow,
  orderWorkflow
]);
```

The durable execution model means workflows can pause and resume across function invocations without losing state, making serverless an ideal deployment target.

### Built-in Observability

Every workflow execution is automatically traced and observable:

- **Execution History**: Step-by-step replay of workflow operations
- **State Inspection**: View workflow state at any point in time  
- **Error Tracking**: Complete stack traces with failure context
- **Performance Metrics**: Timing data for each workflow step

This eliminates the need for external observability infrastructure or custom instrumentation that many workflow systems require.

### Single Binary Architecture

Unlike systems that require orchestrator servers, worker clusters, and external databases, Restate workflows run in a single binary alongside your application code:

```bash
# Simple deployment
./restate-server &
java -jar my-workflows.jar
```

This simplified architecture reduces operational complexity while providing enterprise-grade durability and reliability.

## Summary

Restate workflows provide:

- **Natural Programming**: Write workflows as regular functions in your preferred language
- **Automatic Durability**: Built-in resilience without infrastructure complexity
- **Flexible Patterns**: State management, events, timers, and parallel execution
- **Modern Deployment**: Serverless-ready with built-in observability

With Restate, you can build complex, long-running workflows using familiar programming patterns while getting enterprise-grade durability automatically.