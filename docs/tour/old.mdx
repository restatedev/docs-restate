---
title: "Microservice Orchestration"
description: "An introduction to service communication, sagas, and async tasks."
icon: "circle-nodes"
---

## Durable Execution

- Resiliency
- Idempotency
- Explain service/handler/context
- how to call
- layout app
- observability

```java
@RestateService
public class SubscriptionService {

  @Autowired PaymentClient paymentClient;
  @Autowired SubscriptionClient subscriptionClient;

  @Handler
  public void add(Context ctx, SubscriptionRequest req) {

    var paymentId = ctx.random().nextUUID().toString();

    ctx.run(
        "Creating payment",
        String.class,
        () -> paymentClient.createRecurringPayment(req.creditCard(), paymentId));

    for (String subscription : req.subscriptions()) {
      ctx.run(
          "Subscribe " + subscription,
          () -> subscriptionClient.createSubscription(req.userId(), subscription));
    }
  }
}
```

## Saga Orchestration
- rolling back in case you want to

```java
@RestateService
public class SubscriptionSaga {

  @Autowired PaymentClient paymentClient;
  @Autowired SubscriptionClient subscriptionClient;

  @Handler
  public void add(Context ctx, SubscriptionRequest req) {
    List<Runnable> compensations = new ArrayList<>();
    try {
      var paymentId = ctx.random().nextUUID().toString();

      compensations.add(
          () -> ctx.run("Remove payment", () -> paymentClient.removeRecurringPayment(paymentId)));
      ctx.run(
          "Creating payment",
          String.class,
          () -> paymentClient.createRecurringPayment(req.creditCard(), paymentId));

      for (String subscription : req.subscriptions()) {
        compensations.add(
            () ->
                ctx.run(
                    "Remove " + subscription,
                    () -> subscriptionClient.removeSubscription(req.userId(), subscription)));
        ctx.run(
            "Subscribe " + subscription,
            () -> subscriptionClient.createSubscription(req.userId(), subscription));
      }
    } catch (TerminalException e) {
      compensations.reversed().forEach(Runnable::run);
      throw e;
    }
  }
}
```

## Service communication
pulling out some of the steps into separate handlers/services.

- scaling separately
- durable RPC / background tasks


## Virtual Objects
- K/V state
- exclusive vs shared
- concurrency, consistency

```
const subscriptionObject = restate.object({
  name: "SubscriptionObject",
  handlers: {
    add: async (ctx: restate.ObjectContext, req: SubscriptionRequest) => {
      const paymentId = ctx.rand.uuidv4();

      ctx.set("subscription", "awaiting_payment");
      const success = await tryPaymentFiveTimes(ctx, req, paymentId);
      if (!success) {
        ctx.set("subscription", "payment_failed");
        return;
      }

      ctx.set("subscription", "creating_subscription");
      await ctx.run(() => createSubscription(req.userId, req.subscription));

      ctx.set("subscription", "created");
    },
  },
```

## Task scheduling and Concurrency

Parallelization
wait for all
store state machine

```java
@RestateService
public class EmailVerification {

  @Autowired EmailClient emailClient;

  @Handler
  public String verifyEmail(Context ctx, VerifyEmailRequest req) {
    var confirmationFuture = ctx.awakeable(Boolean.class);
    ctx.run(
        "send email",
        () -> emailClient.sendVerificationEmail(req.email(), confirmationFuture.id()));

    var verificationTimeout = ctx.timer(Duration.ofDays(1));

    while (true) {
      var reminderTimer = ctx.timer(Duration.ofSeconds(10));

      var selected =
          Select.<String>select()
              .when(confirmationFuture, res -> res ? "success" : "failure")
              .when(reminderTimer, unused -> "reminder")
              .when(verificationTimeout, unused -> "timeout")
              .await();

      switch (selected) {
        case "success":
          return "Email verified";
        case "failure":
          return "Email rejected";
        case "reminder":
            ctx.run(
                "send reminder",
                () -> emailClient.sendReminder(req.email(), confirmationFuture.id()));
            break;
        case "timeout":
            throw new TerminalException("Verification timed out");
      }
    }
  }
```

