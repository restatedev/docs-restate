---
title: "Microservice Orchestration"
description: "Learn how to orchestrate microservices with durable execution, sagas, and async communication patterns."
icon: "circle-nodes"
---

Microservice orchestration is about coordinating multiple services to complete complex business workflows. Restate provides powerful primitives for building resilient, observable orchestration patterns.

In this guide, you'll learn how to:
- Build durable, fault-tolerant service orchestrations with automatic failure recovery
- Implement sagas for distributed transactions with resilient compensation
- Use durable timers and external events for complex async patterns
- Implement stateful entities with Virtual Objects

## Getting Started
A Restate application is composed of two main components:
- **Restate Server**: The core engine that manages durable execution and orchestrates services. It acts as a message broker or reverse proxy in front of your services.
- **Your Services**: Your business logic, implemented as service handlers using the Restate SDK to perform durable operations.

<img src="/img/tour/app_layout.svg" alt="Application Structure"/>


A basic subscription service orchestration looks like this:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/getstarted/service.ts?collapse_prequel"} 
export const subscriptionService = restate.service({
  name: "SubscriptionService",
  handlers: {
    add: async (ctx: restate.Context, req: SubscriptionRequest) => {
      const paymentId = ctx.rand.uuidv4();

      const payRef = await ctx.run("pay", () =>
        createRecurringPayment(req.creditCard, paymentId),
      );

      for (const subscription of req.subscriptions) {
        await ctx.run(`subscribe-${subscription}`, () =>
          createSubscription(req.userId, subscription, payRef),
        );
      }
    },
  },
});
```
A service has handlers that can be called over HTTP. Each handler receives a `Context` object that provides durable execution primitives. Any action performed with the Context is automatically recorded and can survive failures.

You don't need to run your services in any special way. Restate works with how you already deploy your code, whether that's in Docker, on Kubernetes, or via AWS Lambda.

### Run the example
[Install Restate](/develop/local_dev) and launch it:
```bash
restate-server
```

Get the example:
```bash
restate example typescript-tour-of-orchestration && cd typescript-tour-of-orchestration
npm install
```

Run the example:
```bash
npm run dev
```

Then, tell Restate where your services are running via the UI (`http://localhost:9070`) or CLI:
```bash
restate deployments register http://localhost:9080
```

Invoke the service handler to add a subscription:
```bash
curl localhost:8080/SubscriptionService/add \
  --json '{"userId": "user-123", "creditCard": "4111111111111111", "subscriptions": ["Hulu", "Prime"]}'
```

## Durable Execution

Restate uses Durable Execution to ensure your orchestration logic survives failures and restarts.
Whenever a handler executes an action with the Restate `Context`, this gets send over to the Restate Server and persisted in a log.

On a failure or a crash, the Restate Server sends a retry request that contains the log of the actions that were executed so far.
The service then replays the log to restore state and continues executing the remaining actions.
This process continues until the handler runs till completion.

<img src="/img/tour/durable_execution_microservices.gif" alt="Context in Restate" />

**Key Benefits:**
- `ctx.run()` makes external calls or non-deterministic operations durable. They get replayed on failures.
- If the service crashes after payment creation, it resumes at the subscription step
- Deterministic IDs from `ctx.random()` ensure operations are idempotent
- Full execution traces for debugging and monitoring

<Accordion title={"Try it out yourself!"}>
    Invoke the service handler to add a subscription:
    ```bash
    curl localhost:9070/SubscriptionService/add --json '{"userId": "user-123", "creditCard": "4111111111111111", "subscriptions": ["Hulu", "Prime"]}'
    ```
</Accordion>

## Error Handling

By default, Restate retries failures infinitely with an exponential backoff strategy.
For some failures, you might not want to retry or only retry a limited number of times.

For these cases, Restate distinguishes between two types of errors:

- **Transient Errors**: These are temporary issues that can be retried, such as network timeouts or service unavailability. Restate automatically retries these errors.
- **Terminal Errors**: These indicate a failure that will not be retried, such as invalid input or business logic violations. Restate stops execution and allows you to handle these errors gracefully.

Throw a `TerminalError` in your handler to indicate a terminal failure:
```typescript {"CODE_LOAD::ts/src/tour/microservices/terminal_error.ts#terminal_error"} 
throw new TerminalError("Invalid credit card");
```

<Accordion title={"Configuring Retry Behavior"}>

    Some actions let you configure their retry behavior, for example to limit the number of retries of a run block:

```ts {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/retries/service.ts#retries"}
try {
    const policy = {
    maxRetryAttempts: 3,
    initialRetryIntervalMillis: 1000,
};
    await ctx.run("welcome", () => sendWelcomeEmail(user), policy);
} catch (error) {
    console.error("Failed to send welcome email after retries:", error);
}
```

    When the retries are exhausted, the run block will throw a `TerminalError`, that you can handle in your handler logic.

</Accordion>

Learn more with the [Error Handling Guide](/guides/error-handling).

## Sagas and rollback
On a terminal failure, Restate stops the execution of the handler.
You might, however, want to roll back the changes made by the workflow to keep your system in a consistent state.
This is where Sagas come in.

Sagas are a pattern for rolling back changes made by a handler when it fails.

In Restate, you can implement a saga by building a list of compensating actions for each step of the workflow.
On a terminal failure, you execute them in reverse order:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/sagas/service.ts?collapse_prequel"}
export const subscriptionSaga = restate.service({
  name: "SubscriptionSaga",
  handlers: {
    add: async (ctx: restate.Context, req: SubscriptionRequest) => {
      const compensations = [];
      try {
        const paymentId = ctx.rand.uuidv4();
        compensations.push(() =>
          ctx.run("undo-pay", () => removeRecurringPayment(paymentId)),
        );
        const payRef = await ctx.run("pay", () =>
          createRecurringPayment(req.creditCard, paymentId),
        );

        for (const subscription of req.subscriptions) {
          compensations.push(() =>
            ctx.run(`del-${subscription}`, () =>
              removeSubscription(req.userId, subscription),
            ),
          );
          await ctx.run(`add-${subscription}`, () =>
            createSubscription(req.userId, subscription, payRef),
          );
        }
      } catch (e) {
        if (e instanceof restate.TerminalError) {
          for (const compensation of compensations.reverse()) {
            await compensation();
          }
        }
        throw e;
      }
    },
  },
});
```

**Benefits with Restate:**
- The list of compensations can be recovered after a crash, and Restate knows which compensations still need to be run.
- Sagas always run till completion (success or complete rollback)
- Full trace of all operations and compensations
- No complex state machines needed

<Accordion title={"Try it out yourself!"}>
```bash
# Test the saga pattern
restate invoke SubscriptionSaga.add --json '{"userId": "user-456", "creditCard": "4111111111111111", "subscriptions": ["premium", "sports"]}'

# View execution in UI
open http://localhost:9070
```
The UI shows each saga step, results, and any compensations that ran.
</Accordion>

Learn more with the [Sagas Guide](/guides/sagas).

## Virtual Objects

Until now, the services we looked at did not share any state between requests.

To implement stateful entities like shopping carts, user profiles, or AI agents, Restate provides **Virtual Objects**.

Each Virtual Object instance maintains isolated state:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/objects/service.ts?collapse_prequel"} 
export const userSubscriptions = restate.object({
  name: "UserSubscriptions",
  handlers: {
    add: async (ctx: ObjectContext, subscription: string) => {
      // Get current subscriptions
      const subscriptions = (await ctx.get<string[]>("subscriptions")) ?? [];

      // Add new subscription
      if (!subscriptions.includes(subscription)) {
        subscriptions.push(subscription);
      }
      ctx.set("subscriptions", subscriptions);

      // Update metrics
      ctx.set("lastUpdated", ctx.date.toJSON());
    },

    getSubscriptions: async (ctx: ObjectSharedContext) => {
      return (await ctx.get<string[]>("subscriptions")) ?? [];
    },
  },
});
```

Restate ensures that your state is durable and consistent:
- Each object key processes requests sequentially (no race conditions)
- Only one handler can modify state at a time (no concurrent/lost writes)
- State changes are logged with Durable Execution and survive failures
- Different object keys can be processed in parallel

Virtual Objects are ideal for implementing any entity with mutable state.

## Resilient Service-to-Service Communication

Restate provides durable communication between services.

Restate supports three communication patterns:
- **Request-Response**: Wait for a response
- **One-Way Messages**: Fire-and-forget
- **Delayed Messages**: Schedule for later

All communication is durably logged and guaranteed to complete.

Imagine a handler which processes a concert ticket purchase, and calls multiple services to handle payment, ticket delivery, and reminders:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/communication/service.ts?collapse_prequel"} 
export const concertTicketingService = restate.service({
  name: "ConcertTicketingService",
  handlers: {
    buy: async (ctx: restate.Context, req: PurchaseTicketRequest) => {
      // Request-response call - wait for payment to complete
      const payRef = await ctx.serviceClient(paymentService).charge(req);

      // One-way message - fire and forget ticket delivery
      ctx.serviceSendClient(emailService).emailTicket(req);

      // Delayed message - schedule reminder for day before concert
      ctx
        .serviceSendClient(emailService)
        .sendReminder(req, sendOpts({ delay: dayBefore(req.concertDate) }));

      return `Ticket purchased successfully with payment reference: ${payRef}`;
    },
  },
});
```

Each of these calls is durable and will be retried upon failures.
The handler can finish execution without waiting for the ticket delivery or reminder to complete.
And each service can scale independently.

<Accordion title={"Try it out yourself!"}>
```bash
# Test service communication
restate invoke SubscriptionService.add --json '{"userId": "user-789", "creditCard": "4111111111111111", "subscriptions": ["basic"]}'

# Watch the flow in UI
open http://localhost:9070
```
</Accordion>

## Request Idempotency

Restate allows adding an idempotency header to your requests. It will then deduplicate requests with the same idempotency key, ensuring that they only execute once.

This can help us prevent duplicate calls the concert ticketing service if the user accidentally clicks "buy" multiple times.

Add an idempotency header to your request:

```shell
curl -X POST localhost:8080/ConcertTicketingService/buy \
  -H 'Idempotency-Key: unique-key-123' \
  --json '{"ticketId": "ticket-789", "price": 100, "customerEmail": "me@mail.com", "concertDateTime": "2023-10-01T20:00:00Z"}'
```

Notice how doing the same request with the same idempotency key will return the same response without re-executing the handler.

## External Events

Until now we showed either synchronous API calls via `ctx.run` or calls to other Restate services.

But some API calls may respond asynchronously, such as waiting for external systems to complete operations through webhooks or callbacks.

For this, you can use `awakeable`. It allows you to pause execution until an external system completes an operation, such as waiting for a payment processor to confirm a transaction.

Let's implement a payment processing flow where we initiate a payment with an external provider and wait for their webhook confirmation:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/events/service.ts?collapse_prequel"} 
export const asyncPaymentService = restate.service({
  name: "AsyncPaymentService",
  handlers: {
    processPayment: async (ctx: restate.Context, req: PaymentRequest) => {
      // Create awakeable to wait for webhook payment confirmation
      const confirmation = ctx.awakeable<PaymentResult>();

      // Initiate payment with external provider (Stripe, PayPal, etc.)
      await ctx.run("pay", () => initExternalPayment(req, confirmation.id));

      // Wait for external payment provider to call our webhook
      return confirmation.promise;
    },

    // Webhook handler called by external payment provider
    confirmPayment: async (
      ctx: restate.Context,
      confirmation: { id: string; result: PaymentResult },
    ) => {
      // Resolve the awakeable to continue the payment flow
      ctx.resolveAwakeable(confirmation.id, confirmation.result);
    },
  },
});
```

## Durable Timers

Durable timers let you add timeouts and scheduling to your workflows. They survive crashes and resume exactly when scheduled.

Let's extend our payment service to automatically cancel payments that don't complete within a reasonable time:

```typescript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/examples/refs/heads/new_tours/typescript/tutorials/tour-of-orchestration-typescript/src/timers/service.ts?collapse_prequel"} 
export const asyncPaymentServiceWithTimeout = restate.service({
  name: "AsyncPaymentServiceWithTimeout",
  handlers: {
    processPayment: async (ctx: restate.Context, req: PaymentRequest) => {
      const paymentConfirmation = ctx.awakeable<PaymentResult>();

      // Initiate payment with external provider
      const payRef = await ctx.run("init-payment", () =>
        initExternalPayment(req, paymentConfirmation.id),
      );

      // Race between payment confirmation and timeout
      try {
        return paymentConfirmation.promise.orTimeout({ minutes: 10 });
      } catch (e) {
        if (e instanceof TimeoutError) {
          // Cancel the payment with external provider
          await ctx.run("cancel-payment", () => cancelExternalPayment(payRef));
          return {
            success: false,
            errorMessage: "Payment timed out after 10 minutes",
          };
        }
        throw e;
      }
    },

    // Webhook handler called by external payment provider
    confirmPayment: async (
      ctx: restate.Context,
      confirmation: { awakeableId: string; result: PaymentResult },
    ) => {
      // Resolve the awakeable to continue the payment flow
      ctx.resolveAwakeable(confirmation.awakeableId, confirmation.result);
    },
  },
});
```

For more complex timer patterns like recurring reminders, see the [Timers Guide](/develop/ts/timers).

## Advanced Patterns

<CardGroup title="Advanced Patterns">
<Card title="Timers and Scheduling" icon="clock">
  Use durable timers for complex timing logic, such as sending reminders or handling timeouts.
</Card>
<Card title="Parallelize Work" icon="arrows-right-left">
  Run multiple operations concurrently, such as creating multiple subscriptions in parallel.
</Card>
<Card title="Cron Jobs" icon="arrows-right-left">
    Implement durable cron jobs that run at specific intervals, such as daily reports or periodic data processing.
</Card>
<Card title="Webhook Processing" icon="arrows-right-left">
    Point your webhooks to Restate handlers, which can then handle incoming requests with durable execution.
</Card>
</CardGroup>

## Summary

Restate simplifies microservice orchestration with:

- **Durable Execution**: Automatic failure recovery without complex retry logic
- **Sagas**: Distributed transactions with resilient compensation
- **Service Communication**: Reliable RPC and messaging between services  
- **Stateful Processing**: Consistent state management without external stores
- **Advanced Patterns**: Fault-tolerant timers, awakeables, and parallel execution

Build resilient distributed systems without the typical complexity.
