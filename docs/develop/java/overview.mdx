---
title: "Services"
description: "Implementing Restate services with the Java/Kotlin SDK."
icon: "brackets-curly"
---

The Restate Java/Kotlin SDK is open source and available on [GitHub](https://github.com/restatedev/sdk-java).

The Restate SDK lets you implement **handlers**. Handlers can be part of a **[Basic Service](/basics/services#basic-service)**, a **[Virtual Object](/basics/services#virtual-object)**, or a **[Workflow](/basics/services#workflow)**. This page shows how to define them with the Java/Kotlin SDK.

## Prerequisites
- [JDK](https://whichjdk.com/) >= 17

<Info>Contact us on [Discord](https://discord.com/invite/skW3AZ6uGd)/[Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA) if you need earlier Java versions.</Info>

## Getting started
<Tip>
    Get started quickly with the [Java](/quickstart#java) or [Kotlin](/quickstart#kotlin) Quickstart.
</Tip>

Add the following dependencies to your project to start developing Restate services:
- `dev.restate:sdk-java-http` for Java API + HTTP endpoint ([build.gradle.kts](https://github.com/restatedev/examples/blob/main/java/templates/java-gradle/build.gradle.kts)/[pom.xml](https://github.com/restatedev/examples/blob/main/java/templates/java-maven/pom.xml))
- `dev.restate:sdk-java-lambda` for Java API + Lambda endpoint
- `dev.restate:sdk-kotlin-http` for Kotlin API + HTTP endpoint ([build.gradle.kts](https://github.com/restatedev/examples/blob/main/kotlin/templates/kotlin-gradle/build.gradle.kts))
- `dev.restate:sdk-kotlin-lambda` for Kotlin API + Lambda endpoint

Additionally, you need the code generator to generate service clients `dev.restate:sdk-api-gen`.

For example:
<CodeGroup>
```kt Java
// Code generator
annotationProcessor("dev.restate:sdk-api-gen:2.0.0")

// Java API + HTTP endpoint
implementation("dev.restate:sdk-java-http:2.0.0")
```
```kt Kotlin
// Code generator
ksp("dev.restate:sdk-api-kotlin-gen:2.0.0")

// Kotlin API + HTTP endpoint
implementation("dev.restate:sdk-kotlin-http:2.0.0")
```
</CodeGroup>
## Basic Services

[Basic Services](/basics/services) group related **handlers** and expose them as callable endpoints:

<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/MyService.java?collapse_prequel"} 
@Service
public class MyService {
  @Handler
  public String myHandler(Context ctx, String greeting) {
    return greeting + "!";
  }

  public static void main(String[] args) {
    RestateHttpServer.listen(Endpoint.bind(new MyService()));
  }
}
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/MyService.kt?collapse_prequel"} 
@Service
class MyService {
  @Handler
  suspend fun myHandler(ctx: Context, greeting: String): String {
    return "$greeting!"
  }
}

fun main() {
  RestateHttpServer.listen(endpoint { bind(MyService()) })
}
```
</CodeGroup>

* Define a service using the [`@Service`](http://docs.restate.dev/javadocs/dev/restate/sdk/annotation/Service.html) and [`@Handler`](http://docs.restate.dev/javadocs/dev/restate/sdk/annotation/Handler.html) annotations
* Each handler can be called at `<RESTATE_INGRESS>/MyService/myHandler`. To override the service name (default is simple class name), use the annotation [`@Name`](http://docs.restate.dev/javadocs/dev/restate/sdk/annotation/Name.html).
* Handlers take the `Context` ([JavaDocs](https://docs.restate.dev/javadocs/dev/restate/sdk/ObjectContext)/[KotlinDocs](https://docs.restate.dev/ktdocs/sdk-api-kotlin/dev.restate.sdk.kotlin/-context/)) as the first argument.
* The input parameter (at most one) and return type are optional and can be of any type. See [serialization](/develop/java/serialization) for more details.
* Create an endpoint to expose the service over HTTP (port `9080` by default).

## Virtual Objects

[Virtual Objects](/basics/services) are services that are stateful and key-addressable â€” each object instance has a unique ID and persistent state.

<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/MyVirtualObject.java?collapse_prequel"} 
@VirtualObject
public class MyVirtualObject {

  @Handler
  public String myHandler(ObjectContext ctx, String greeting) {
    String objectId = ctx.key();

    return greeting + " " + objectId + "!";
  }

  @Shared
  public String myConcurrentHandler(SharedObjectContext ctx, String input) {
    return "my-output";
  }

  public static void main(String[] args) {
    RestateHttpServer.listen(Endpoint.bind(new MyVirtualObject()));
  }
}
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/MyVirtualObject.kt?collapse_prequel"} 
@VirtualObject
class MyVirtualObject {

  @Handler
  suspend fun myHandler(ctx: ObjectContext, greeting: String): String {
    val objectKey = ctx.key()

    return "$greeting $objectKey!"
  }

  @Shared
  suspend fun myConcurrentHandler(ctx: SharedObjectContext, input: String): String {
    return "my-output"
  }
}

fun main() {
  RestateHttpServer.listen(endpoint { bind(MyVirtualObject()) })
}
```
</CodeGroup>

* Use the `@VirtualObject` annotation.
* The first argument of the handler must be the `ObjectContext` parameter ([JavaDocs](https://docs.restate.dev/javadocs/dev/restate/sdk/ObjectContext)/[KotlinDocs](https://docs.restate.dev/ktdocs/sdk-api-kotlin/dev.restate.sdk.kotlin/-object-context/)).
* Each instance is identified by a key (accessible via `ctx.key()`).
* Virtual Objects can have [exclusive and shared handlers](/basics/functions#handler-behavior).
* Exclusive handlers receive an `ObjectContext`, allowing read/write access to object state.
* Shared handlers use the [`@Shared`](http://docs.restate.dev/javadocs/dev/restate/sdk/annotation/Shared.html) annotation and the `SharedObjectContext` ([JavaDocs](https://docs.restate.dev/javadocs/dev/restate/sdk/SharedObjectContext)/[KotlinDocs](https://docs.restate.dev/ktdocs/sdk-api-kotlin/dev.restate.sdk.kotlin/-shared-object-context/)).

## Workflows

[Workflows](/basics/services) are long-lived processes with a defined lifecycle. They run once per key and are ideal for orchestrating multi-step operations, which require external interaction via signals and queries.

<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/MyWorkflow.java?collapse_prequel"} 
@Workflow
public class MyWorkflow {

  @Workflow
  public String run(WorkflowContext ctx, String input) {

    // implement workflow logic here

    return "success";
  }

  @Shared
  public void interactWithWorkflow(SharedWorkflowContext ctx, String input) {
    // implement interaction logic here
  }

  public static void main(String[] args) {
    RestateHttpServer.listen(Endpoint.bind(new MyWorkflow()));
  }
}
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/MyWorkflow.kt?collapse_prequel"} 
@Workflow
class MyWorkflow {

  @Workflow
  suspend fun run(ctx: WorkflowContext, input: String): String {
    // implement workflow logic here

    return "success"
  }

  @Handler
  suspend fun interactWithWorkflow(ctx: SharedWorkflowContext, input: String) {
    // implement interaction logic here
  }
}

fun main() {
  RestateHttpServer.listen(endpoint { bind(MyWorkflow()) })
}
```
</CodeGroup>

* Create the workflow by using the [`@Workflow`](http://docs.restate.dev/javadocs/dev/restate/sdk/annotation/Workflow.html) annotation.
* Every workflow **must** include a `run` handler:
  * This is the main orchestration entry point
  * It runs exactly once per workflow execution and uses the `WorkflowContext` ([JavaDocs](https://docs.restate.dev/javadocs/dev/restate/sdk/WorkflowContext)/[KotlinDocs](https://docs.restate.dev/ktdocs/sdk-api-kotlin/dev.restate.sdk.kotlin/-workflow-context/))
  * Use `ctx.key()` to access the workflow's unique ID
* Additional handlers must use the `SharedWorkflowContext` ([JavaDocs](https://docs.restate.dev/javadocs/dev/restate/sdk/SharedWorkflowContext)/[KotlinDocs](https://docs.restate.dev/ktdocs/sdk-api-kotlin/dev.restate.sdk.kotlin/-shared-workflow-context/)) and can signal or query the workflow. They can run concurrently with the `run` handler and until the retention time expires.

## Configuring services
Check out the [service configuration docs](/operate/configuration/services) to learn how to configure service behavior, including timeouts and retention policies.