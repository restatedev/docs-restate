---
title: "Concurrent Tasks"
description: "Execute multiple tasks concurrently and gather results."
icon: "merge"
---

import ConcurrentTaskIntro from "/snippets/sdk/concurrent-tasks-intro.mdx";

<ConcurrentTaskIntro/>

## Parallelizing tasks

Start multiple durable operations concurrently by calling them without immediately awaiting:

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#parallel"} 
// Start operations concurrently using DurableFuture
var call1 = ctx.runAsync(UserData.class, () -> fetchUserData(123));
var call2 = ctx.runAsync(OrderHistory.class, () -> fetchOrderHistory(123));
var call3 = AnalyticsServiceClient.fromContext(ctx).calculateMetric(123);

// Now wait for results as needed
UserData user = call1.await();
OrderHistory orders = call2.await();
Integer metric = call3.await();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#parallel"} 
val call1 = ctx.runAsync<UserData> { fetchUserData(123) }
val call2 = ctx.runAsync<OrderHistory> { fetchOrderHistory(123) }
val call3 = AnalyticsServiceClient.fromContext(ctx).calculateMetric(123)

// Now wait for results as needed
val user: UserData = call1.await()
val orders: OrderHistory = call2.await()
val metric: Int = call3.await()
```
</CodeGroup>

Check out the guide on [parallelizing work](guides/parallelizing-work).

## Retrieving results

Restate provides several patterns for coordinating concurrent tasks. All patterns use `DurableFuture` combinators that log the order of completion, ensuring deterministic behavior during replays.

### Wait for the first completion
**Select** creates a `DurableFuture` that returns on the first completed `DurableFuture` of the provided ones.
The semantics are similar to [`CompleteableFuture.anyOf()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html#anyOf(java.util.concurrent.CompletableFuture...)), but the outcome is stored in the Restate journal to be deterministically replayable.

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#combine_any"} 
boolean res = Select.<Boolean>select().or(a1).or(a2).or(a3).await();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#combine_any"} 
val resSelect =
    select {
          a1.onAwait { it }
          a2.onAwait { it }
          a3.onAwait { it }
        }
        .await()
```
</CodeGroup>

### Wait for all tasks to complete

**Await all** creates a `DurableFuture` that awaits for all the provided DurableFutures to resolve.
The semantics are similar to [`CompleteableFuture.allOf()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)), but the outcome is stored in the Restate journal to be deterministically replayable.

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#combine_all"} 
DurableFuture.all(a1, a2, a3).await();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#combine_all"} 
listOf(a1, a2, a3).awaitAll()
```
</CodeGroup>

