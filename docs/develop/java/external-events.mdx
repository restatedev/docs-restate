---
title: "External Events"
description: "Handle external events and human-in-the-loop patterns with durable waiting primitives."
icon: "hourglass-start"
---

import AwakeablesIntro from "/snippets/sdk/awakeables-intro.mdx";
import AwakeablesOutro from "/snippets/sdk/awakeables-outro.mdx";

<AwakeablesIntro/>

### Creating and waiting for awakeables
1. **Create an awakeable** - Get a unique ID and Future
2. **Send the ID externally** - Pass the awakeable ID to your external system
3. **Wait for result** - Your handler [suspends](/foundations/key-concepts#suspensions-on-faas) until the external system responds

<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/Awakeables.java#here"} 
// Create awakeable and get unique ID
Awakeable<String> awakeable = ctx.awakeable(String.class);
String awakeableId = awakeable.id();

// Send ID to external system (email, queue, webhook, etc.)
ctx.run(() -> requestHumanReview(name, awakeableId));

// Handler suspends here until external completion
String review = awakeable.await();
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/Awakeables.kt#here"} 
// Create awakeable and get unique ID
val awakeable = ctx.awakeable<String>()
val awakeableId: String = awakeable.id

// Send ID to external system (email, queue, webhook, etc.)
ctx.runBlock { requestHumanReview(awakeableId) }

// Handler suspends here until external completion
val review: String = awakeable.await()
```

</CodeGroup>

<Accordion title="Serialization">
  To customize serialization, visit the [docs](/develop/java/serialization).
</Accordion>

<Info>
    Note that if you wait for an awakeable in an [exclusive handler](/foundations/functions#handler-behavior) in a Virtual Object, all other calls to this object will be queued.
</Info>

### Resolving/rejecting Awakeables

External processes complete awakeables in two ways:

- **Resolve** with success data → handler continues normally
- **Reject** with error reason → throws a [terminal error](/develop/java/error-handling) in the waiting handler

#### Via HTTP API

External systems can complete awakeables using Restate's HTTP API:

**Resolve with data:**
```shell
curl localhost:8080/restate/awakeables/sign_1PePOqp/resolve \
  --json '"Looks good!"'
```

**Reject with error:**
```shell
curl localhost:8080/restate/awakeables/sign_1PePOqp/reject \
  -H 'content-type: text/plain' \
  -d 'Review rejected: insufficient documentation'
```

#### Via SDK (from other handlers)

**Resolve:**
<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/Awakeables.java#resolve"} 
// Complete with success data
ctx.awakeableHandle(awakeableId).resolve(String.class, "Looks good!");
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/Awakeables.kt#resolve"} 
// Complete with success data
ctx.awakeableHandle(awakeableId).resolve("Looks good!")
```
</CodeGroup>

**Reject:**
<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/Awakeables.java#reject"} 
// Complete with error
ctx.awakeableHandle(awakeableId).reject("This cannot be reviewed.");
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/Awakeables.kt#reject"} 
// Complete with error
ctx.awakeableHandle(awakeableId).reject("This cannot be reviewed.")
```
</CodeGroup>

## Durable Promises

**Best for:** Workflows where you need to signal between different workflow handlers.

**Key differences from awakeables:**
- No ID management - use logical names instead
- Scoped to workflow execution lifetime

Use this for:
- Sending data to the run handler
- Have handlers wait for events emitted by the run handler

<Info>
After a workflow's run handler completes, other handlers can still be called for up to 24 hours (default).
The results of resolved Durable Promises remain available during this time.
Update the retention time via the [service configuration](/services/configuration).
</Info>

### Creating and waiting for promises
Create a promise key:
<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/ReviewWorkflow.java#promise_key"} 
private static final DurablePromiseKey<String> REVIEW_PROMISE =
    DurablePromiseKey.of("review", String.class);
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/ReviewWorkflow.kt#promise_key"} 
val REVIEW_PROMISE = durablePromiseKey<String>("review")
```
</CodeGroup>

Wait for a promise by name:
<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/ReviewWorkflow.java#promise"} 
String review = ctx.promise(REVIEW_PROMISE).future().await();
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/ReviewWorkflow.kt#promise"} 
val review: String = ctx.promise(REVIEW_PROMISE).future().await()
```
</CodeGroup>

Your workflow can [suspend](/foundations/key-concepts#suspensions-on-faas) until the promise is resolved or rejected.

### Resolving/rejecting promises
Resolve/reject from any workflow handler:
<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/ReviewWorkflow.java#resolve_promise"} 
ctx.promiseHandle(REVIEW_PROMISE).resolve(review);
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/ReviewWorkflow.kt#resolve_promise"} 
ctx.promiseHandle(REVIEW_PROMISE).resolve(review)
```
</CodeGroup>


### Complete workflow example

<CodeGroup>
```java Java expandable {"CODE_LOAD::java/src/main/java/develop/ReviewWorkflow.java#here"} 
@Workflow
public class ReviewWorkflow {
  private static final DurablePromiseKey<String> REVIEW_PROMISE =
      DurablePromiseKey.of("review", String.class);


  @Workflow
  public String run(WorkflowContext ctx, String documentId) {
    // Send document for review
    ctx.run(() -> askReview(documentId));

    // Wait for external review submission
    String review = ctx.promise(REVIEW_PROMISE).future().await();

    // Process the review result
    return processReview(documentId, review);
  }

  @Shared
  public void submitReview(SharedWorkflowContext ctx, String review) {
    // Signal the waiting run handler
    ctx.promiseHandle(REVIEW_PROMISE).resolve(review);
  }
}
```
```kotlin Kotlin expandable {"CODE_LOAD::kotlin/src/main/kotlin/develop/ReviewWorkflow.kt#here"} 
@Workflow
class ReviewWorkflow {

  companion object {
    val REVIEW_PROMISE = durablePromiseKey<String>("review")
  }

  @Workflow
  suspend fun run(ctx: WorkflowContext, documentId: String): String {
    // Send document for review
    ctx.runBlock { askReview(documentId) }

    // Wait for external review submission
    val review: String = ctx.promise(REVIEW_PROMISE).future().await()

    // Process the review result
    return processReview(documentId, review)
  }

  @Shared
  suspend fun submitReview(ctx: SharedWorkflowContext, review: String) {
    // Signal the waiting run handler
    ctx.promiseHandle(REVIEW_PROMISE).resolve(review)
  }
}
```
</CodeGroup>

<AwakeablesOutro/>