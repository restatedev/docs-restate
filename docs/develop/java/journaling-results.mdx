---
title: "Durable Steps"
description: "Persist results of operations."
icon: "list-check"
---

Restate uses an execution log to replay operations after failures and suspensions. Non-deterministic operations (database calls, HTTP requests, UUID generation) must be wrapped to ensure deterministic replay.

## Run

Use `ctx.run` to safely wrap any non-deterministic operation, like HTTP calls or database responses, and have Restate store its result in the execution log.

<CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#side_effect"} 
String output = ctx.run(String.class, () -> doDbRequest());
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#side_effect"} 
val output: String = ctx.runBlock { doDbRequest() }
```
</CodeGroup>

Note that inside `ctx.run`, you cannot use the Restate context (e.g., `ctx.get`, `ctx.sleep`, or nested `ctx.run`).

<AccordionGroup>

    <Accordion title="Asynchronous run actions">
        To run an action asynchronously, use `ctx.runAsync`:
        <CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#async_side_effect"}
DurableFuture<String> myRunFuture = ctx.runAsync(String.class, () -> doSomethingSlow());
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#async_side_effect"}
val myRunFuture: DurableFuture<String> = ctx.runAsync { doSomethingSlow() }
```
        </CodeGroup>

        You can use this to combine your run actions with other asynchronous operations, like waiting for a timer or an awakeable.

        Check out [Durable Futures combinators](#durablefuture-combinators).

    </Accordion>

    <Accordion title="Serialization">
        Have a look at the [serialization docs](/develop/java/serialization) to learn how to serialize and deserialize your objects.
    </Accordion>

    <Accordion title="Error handling and retry policies">

        Failures in `ctx.run` are treated the same as any other handler error. Restate will retry it unless configured otherwise or unless a [`TerminalError`](/develop/ts/error-handling) is thrown.


        You can customize how `ctx.run` retries via:

        <CodeGroup>
```java Java {"CODE_LOAD::java/src/main/java/develop/RetryRunService.java#here"} 
try {
  RetryPolicy myRunRetryPolicy =
      RetryPolicy.defaultPolicy()
          .setInitialDelay(Duration.ofMillis(500))
          .setExponentiationFactor(2)
          .setMaxDelay(Duration.ofSeconds(10))
          .setMaxAttempts(10)
          .setMaxDuration(Duration.ofMinutes(5));
  ctx.run("my-run", myRunRetryPolicy, () -> writeToOtherSystem());
} catch (TerminalException e) {
  // Handle the terminal error after retries exhausted
  // For example, undo previous actions (see sagas guide) and
  // propagate the error back to the caller
}
```
```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/RetryRunService.kt#here"} 
try {
  val myRunRetryPolicy =
      RetryPolicy(
          initialDelay = 5.seconds,
          exponentiationFactor = 2.0f,
          maxDelay = 60.seconds,
          maxAttempts = 10,
          maxDuration = 5.minutes)
  ctx.runBlock("write", myRunRetryPolicy) { writeToOtherSystem() }
} catch (e: TerminalException) {
  // Handle the terminal error after retries exhausted
  // For example, undo previous actions (see sagas guide) and
  // propagate the error back to the caller
  throw e
}
```
        </CodeGroup>

        * You can limit retries by time or count
        * When the policy is exhausted, a `TerminalError` is thrown
        * See the [Error Handling Guide](/guides/error-handling) and the [Sagas Guide](/guides/sagas) for patterns like compensation

    </Accordion>
    <Accordion title="Increasing timeouts">
        If Restate doesn't receive new journal entries from a service for more than one minute (by default), it will automatically abort the invocation and retry it.

        However, some business logic can take longer to complete—for example, an LLM call that takes up to 3 minutes to respond.

        In such cases, you can adjust the service’s [abort timeout](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#aborttimeout) and [inactivity timeout](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#inactivitytimeout) settings to accommodate longer execution times.

        For more information, see the [error handling guide](/guides/error-handling).
    </Accordion>

</AccordionGroup>

## Deterministic randoms

The SDK provides deterministic helpers for random values — seeded by the invocation ID — so they return the **same result on retries**.

### UUIDs

To generate stable UUIDs for things like idempotency keys:

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#uuid"} 
UUID uuid = ctx.random().nextUUID();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#uuid"} 
val uuid: UUID = ctx.random().nextUUID()
```
</CodeGroup>

Do not use this in cryptographic contexts.

### Random numbers

To generate a deterministic float between `0` and `1`:

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#random_nb"} 
int value = ctx.random().nextInt();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#random_nb"} 
val value: Int = ctx.random().nextInt()
```
</CodeGroup>


This behaves like `Math.random()` but is deterministically replayable.

## `DurableFuture` combinators

To run multiple operations concurrently and deterministically, use `DurableFuture` combinators.
Restate then logs the order in which they get resolved or rejected so they are deterministic on replay.

**Await all** creates a `DurableFuture` that awaits for all the provided DurableFutures to resolve.
The semantics are similar to [`CompleteableFuture.allOf()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html#allOf(java.util.concurrent.CompletableFuture...)), but the outcome is stored in the Restate journal to be deterministically replayable.

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#combine_all"} 
DurableFuture.all(a1, a2, a3).await();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#combine_all"} 
listOf(a1, a2, a3).awaitAll()
```
</CodeGroup>

**Select** creates a `DurableFuture` that returns on the first completed `DurableFuture` of the provided ones.
The semantics are similar to [`CompleteableFuture.anyOf()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html#anyOf(java.util.concurrent.CompletableFuture...)), but the outcome is stored in the Restate journal to be deterministically replayable.

<CodeGroup>
    ```java Java {"CODE_LOAD::java/src/main/java/develop/JournalingResults.java#combine_any"} 
boolean res = Select.<Boolean>select().or(a1).or(a2).or(a3).await();
```
    ```kotlin Kotlin {"CODE_LOAD::kotlin/src/main/kotlin/develop/JournalingResults.kt#combine_any"} 
val resSelect =
    select {
          a1.onAwait { it }
          a2.onAwait { it }
          a3.onAwait { it }
        }
        .await()
```
</CodeGroup>