---
title: "Scheduling & Timers"
description: "Durable timers, scheduled actions, and sleep, backed by Restate."
icon: "timer"
---

import TimersIntro from "/snippets/sdk/timers-intro.mdx";

<TimersIntro/>

## Durable sleep
To pause a handler for a set duration:

```python {"CODE_LOAD::python/src/develop/durable_timers.py#here"} 
await ctx.sleep(delta=timedelta(seconds=10))
```

<Info>
    Note that if you sleep in an [exclusive handler](/basics/functions#handler-behavior) in a Virtual Object, all other calls to this object will be queued.
</Info>

<Accordion title="Clock synchronization Restate Server vs. SDK">
    The Restate SDK calculates the wake-up time based on the delay you specify.
    The Restate Server then uses this calculated time to wake up the handler.
    If the Restate Server and the SDK have different system clocks, the sleep duration might not be accurate.
    So make sure that the system clock of the Restate Server and the SDK have the same timezone and are synchronized.
    A mismatch can cause timers to fire earlier or later than expected.
</Accordion>

## Scheduling async tasks

To invoke a handler at a later time, use [delayed messages](/develop/python/service-communication#delayed-messages).

<Accordion title={"Delayed messages vs. sleep and send"}>

In theory, you can schedule future work in Restate in two ways:
1. **Delayed messages** (recommended)
2. **Sleep + send** - sleeping in the current handler, then sending a message

At first sight, both approaches might seem to achieve similar results.
However, we recommend to use delayed messages for the following reasons:

- **Handler completes immediately**: The calling handler can finish execution and complete the invocation without waiting for the delay to finish
- **No Virtual Object blocking**: Other requests to the same Virtual Object can be processed during the delay period
- **Better for service versioning**: No long-running invocations that require keeping old service deployments around for a long time (see [service versioning](/operate/registration))
</Accordion>

## Timers and timeouts

Most context actions are async actions that return a `RestateDurableFuture`.

You can race these against a timer to bound how long your code waits for an operation.

For example, to either wait for the greeting or for the timeout:

```py {"CODE_LOAD::python/src/develop/durable_timers.py#timer"} 
match await restate.select(
    greeting=ctx.service_call(my_service.my_handler, "Hi"),
    timeout=ctx.sleep(timedelta(seconds=5)),
):
    case ["greeting", greeting]:
        print("Greeting:", greeting)
    case ["timeout", _]:
        print("Timeout occurred")
```

For alternative ways of racing async operations, have a look at the [`RestateDurableFuture` Combinators](/develop/python/journaling-results#restatedurablefuture-combinators).

## Cron jobs

Restate does not yet include native cron support, but you can implement your own cron scheduler using:
- Durable timers
- Virtual Objects
- A repeat loop or sleep-schedule pattern

Check out the guide on [implementing cron jobs](/guides/cron-jobs).