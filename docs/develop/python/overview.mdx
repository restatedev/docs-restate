---
title: "Services"
description: "Implementing Restate services with the TypeScript SDK."
icon: "brackets-curly"
---


The Restate Python SDK is open source and available on [GitHub](https://github.com/restatedev/sdk-python).

The Restate SDK lets you implement **handlers**. Handlers can be part of a **[Basic Service](/basics/services#basic-service)**, a **[Virtual Object](/basics/services#virtual-object)**, or a **[Workflow](/basics/services#workflow)**. This page shows how to define them with the Python SDK.

## Prerequisites
- Python >= v3.11

## Getting started
<Tip>
    Get started quickly with the [Python Quickstart](/quickstart#python).
</Tip>

Add the `restate_sdk[serde]` dependency to your Python project to start developing Restate services.


## Basic Services

[Basic Services](/basics/services) group related **handlers** and expose them as callable endpoints:

```python {"CODE_LOAD::python/src/develop/my_service.py"} 
import restate

my_service = restate.Service("MyService")


@my_service.handler("myHandler")
async def my_handler(ctx: restate.Context, greeting: str) -> str:
    return f"${greeting}!"


app = restate.app([my_service])
```


* Define a service using [`restate.service`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.service).
* The service has a name and a list of handlers.
* Each handler has a name and can be called at `<RESTATE_INGRESS>/myService/myHandler`
* Handlers take the [`Context`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context) as the first argument.
* Handlers can take one optional JSON-serializable input and must return a JSON-serializable output (see [custom serialization](/develop/ts/serialization) for advanced types).
* Create an endpoint to expose the service over HTTP (port `9080` by default).

## Virtual Objects

[Virtual Objects](/basics/services) are services that are stateful and key-addressable â€” each object instance has a unique ID and persistent state.

```python {"CODE_LOAD::python/src/develop/my_virtual_object.py"} 
import restate

my_object = restate.VirtualObject("MyVirtualObject")


@my_object.handler("myHandler")
async def my_handler(ctx: restate.ObjectContext, greeting: str) -> str:
    return f"${greeting} ${ctx.key()}!"


@my_object.handler(kind="shared")
async def my_concurrent_handler(ctx: restate.ObjectSharedContext, greeting: str) -> str:
    return f"${greeting} ${ctx.key()}!"


app = restate.app([my_object])
```

* Define a Virtual Object using [`restate.object(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.object)
* Each instance is identified by a key (accessible via `ctx.key`).
* Virtual Objects can have [exclusive and shared handlers](/basics/functions#handler-behavior).
* Exclusive handlers receive an [`ObjectContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext), allowing read/write access to object state.
* Shared handlers are wrapped in `handlers.object.shared(...)` and use the [`ObjectSharedContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectSharedContext)


## Workflows

[Workflows](/basics/services) are long-lived processes with a defined lifecycle. They run once per key and are ideal for orchestrating multi-step operations, which require external interaction via signals and queries.

```python {"CODE_LOAD::python/src/develop/my_workflow.py"} 
import restate

my_workflow = restate.Workflow("MyWorkflow")


@my_workflow.main()
async def run(ctx: restate.WorkflowContext, req: str) -> str:
    # ... implement workflow logic here ---
    return "success"


@my_workflow.handler()
async def interact_with_workflow(ctx: restate.WorkflowSharedContext, req: str):
    # ... implement interaction logic here ...
    return


app = restate.app([my_workflow])
```

* Define a workflow with [`restate.workflow(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.workflow)
* Every workflow **must** include a `run` handler:
  * This is the main orchestration entry point
  * It runs exactly once per workflow execution and uses the [`WorkflowContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.WorkflowContext)
  * Use `ctx.key` to access the workflow's unique ID
* Additional handlers must use the [`WorkflowSharedContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.WorkflowSharedContext) and can signal or query the workflow. They can run concurrently with the `run` handler and until the retention time expires.

## Configuring services
Check out the [service configuration docs](/operate/configuration/services) to learn how to configure service behavior, including timeouts and retention policies.