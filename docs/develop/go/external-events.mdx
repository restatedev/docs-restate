---
title: "External Events"
description: "Handle external events and human-in-the-loop patterns with durable waiting primitives."
icon: "hourglass-start"
---

import AwakeablesIntro from "/snippets/sdk/awakeables-intro.mdx";
import AwakeablesOutro from "/snippets/sdk/awakeables-outro.mdx";

<AwakeablesIntro/>

### Creating and waiting for awakeables
1. **Create an awakeable** - Get a unique ID and promise
2. **Send the ID externally** - Pass the awakeable ID to your external system
3. **Wait for result** - Your handler [suspends](/foundations/key-concepts#suspensions-on-faas) until the external system responds

```go {"CODE_LOAD::go/develop/awakeable.go#here"} 
awakeable := restate.Awakeable[string](ctx)
awakeableId := awakeable.Id()

if _, err := restate.Run(ctx, func(ctx restate.RunContext) (string, error) {
  return requestHumanReview(awakeableId)
}); err != nil {
  return err
}

review, err := awakeable.Result()
if err != nil {
  return err
}
```

<Accordion title="Serialization">
    You can resolve an awakeable with any payload that can be serialized. By default,
    serialization is done with [`JSONCodec`](https://pkg.go.dev/github.com/restatedev/sdk-go/encoding#PayloadCodec)
    which uses `encoding/json`. If you don't need to provide anything, you can
    use `restate.Void{}` which serializes to a nil byte slice.
</Accordion>

<Info>
    Note that if you wait for an awakeable in an [exclusive handler](/foundations/functions#handler-behavior) in a Virtual Object, all other calls to this object will be queued.
</Info>

### Resolving/rejecting Awakeables

External processes complete awakeables in two ways:

- **Resolve** with success data → handler continues normally
- **Reject** with error reason → throws a [terminal error](/develop/go/error-handling) in the waiting handler

#### Via HTTP API

External systems can complete awakeables using Restate's HTTP API:

**Resolve with data:**
```shell
curl localhost:8080/restate/awakeables/sign_1PePOqp/resolve \
  --json '"Looks good!"'
```

**Reject with error:**
```shell
curl localhost:8080/restate/awakeables/sign_1PePOqp/reject \
  -H 'content-type: text/plain' \
  -d 'Review rejected: insufficient documentation'
```

#### Via SDK (from other handlers)

**Resolve:**
```go {"CODE_LOAD::go/develop/awakeable.go#resolve"} 
restate.ResolveAwakeable(ctx, awakeableId, "Looks good!")
```

**Reject:**
```go {"CODE_LOAD::go/develop/awakeable.go#reject"} 
restate.RejectAwakeable(ctx, awakeableId, fmt.Errorf("Cannot do review"))
```

## Durable Promises

**Best for:** Workflows where you need to signal between different workflow handlers.

**Key differences from awakeables:**
- No ID management - use logical names instead
- Scoped to workflow execution lifetime

Use this for:
- Sending data to the run handler
- Have handlers wait for events emitted by the run handler

<Info>
After a workflow's run handler completes, other handlers can still be called for up to 24 hours (default).
The results of resolved Durable Promises remain available during this time.
Update the retention time via the [service configuration](/operate/configuration/services).
</Info>

### Creating and waiting for promises

Wait for a promise by name:

```go {"CODE_LOAD::go/develop/durablepromise.go#promise"} 
review, err := restate.Promise[string](ctx, "review").Result()
```

### Resolving/rejecting promises

Resolve/reject from any workflow handler:
```go {"CODE_LOAD::go/develop/durablepromise.go#resolve_promise"} 
err := restate.Promise[string](ctx, "review").Resolve(review)
if err != nil {
  return err
}
```

### Complete workflow example

```go expandable {"CODE_LOAD::go/develop/durablepromise.go#review"} 
type ReviewWorkflow struct{}

func (ReviewWorkflow) Run(ctx restate.WorkflowContext, documentId string) (string, error) {
  // Send document for review
  if _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return restate.Void{}, askReview(documentId)
  }); err != nil {
    return "", err
  }

  // Wait for external review submission
  review, err := restate.Promise[string](ctx, "review").Result()
  if err != nil {
    return "", err
  }

  // Process the review result
  return processReview(documentId, review)
}

func (ReviewWorkflow) SubmitReview(ctx restate.WorkflowSharedContext, review string) error {
  // Signal the waiting run handler
  return restate.Promise[string](ctx, "review").Resolve(review)
}
```

<AwakeablesOutro/>