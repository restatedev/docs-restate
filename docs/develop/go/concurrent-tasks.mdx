---
title: "Concurrent Tasks"
description: "Execute multiple tasks concurrently and gather results."
icon: "merge"
---


import ConcurrentTaskIntro from "/snippets/sdk/concurrent-tasks-intro.mdx";

<ConcurrentTaskIntro/>

## Parallelizing tasks
Start multiple durable operations concurrently by calling them without immediately awaiting:

```go {"CODE_LOAD::go/develop/journalingresults.go#parallel"} 
call1 := restate.RunAsync(ctx, func(ctx restate.RunContext) (UserData, error) {
  return fetchUserData(123)
})
call2 := restate.RunAsync(ctx, func(ctx restate.RunContext) (OrderHistory, error) {
  return fetchOrderHistory(123)
})
call3 := restate.Service[int](ctx, "AnalyticsService", "CalculateMetrics").RequestFuture(123)

user, _ := call1.Result()
orders, _ := call2.Result()
metrics, _ := call3.Response()
```

Check out the guide on [parallelizing work](guides/parallelizing-work).

## Retrieving results

Operations such as calls, awakeables, and `restate.After` return futures which can
be safely selected over using `restate.Select`. Restate will log the order in which they complete, to make this deterministic on replay.

<Warning>
    **Don't use Go routines**:

    Do not try to combine blocking Restate operations using goroutines, channels or select statements. These cannot be used deterministically, and will likely lead to non-determinism errors upon replay. The only place it is safe to use these types is inside of a restate.Run function.
</Warning>

### Select the first successful completion

```go {"CODE_LOAD::go/develop/journalingresults.go#race"} 
sleepFuture := restate.After(ctx, 100*time.Millisecond)
callFuture := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi")

selector := restate.Select(ctx, sleepFuture, callFuture)
switch selector.Select() {
case sleepFuture:
  if err := sleepFuture.Done(); err != nil {
    return "", err
  }
  return "sleep won", nil
case callFuture:
  result, err := callFuture.Response()
  if err != nil {
    return "", err
  }
  return fmt.Sprintf("call won with result: %s", result), nil
}
```

Select blocks on the next completed operation or returns `nil` if there are none left.

### Wait for all tasks to complete

```go {"CODE_LOAD::go/develop/journalingresults.go#all"} 
callFuture1 := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi")
callFuture2 := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi again")

selector := restate.Select(ctx, callFuture1, callFuture2)

// Collect all results
var subResults []string
for selector.Remaining() {
  response, err := selector.Select().(restate.ResponseFuture[string]).Response()
  if err != nil {
    return "", err
  }
  subResults = append(subResults, response)
}
```

