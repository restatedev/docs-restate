---
title: "Concurrent Tasks"
description: "Execute multiple tasks concurrently and gather results."
icon: "merge"
---


import ConcurrentTaskIntro from "/snippets/sdk/concurrent-tasks-intro.mdx";

<ConcurrentTaskIntro/>

## Parallelizing tasks
Start multiple durable operations concurrently by calling them without immediately awaiting:

```go {"CODE_LOAD::go/develop/journalingresults.go#parallel"} 
call1 := restate.RunAsync(ctx, func(ctx restate.RunContext) (UserData, error) {
  return fetchUserData(123)
})
call2 := restate.RunAsync(ctx, func(ctx restate.RunContext) (OrderHistory, error) {
  return fetchOrderHistory(123)
})
call3 := restate.Service[int](ctx, "AnalyticsService", "CalculateMetrics").RequestFuture(123)

user, _ := call1.Result()
orders, _ := call2.Result()
metrics, _ := call3.Response()
```

Check out the guide on [parallelizing work](guides/parallelizing-work).

## Retrieving results

Operations such as calls, awakeables, and [`restate.After`](https://pkg.go.dev/github.com/restatedev/sdk-go#After) return futures which can
be safely waited concurrently using [`restate.Wait`](https://pkg.go.dev/github.com/restatedev/sdk-go#Wait). Restate will log the order in which they complete, to make this deterministic on replay.

<Warning>
    **Don't use Go routines**:

    Do not try to combine blocking Restate operations using goroutines, channels or select statements. These cannot be used deterministically, and will likely lead to non-determinism errors upon replay. The only place it is safe to use these types is inside of a restate.Run function.
</Warning>

### Select the first successful completion

```go {"CODE_LOAD::go/develop/journalingresults.go#race"} 
sleepFuture := restate.After(ctx, 30*time.Second)
callFuture := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi")

fut, err := restate.WaitFirst(ctx, sleepFuture, callFuture)
if err != nil {
  return "", err
}
switch fut {
case sleepFuture:
  if err := sleepFuture.Done(); err != nil {
    return "", err
  }
  return "sleep won", nil
case callFuture:
  result, err := callFuture.Response()
  if err != nil {
    return "", err
  }
  return fmt.Sprintf("call won with result: %s", result), nil
}
```

### Wait for all tasks to complete

```go {"CODE_LOAD::go/develop/journalingresults.go#all"} 
callFuture1 := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi")
callFuture2 := restate.Service[string](ctx, "MyService", "MyHandler").RequestFuture("hi again")

// Collect all results
var subResults []string
for fut, err := range restate.Wait(ctx, callFuture1, callFuture2) {
  if err != nil {
    return "", err
  }
  response, err := fut.(restate.ResponseFuture[string]).Response()
  if err != nil {
    return "", err
  }
  subResults = append(subResults, response)
}
```

