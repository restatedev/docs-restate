---
title: "Durable Steps"
description: "Persist results of operations."
icon: "list-check"
---

Restate uses an execution log to replay operations after failures and suspensions. Non-deterministic operations (database calls, HTTP requests, UUID generation) must be wrapped to ensure deterministic replay.

## Run 

Use `ctx.run` to safely wrap any non-deterministic operation, like HTTP calls or database responses, and have Restate store its result in the execution log.

```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#side_effect"} 
const result = await ctx.run<string>(async () => doDbRequest());
```

Note that inside `ctx.run`, you cannot use the Restate context (e.g., `ctx.get`, `ctx.sleep`, or nested `ctx.run`).

<AccordionGroup>

  <Accordion title="Serialization">
  By default, results are serialized using [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON). See the [serialization docs](/develop/ts/serialization) to customize this.
  </Accordion>

  <Accordion title="Error handling and retry policies">

  Failures in `ctx.run` are treated the same as any other handler error. Restate will retry it unless configured otherwise or unless a [`TerminalError`](/develop/ts/error-handling) is thrown.


  You can customize how `ctx.run` retries via:

```typescript {"CODE_LOAD::ts/src/develop/retries.ts#here"} 
try {
  const myRunRetryPolicy = {
    initialRetryInterval: { milliseconds: 500 },
    retryIntervalFactor: 2,
    maxRetryInterval: { seconds: 1 },
    maxRetryAttempts: 5,
    maxRetryDuration: { seconds: 1 },
  };
  await ctx.run("write", () => writeToOtherSystem(), myRunRetryPolicy);
} catch (e) {
  if (e instanceof restate.TerminalError) {
    // Undo or compensate here (see Sagas guide)
  }
  throw e;
}
```

  * You can limit retries by time or count
  * When the policy is exhausted, a `TerminalError` is thrown
  * See the [Error Handling Guide](/guides/error-handling) and the [Sagas Guide](/guides/sagas) for patterns like compensation

  </Accordion>
  <Accordion title="Increasing timeouts">
    If Restate doesn't receive new journal entries from a service for more than one minute (by default), it will automatically abort the invocation and retry it.

    However, some business logic can take longer to complete—for example, an LLM call that takes up to 3 minutes to respond.

    In such cases, you can adjust the service’s [abort timeout and inactivity timeout](/operate/configuration/services) settings to accommodate longer execution times.

    For more information, see the [error handling guide](/guides/error-handling).
  </Accordion>

</AccordionGroup>

## Deterministic randoms

The SDK provides deterministic helpers for random values — seeded by the invocation ID — so they return the **same result on retries**.

### UUIDs

To generate stable UUIDs for things like idempotency keys:

```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#uuid"} 
const uuid = ctx.rand.uuidv4();
```

Do not use this in cryptographic contexts.

### Random numbers

To generate a deterministic float between `0` and `1`:


```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#random_nb"} 
const randomNumber = ctx.rand.random();
```

This behaves like `Math.random()` but is deterministically replayable.

