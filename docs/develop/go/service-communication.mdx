---
title: "Service Communication"
sidebarTitle: "Communication"
description: "Call other services from your handler."
icon: "comment"
---

Your Restate handler can call other handlers in three ways:

- **[Request-response calls](#request-response-calls)**: Call and wait for a response
- **[One-way messages](#sending-messages)**: Send a message and continue
- **[Delayed messages](#delayed-messages)**: Send a message after a delay

<Info>
To call a service from an external application, see the [HTTP](/operate/invocation/http), [Kafka](/operate/invocation/kafka), or [SDK Clients](/operate/invocation/clients) documentation.
</Info>

<Info>[Learn how Restate how it works](/basics/key-concepts#resilient-communication)</Info>


## Request-response calls

To call a Restate handler and wait for its result:

```go {"CODE_LOAD::go/develop/servicecommunication.go#request_response"} 
package develop

import (
  "time"

  restate "github.com/restatedev/sdk-go"
)

type Router struct{}

func (Router) Greet(ctx restate.Context, name string) error {
  response, err := restate.Service[string](ctx, "MyService", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  _ = response
  return nil
}

func (Router) Greet2(ctx restate.Context, name string) error {
  response, err := restate.Object[string](ctx, "MyObject", "Mary", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  // Call the `run` handler of the workflow (only works once).
  result, err := restate.Workflow[bool](ctx, "MyWorkflow", "my-workflow-id", "Run").
    Request("Hi")
  if err != nil {
    return err
  }
  // Call some other `GetStatus` handler of the workflow.
  status, err := restate.Workflow[restate.Void](ctx, "MyWorkflow", "my-workflow-id", "GetStatus").
    Request("Hi again")
  if err != nil {
    return err
  }

  _ = response
  _ = result
  _ = status

  restate.ServiceSend(ctx, "MyService", "MyHandler").Send("Hi")

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("Hi")

  // Call the `run` handler of the workflow (only works once).
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi")
  // Call some other `interactWithWorkflow` handler of the workflow.
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "InteractWithWorkflow").
    Send("Hi again")

  restate.ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")

  return nil
}

func (Router) Greet3(ctx restate.Context, name string) error {
  restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))

  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Optional: send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
    GetInvocationId()

  // Later re-attach to the request
  response, err := restate.AttachInvocation[string](ctx, invocationId).Response()

  _ = response
  _ = err
  return nil
}

func (Router) Greet4(ctx restate.Context, name string) error {
  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi").
    GetInvocationId()

  // I don't need this invocation anymore, let me just cancel it
  restate.CancelInvocation(ctx, invocationId)

  return nil
}
```

Use generic calls when you don't have the service definition or need dynamic service names:

```go {"CODE_LOAD::go/develop/servicecommunication.go#generic_call"} 
package develop

import (
  "time"

  restate "github.com/restatedev/sdk-go"
)

type Router struct{}

func (Router) Greet(ctx restate.Context, name string) error {
  response, err := restate.Service[string](ctx, "MyService", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  _ = response
  return nil
}

func (Router) Greet2(ctx restate.Context, name string) error {
  response, err := restate.Object[string](ctx, "MyObject", "Mary", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  // Call the `run` handler of the workflow (only works once).
  result, err := restate.Workflow[bool](ctx, "MyWorkflow", "my-workflow-id", "Run").
    Request("Hi")
  if err != nil {
    return err
  }
  // Call some other `GetStatus` handler of the workflow.
  status, err := restate.Workflow[restate.Void](ctx, "MyWorkflow", "my-workflow-id", "GetStatus").
    Request("Hi again")
  if err != nil {
    return err
  }

  _ = response
  _ = result
  _ = status

  restate.ServiceSend(ctx, "MyService", "MyHandler").Send("Hi")

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("Hi")

  // Call the `run` handler of the workflow (only works once).
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi")
  // Call some other `interactWithWorkflow` handler of the workflow.
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "InteractWithWorkflow").
    Send("Hi again")

  restate.ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")

  return nil
}

func (Router) Greet3(ctx restate.Context, name string) error {
  restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))

  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Optional: send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
    GetInvocationId()

  // Later re-attach to the request
  response, err := restate.AttachInvocation[string](ctx, invocationId).Response()

  _ = response
  _ = err
  return nil
}

func (Router) Greet4(ctx restate.Context, name string) error {
  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi").
    GetInvocationId()

  // I don't need this invocation anymore, let me just cancel it
  restate.CancelInvocation(ctx, invocationId)

  return nil
}
```

<Accordion title={"Workflow retention"}>
After a workflow's run handler completes, other handlers can still be called for up to 24 hours (default).
Update this via the [service configuration](/operate/configuration/services).
</Accordion>

<Info>
Request-response calls between [exclusive handlers](/basics/functions#handler-behavior) of Virtual Objects may lead to deadlocks:
- Cross deadlock: A → B and B → A (same keys).
- Cycle deadlock: A → B → C → A.

Use the UI or CLI to [cancel](/operate/invocation#cancelling-invocations) and unblock deadlocked invocations.
</Info>

## Sending messages

To send a message to another Restate handler without waiting for a response:

```go {"CODE_LOAD::go/develop/servicecommunication.go#one_way"} 
package develop

import (
  "time"

  restate "github.com/restatedev/sdk-go"
)

type Router struct{}

func (Router) Greet(ctx restate.Context, name string) error {
  response, err := restate.Service[string](ctx, "MyService", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  _ = response
  return nil
}

func (Router) Greet2(ctx restate.Context, name string) error {
  response, err := restate.Object[string](ctx, "MyObject", "Mary", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  // Call the `run` handler of the workflow (only works once).
  result, err := restate.Workflow[bool](ctx, "MyWorkflow", "my-workflow-id", "Run").
    Request("Hi")
  if err != nil {
    return err
  }
  // Call some other `GetStatus` handler of the workflow.
  status, err := restate.Workflow[restate.Void](ctx, "MyWorkflow", "my-workflow-id", "GetStatus").
    Request("Hi again")
  if err != nil {
    return err
  }

  _ = response
  _ = result
  _ = status

  restate.ServiceSend(ctx, "MyService", "MyHandler").Send("Hi")

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("Hi")

  // Call the `run` handler of the workflow (only works once).
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi")
  // Call some other `interactWithWorkflow` handler of the workflow.
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "InteractWithWorkflow").
    Send("Hi again")

  restate.ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")

  return nil
}

func (Router) Greet3(ctx restate.Context, name string) error {
  restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))

  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Optional: send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
    GetInvocationId()

  // Later re-attach to the request
  response, err := restate.AttachInvocation[string](ctx, invocationId).Response()

  _ = response
  _ = err
  return nil
}

func (Router) Greet4(ctx restate.Context, name string) error {
  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi").
    GetInvocationId()

  // I don't need this invocation anymore, let me just cancel it
  restate.CancelInvocation(ctx, invocationId)

  return nil
}
```
Restate handles message delivery and retries, so the handler can complete and return without waiting for the message to be processed.


Use generic send when you don't have the service definition:

```go {"CODE_LOAD::go/develop/servicecommunication.go#generic_send"} 
package develop

import (
  "time"

  restate "github.com/restatedev/sdk-go"
)

type Router struct{}

func (Router) Greet(ctx restate.Context, name string) error {
  response, err := restate.Service[string](ctx, "MyService", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  _ = response
  return nil
}

func (Router) Greet2(ctx restate.Context, name string) error {
  response, err := restate.Object[string](ctx, "MyObject", "Mary", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  // Call the `run` handler of the workflow (only works once).
  result, err := restate.Workflow[bool](ctx, "MyWorkflow", "my-workflow-id", "Run").
    Request("Hi")
  if err != nil {
    return err
  }
  // Call some other `GetStatus` handler of the workflow.
  status, err := restate.Workflow[restate.Void](ctx, "MyWorkflow", "my-workflow-id", "GetStatus").
    Request("Hi again")
  if err != nil {
    return err
  }

  _ = response
  _ = result
  _ = status

  restate.ServiceSend(ctx, "MyService", "MyHandler").Send("Hi")

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("Hi")

  // Call the `run` handler of the workflow (only works once).
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi")
  // Call some other `interactWithWorkflow` handler of the workflow.
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "InteractWithWorkflow").
    Send("Hi again")

  restate.ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")

  return nil
}

func (Router) Greet3(ctx restate.Context, name string) error {
  restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))

  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Optional: send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
    GetInvocationId()

  // Later re-attach to the request
  response, err := restate.AttachInvocation[string](ctx, invocationId).Response()

  _ = response
  _ = err
  return nil
}

func (Router) Greet4(ctx restate.Context, name string) error {
  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi").
    GetInvocationId()

  // I don't need this invocation anymore, let me just cancel it
  restate.CancelInvocation(ctx, invocationId)

  return nil
}
```

<Info>
Calls to a Virtual Object execute in order of arrival, serially.
Example:

```go {"CODE_LOAD::go/develop/servicecommunication.go#ordering"} 
restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")
```

Call A is guaranteed to execute before B. However, other invocations may interleave between A and B.
</Info>

## Delayed messages

To send a message after a delay:

```go {"CODE_LOAD::go/develop/servicecommunication.go#delayed"} 
package develop

import (
  "time"

  restate "github.com/restatedev/sdk-go"
)

type Router struct{}

func (Router) Greet(ctx restate.Context, name string) error {
  response, err := restate.Service[string](ctx, "MyService", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  _ = response
  return nil
}

func (Router) Greet2(ctx restate.Context, name string) error {
  response, err := restate.Object[string](ctx, "MyObject", "Mary", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  // Call the `run` handler of the workflow (only works once).
  result, err := restate.Workflow[bool](ctx, "MyWorkflow", "my-workflow-id", "Run").
    Request("Hi")
  if err != nil {
    return err
  }
  // Call some other `GetStatus` handler of the workflow.
  status, err := restate.Workflow[restate.Void](ctx, "MyWorkflow", "my-workflow-id", "GetStatus").
    Request("Hi again")
  if err != nil {
    return err
  }

  _ = response
  _ = result
  _ = status

  restate.ServiceSend(ctx, "MyService", "MyHandler").Send("Hi")

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("Hi")

  // Call the `run` handler of the workflow (only works once).
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi")
  // Call some other `interactWithWorkflow` handler of the workflow.
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "InteractWithWorkflow").
    Send("Hi again")

  restate.ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")

  return nil
}

func (Router) Greet3(ctx restate.Context, name string) error {
  restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))

  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Optional: send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
    GetInvocationId()

  // Later re-attach to the request
  response, err := restate.AttachInvocation[string](ctx, invocationId).Response()

  _ = response
  _ = err
  return nil
}

func (Router) Greet4(ctx restate.Context, name string) error {
  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi").
    GetInvocationId()

  // I don't need this invocation anymore, let me just cancel it
  restate.CancelInvocation(ctx, invocationId)

  return nil
}
```

Use generic send with a delay when you don't have the service definition:

```go {"CODE_LOAD::go/develop/servicecommunication.go#generic_delayed"} 
package develop

import (
  "time"

  restate "github.com/restatedev/sdk-go"
)

type Router struct{}

func (Router) Greet(ctx restate.Context, name string) error {
  response, err := restate.Service[string](ctx, "MyService", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  _ = response
  return nil
}

func (Router) Greet2(ctx restate.Context, name string) error {
  response, err := restate.Object[string](ctx, "MyObject", "Mary", "MyHandler").
    Request("Hi")
  if err != nil {
    return err
  }

  // Call the `run` handler of the workflow (only works once).
  result, err := restate.Workflow[bool](ctx, "MyWorkflow", "my-workflow-id", "Run").
    Request("Hi")
  if err != nil {
    return err
  }
  // Call some other `GetStatus` handler of the workflow.
  status, err := restate.Workflow[restate.Void](ctx, "MyWorkflow", "my-workflow-id", "GetStatus").
    Request("Hi again")
  if err != nil {
    return err
  }

  _ = response
  _ = result
  _ = status

  restate.ServiceSend(ctx, "MyService", "MyHandler").Send("Hi")

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("Hi")

  // Call the `run` handler of the workflow (only works once).
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi")
  // Call some other `interactWithWorkflow` handler of the workflow.
  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "InteractWithWorkflow").
    Send("Hi again")

  restate.ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.WorkflowSend(ctx, "MyWorkflow", "my-workflow-id", "Run").
    Send("Hi", restate.WithDelay(5*time.Second))

  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call A")
  restate.ObjectSend(ctx, "MyService", "Mary", "MyHandler").Send("I'm call B")

  return nil
}

func (Router) Greet3(ctx restate.Context, name string) error {
  restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))

  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    // Optional: send attaching idempotency key
    Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
    GetInvocationId()

  // Later re-attach to the request
  response, err := restate.AttachInvocation[string](ctx, invocationId).Response()

  _ = response
  _ = err
  return nil
}

func (Router) Greet4(ctx restate.Context, name string) error {
  // Execute the request and retrieve the invocation id
  invocationId := restate.
    ServiceSend(ctx, "MyService", "MyHandler").
    Send("Hi").
    GetInvocationId()

  // I don't need this invocation anymore, let me just cancel it
  restate.CancelInvocation(ctx, invocationId)

  return nil
}
```

<Info>
Learn [how this is different](/develop/ts/durable-timers#scheduling-async-tasks) from sleeping and then sending a message.
</Info>

## Using an idempotency key

To prevent duplicate executions of the same call, add an idempotency key:

```go {"CODE_LOAD::go/develop/servicecommunication.go#idempotency_key"} 
restate.
  ServiceSend(ctx, "MyService", "MyHandler").
  // Send attaching idempotency key
  Send("Hi", restate.WithIdempotencyKey("my-idempotency-key"))
```

Restate automatically deduplicates calls made during the same handler execution, so there's no need to provide an idempotency key in that case.
However, if multiple handlers might call the same service independently, you can use an idempotency key to ensure deduplication across those calls.

## Attach to an invocation

To wait for or get the result of a previously sent message:

```go {"CODE_LOAD::go/develop/servicecommunication.go#attach"} 
// Execute the request and retrieve the invocation id
invocationId := restate.
  ServiceSend(ctx, "MyService", "MyHandler").
  // Optional: send attaching idempotency key
  Send("Hi", restate.WithIdempotencyKey("my-idempotency-key")).
  GetInvocationId()

// Later re-attach to the request
response, err := restate.AttachInvocation[string](ctx, invocationId).Response()
```

- With an idempotency key: Wait for completion and retrieve the result.
- Without an idempotency key: Can only wait, not retrieve the result.


## Cancel an invocation

To cancel a running handler:

```go {"CODE_LOAD::go/develop/servicecommunication.go#cancel"} 
// Execute the request and retrieve the invocation id
invocationId := restate.
  ServiceSend(ctx, "MyService", "MyHandler").
  Send("Hi").
  GetInvocationId()

// I don't need this invocation anymore, let me just cancel it
restate.CancelInvocation(ctx, invocationId)
```


## See also

- **[SDK Clients](/develop/go/clients)**: Call Restate services from external applications
- **[Error Handling](/develop/go/error-handling)**: Handle failures and terminal errors in service calls
- **[Durable Timers](/develop/go/durable-timers)**: Implement timeouts for your service calls
- **[Serialization](/develop/go/serialization)**: Customize how data is serialized between services
- **[Sagas](/guides/sagas)**: Roll back or compensate for canceled service calls.
