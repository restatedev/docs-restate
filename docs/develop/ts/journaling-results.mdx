---
title: "Durable Steps"
description: "Persist results of operations."
icon: "list-check"
---

Restate uses an execution log to replay operations after failures and suspensions. Non-deterministic operations (database calls, HTTP requests, UUID generation) must be wrapped to ensure deterministic replay.

## Why use Restate for this?

Without proper journaling, non-deterministic operations cause issues on replay:
- **Database calls** return different results
- **HTTP requests** may have different responses or fail
- **Random values** change between replays
- **Timestamps** shift, breaking business logic

Restate solves this by journaling results the first time, then replaying the same values on subsequent attempts, ensuring your handlers are deterministic and reliable.

## Run 

Use [`ctx.run`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#run) to safely wrap any non-deterministic operation, like HTTP calls or database responses, and have Restate store its result in the execution log.

```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#side_effect""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";
import { RestatePromise } from "@restatedev/restate-sdk";
import { MyService } from "./my_service";

const service = restate.service({
  name: "SideEffects",
  handlers: {
    greet: async (ctx: restate.Context, name: string) => {
      const result = await ctx.run<string>(async () => doDbRequest());
    },

    promiseCombinators: async (ctx: restate.Context, name: string) => {
      const sleepPromise = ctx.sleep({ milliseconds: 100 });
      const callPromise = ctx.serviceClient(MyService).myHandler("Hi");
      const externalCallPromise = ctx.run(() => httpCall());
      
      const resultArray = await RestatePromise.all([
        sleepPromise,
        callPromise,
        externalCallPromise,
      ]);

      const uuid = ctx.rand.uuidv4();

      const randomNumber = ctx.rand.random();
    },
  },
});

function doDbRequest() {
  return "";
}

async function httpCall() {
  return "";
}
```

Note that inside `ctx.run`, you cannot use the Restate context (e.g., `ctx.get`, `ctx.call`, or nested `ctx.run`).

<AccordionGroup>

  <Accordion title="Serialization">
  By default, results are serialized using [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON). See the [serialization docs](/develop/ts/serialization) to customize this.
  </Accordion>

  <Accordion title="Error handling and retry policies">

  Failures in `ctx.run` are treated the same as any other handler error. Restate will retry it unless configured otherwise or unless a [`TerminalError`](/develop/ts/error-handling) is thrown.


  You can customize how `ctx.run` retries via the [`RunOptions`](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.RunOptions):

  ```typescript {"CODE_LOAD::ts/src/develop/retries.ts?1"""""} 
import * as restate from "@restatedev/restate-sdk";

function writeToOtherSystem() {
  return undefined;
}

const service = restate.service({
  name: "MyService",
  handlers: {
    greet: async (ctx: restate.Context, name: string) => {
      try {
        const myRunRetryPolicy = {
          initialRetryInterval: { milliseconds: 500 },
          retryIntervalFactor: 2,
          maxRetryInterval: { seconds: 1 },
          maxRetryAttempts: 5,
          maxRetryDuration: { seconds: 1 },
        };
        await ctx.run("write", () => writeToOtherSystem(), myRunRetryPolicy);
      } catch (e) {
        if (e instanceof restate.TerminalError) {
          // Undo or compensate here (see Sagas guide)
        }
        throw e;
      }
    },
  },
});

const paymentClient = {
  call: (txId: string, amt: number) => {
    return { error: "", isSuccess: false };
  },
};
```

  * You can limit retries by time or count
  * When the policy is exhausted, a `TerminalError` is thrown
  * See [Error Handling](/develop/ts/error-handling) and the [Sagas Guide](/guides/sagas) for patterns like compensation

  </Accordion>
  <Accordion title="Increasing timeouts">
    If Restate doesn't receive new journal entries from a service for more than one minute (by default), it will automatically abort the invocation and retry it.

    However, some business logic can take longer to complete—for example, an LLM call that takes up to 3 minutes to respond.

    In such cases, you can adjust the service’s [abort timeout](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#aborttimeout) and [inactivity timeout](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#inactivitytimeout) settings to accommodate longer execution times.

    For more information, see the [error handling guide](/guides/error-handling).
  </Accordion>

</AccordionGroup>

## Deterministic randoms

The SDK provides deterministic helpers for random values — seeded by the invocation ID — so they return the **same result on retries**.

### UUIDs

Use `ctx.rand.uuidv4()` to generate stable UUIDs for things like idempotency keys:

```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#uuid""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";
import { RestatePromise } from "@restatedev/restate-sdk";
import { MyService } from "./my_service";

const service = restate.service({
  name: "SideEffects",
  handlers: {
    greet: async (ctx: restate.Context, name: string) => {
      const result = await ctx.run<string>(async () => doDbRequest());
    },

    promiseCombinators: async (ctx: restate.Context, name: string) => {
      const sleepPromise = ctx.sleep({ milliseconds: 100 });
      const callPromise = ctx.serviceClient(MyService).myHandler("Hi");
      const externalCallPromise = ctx.run(() => httpCall());
      
      const resultArray = await RestatePromise.all([
        sleepPromise,
        callPromise,
        externalCallPromise,
      ]);

      const uuid = ctx.rand.uuidv4();

      const randomNumber = ctx.rand.random();
    },
  },
});

function doDbRequest() {
  return "";
}

async function httpCall() {
  return "";
}
```

### Random numbers

Use `ctx.rand.random()` to generate a deterministic float between `0` and `1`:


```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#random_nb""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";
import { RestatePromise } from "@restatedev/restate-sdk";
import { MyService } from "./my_service";

const service = restate.service({
  name: "SideEffects",
  handlers: {
    greet: async (ctx: restate.Context, name: string) => {
      const result = await ctx.run<string>(async () => doDbRequest());
    },

    promiseCombinators: async (ctx: restate.Context, name: string) => {
      const sleepPromise = ctx.sleep({ milliseconds: 100 });
      const callPromise = ctx.serviceClient(MyService).myHandler("Hi");
      const externalCallPromise = ctx.run(() => httpCall());
      
      const resultArray = await RestatePromise.all([
        sleepPromise,
        callPromise,
        externalCallPromise,
      ]);

      const uuid = ctx.rand.uuidv4();

      const randomNumber = ctx.rand.random();
    },
  },
});

function doDbRequest() {
  return "";
}

async function httpCall() {
  return "";
}
```

This behaves like `Math.random()` but is deterministically replayable.


## `RestatePromise` combinators

To run multiple operations concurrently and deterministically, use `RestatePromise` combinators.
Restate then logs the order in which they get resolved or rejected so they are deterministic on replay.

```typescript {"CODE_LOAD::ts/src/develop/journaling_results.ts#all""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";
import { RestatePromise } from "@restatedev/restate-sdk";
import { MyService } from "./my_service";

const service = restate.service({
  name: "SideEffects",
  handlers: {
    greet: async (ctx: restate.Context, name: string) => {
      const result = await ctx.run<string>(async () => doDbRequest());
    },

    promiseCombinators: async (ctx: restate.Context, name: string) => {
      const sleepPromise = ctx.sleep({ milliseconds: 100 });
      const callPromise = ctx.serviceClient(MyService).myHandler("Hi");
      const externalCallPromise = ctx.run(() => httpCall());
      
      const resultArray = await RestatePromise.all([
        sleepPromise,
        callPromise,
        externalCallPromise,
      ]);

      const uuid = ctx.rand.uuidv4();

      const randomNumber = ctx.rand.random();
    },
  },
});

function doDbRequest() {
  return "";
}

async function httpCall() {
  return "";
}
```

Restate provides the following deterministic combinators:
- [`RestatePromise.all`](https://docs.restate.dev/tsdocs/variables/_restatedev_restate-sdk.RestatePromise#all): similar to [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
- [`RestatePromise.any`](https://docs.restate.dev/tsdocs/variables/_restatedev_restate-sdk.RestatePromise#any): similar to [`Promise.any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)
- [`RestatePromise.race`](https://docs.restate.dev/tsdocs/variables/_restatedev_restate-sdk.RestatePromise#race): similar to [`Promise.race`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)
- [`RestatePromise.allSettled`](https://docs.restate.dev/tsdocs/variables/_restatedev_restate-sdk.RestatePromise#allsettled): similar to [`Promise.allSettled`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)
