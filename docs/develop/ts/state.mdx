---
title: "State"
description: "Store key-value state in Restate."
icon: "database"
---

Restate lets you persist key-value (K/V) state using its embedded K/V store.

## Why use Restate for this?

Restate journals all state updates alongside other context actions (e.g., run, calls) in the same execution log. This ensures strong consistency: your state is always in sync with the exact point of execution, making it safe to use in distributed or failure-prone environments.

This model turns your service into a stateless executor: The state is injected on every request, allowing handlers to operate without maintaining any in-memory or external persistence.

This design makes it easy to:
- Implement consistent state machines
- Run stateful logic on stateless platforms (e.g., serverless, FaaS).
- Avoid external databases for transient or actor-scoped data.

## Key characteristics

**State is only available for Virtual Objects and Workflows.**

Scope & retention: 
- For Virtual Objects: State is scoped per object key and retained indefinitely. It is persisted and shared across all invocations for that object until explicitly cleared.
- For Workflows: State is scoped per workflow execution (workflow ID) and retained only for the duration of the workflowâ€™s configured retention time.

Access Rules:
- [Exclusive handlers](/develop/ts/overview#exclusive-vs-shared-handlers) (e.g., `run()` in workflows) can read and write state.
- [Shared handlers](/develop/ts/overview#exclusive-vs-shared-handlers) can only read state and cannot mutate it.

You can inspect and edit the K/V state via the UI and the [CLI](/operate/introspection#inspecting-application-state).

<Accordion title="How it works">
When Restate receives an invocation for a Virtual Object or Workflow:
1. It attaches the K/V state of that object to the request.
2. The request is forwarded along with the state to your handler.
3. All reads and writes operate on this local state context during execution.
</Accordion>

## List all state keys
Use [`ctx.stateKeys()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext#statekeys) to retrieve all keys for which the current Virtual Object has stored state:

```typescript {"CODE_LOAD::ts/src/develop/state.ts#statekeys""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";

export const router = restate.object({
  name: "State",
  handlers: {
    greet: async (ctx: restate.ObjectContext, name: string) => {
      const stateKeys = ctx.stateKeys();

      const myString = (await ctx.get<string>("my-string-key")) ?? "my-default";
      const myNumber = (await ctx.get<number>("my-number-key")) ?? 0;

      ctx.set("my-key", "my-new-value");

      ctx.clear("my-key");

      ctx.clearAll();
    },
  },
});
```

## Get state value
Use [`ctx.get<T>()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext#get-1) to read a value by key. Returns null if the key doesn't exist.

```typescript {"CODE_LOAD::ts/src/develop/state.ts#get""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";

export const router = restate.object({
  name: "State",
  handlers: {
    greet: async (ctx: restate.ObjectContext, name: string) => {
      const stateKeys = ctx.stateKeys();

      const myString = (await ctx.get<string>("my-string-key")) ?? "my-default";
      const myNumber = (await ctx.get<number>("my-number-key")) ?? 0;

      ctx.set("my-key", "my-new-value");

      ctx.clear("my-key");

      ctx.clearAll();
    },
  },
});
```

By default, results are serialized using [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON). See the [serialization docs](/develop/ts/serialization) to customize this.

## Set state value
Use [`ctx.set()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext#set-1) to write or update a value:

```typescript {"CODE_LOAD::ts/src/develop/state.ts#set""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";

export const router = restate.object({
  name: "State",
  handlers: {
    greet: async (ctx: restate.ObjectContext, name: string) => {
      const stateKeys = ctx.stateKeys();

      const myString = (await ctx.get<string>("my-string-key")) ?? "my-default";
      const myNumber = (await ctx.get<number>("my-number-key")) ?? 0;

      ctx.set("my-key", "my-new-value");

      ctx.clear("my-key");

      ctx.clearAll();
    },
  },
});
```

## Clear state key
Use [`ctx.clear()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext#clear) to delete a specific key:

```typescript {"CODE_LOAD::ts/src/develop/state.ts#clear""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";

export const router = restate.object({
  name: "State",
  handlers: {
    greet: async (ctx: restate.ObjectContext, name: string) => {
      const stateKeys = ctx.stateKeys();

      const myString = (await ctx.get<string>("my-string-key")) ?? "my-default";
      const myNumber = (await ctx.get<number>("my-number-key")) ?? 0;

      ctx.set("my-key", "my-new-value");

      ctx.clear("my-key");

      ctx.clearAll();
    },
  },
});
```

## Clear all state keys

Use [`ctx.clearAll()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext#clearall) to remove all stored state for the current Virtual Object:

```typescript {"CODE_LOAD::ts/src/develop/state.ts#clear_all""""""""""""""} 
import * as restate from "@restatedev/restate-sdk";

export const router = restate.object({
  name: "State",
  handlers: {
    greet: async (ctx: restate.ObjectContext, name: string) => {
      const stateKeys = ctx.stateKeys();

      const myString = (await ctx.get<string>("my-string-key")) ?? "my-default";
      const myNumber = (await ctx.get<number>("my-number-key")) ?? 0;

      ctx.set("my-key", "my-new-value");

      ctx.clear("my-key");

      ctx.clearAll();
    },
  },
});
```
