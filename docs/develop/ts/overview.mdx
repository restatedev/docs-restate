---
title: "Overview"
description: "Implementing Restate services with the TypeScript SDK."
---


The Restate TypeScript SDK is open source and available on [GitHub](https://github.com/restatedev/sdk-typescript).

<Note>
**Prerequisites:**  
- [NodeJS](https://nodejs.org/en/) >= v18.17.1 or [Bun](https://bun.sh/docs/installation) or [Deno](https://deno.land/#installation)  
- [npm CLI](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) >= 9.6.7
</Note>

## Getting started 
<Tip>
    Get started quickly with the [TypeScript Quickstart](/get_started/quickstart?sdk=ts).
</Tip>

Add the [`@restatedev/restate-sdk`](https://www.npmjs.com/package/@restatedev/restate-sdk) dependency to your project to start developing Restate services.

The Restate SDK lets you implement **handlers**. Handlers can be part of a **Service**, a **Virtual Object**, or a **Workflow**. This page introduces each concept and shows how to define them.


## Services

Services are the fundamental units in Restate. They group related **handlers** and expose them as callable endpoints.

Here’s a basic example of a service:

```ts  {CODE_LOAD::ts/src/develop/my_service.ts}
import * as restate from "@restatedev/restate-sdk";

const myService = restate.service({
  name: "MyService",
  handlers: {
    myHandler: async (ctx: restate.Context, greeting: string) => {
      return `${greeting}!`;
    },
  },
});

export const MyService: typeof myService = { name: "MyService" };

restate.endpoint().bind(myService).listen();
```


* Define a service using [`restate.service`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.service).
* Set a `name` for the service. Its handlers become accessible at:
  `http://<RESTATE_INGRESS_URL>/<ServiceName>/<HandlerName>`
* Handlers:

  * Are functions mapped to names (e.g., `myHandler`)
  * Accept a [`Context`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context) as the first argument.
  * May take one optional input and return any JSON-serializable value.
    See [Serialization](/develop/ts/serialization) for advanced types (e.g., Zod)
* Export the service definition to be able to call it with typed clients from other services. See [Service Communication](/develop/ts/service-communication).
* Use [`endpoint().bind(...).listen()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.RestateEndpoint) to expose the service over HTTP (port `9080` by default).

## Virtual Objects

Virtual Objects are like services, but stateful and key-addressable — each object instance has a unique ID and persistent state.

```ts  {CODE_LOAD::ts/src/develop/my_virtual_object.ts}
import * as restate from "@restatedev/restate-sdk";

const myObject = restate.object({
  name: "MyObject",
  handlers: {
    myHandler: async (ctx: restate.ObjectContext, greeting: string) => {
      return `${greeting} ${ctx.key}!`;
    },
    myConcurrentHandler: restate.handlers.object.shared(
      async (ctx: restate.ObjectSharedContext, greeting: string) => {
        return `${greeting} ${ctx.key}!`;
      }
    ),
  },
});

export const MyObject: typeof myObject = { name: "MyObject" };

restate.endpoint().bind(myObject).listen();
```

* Define a Virtual Object using [`restate.object(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.object)
* Each instance is identified by a `key` (accessible via `ctx.key`) and can store persistent K/V state.
* Virtual Objects can have [exclusive and shared handlers](/ts/overview#exclusive-vs-shared-handlers). 
* Exclusive handlers receive an [`ObjectContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext), allowing:
  * Read/write access to object state
  * Access to the object key (`ctx.key`)
* Only one exclusive handler runs at a time per object for consistency ([learn more](/ts/overview#exclusive-vs-shared-handlers)).
* Use [`handlers.object.shared(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.handlers.object.shared) to define **concurrent** read-only handlers with [`ObjectSharedContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectSharedContext)


## Workflows

Workflows are long-lived processes with a defined lifecycle. They run once per key and are ideal for orchestrating multi-step operations, which require external interaction via signals and queries.

```ts  {CODE_LOAD::ts/src/develop/workflow.ts}
import * as restate from "@restatedev/restate-sdk";

const myWorkflow = restate.workflow({
  name: "MyWorkflow",
  handlers: {
    run: async (ctx: restate.WorkflowContext, req: string) => {
      // implement workflow logic here

      return "success";
    },

    interactWithWorkflow: async (ctx: restate.WorkflowSharedContext) => {
      // implement interaction logic here
      // e.g. resolve a promise that the workflow is waiting on
    },
  },
});

export const MyWorkflow: typeof myWorkflow = { name: "MyWorkflow" };

restate.endpoint().bind(myWorkflow).listen();
```

* Define a workflow with [`restate.workflow(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.workflow)
* Every workflow **must** include a `run` handler:

  * This is the main orchestration entry point
  * It runs exactly once per workflow execution and uses [`WorkflowContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.WorkflowContext)
  * Use `ctx.key` to access the workflow's unique ID
  * Compose logic from SDK actions (e.g., [`sleep`](/develop/ts/durable-timers), [`run block`](/develop/ts/journaling-results#journaled-actions), [set K/V state](/ts/state#setting-state) or service calls)
* Additional handlers must use the [`WorkflowSharedContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.WorkflowSharedContext) and can:

  * Query workflow state
  * Send signals
  * Run concurrently with the `run` handler and even after it finishes ([learn more](/ts/overview#exclusive-vs-shared-handlers))

Learn more in the [Workflows guide](/develop/ts/workflows).

## Exclusive vs. shared handlers

Virtual Objects and Workflows can have two types of handlers: **exclusive** handlers and **shared** handlers:

### Exclusive handlers
* Use `ObjectContext` or `WorkflowContext`.
* Can **read and write** state (`ctx.set`, `ctx.clear`, etc.).
* Only **one exclusive handler** can run at a time per Virtual Object key or Workflow execution.
* Calls to exclusive handlers are **queued** and executed sequentially to ensure state consistency.
* This serialization guarantees that concurrent writes don't conflict or overwrite each other.

⚠️ **Why this matters:**
If two exclusive handlers were allowed to run concurrently, Restate couldn't safely determine which write is the final one. Serial execution avoids this race condition.

### Shared handlers
* Use `ObjectSharedContext` or `WorkflowSharedContext`.
* Can **only read** state—**no write access**.
* Do **not block** or queue—they can run concurrently with other handlers, including an ongoing exclusive handler.

### When to use shared handlers

Shared handlers are useful for **interacting with long-running exclusive handlers** without blocking or waiting:

* Example: A long-running workflow updates a status in its state.
* Meanwhile, a dashboard can read that status using a shared handler without interrupting or waiting on the main workflow.

## Service options

There are a set of [`ServiceOptions`](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions) you can set for your services to customize their behavior.

```ts  {CODE_LOAD::ts/src/develop/my_advanced_service.ts#options}
restate.service({
  name: "MyService",
  // This description is exposed via the OpenAPI spec
  // and visible in the Restate UI.
  description: "An example service that doesn't do anything.",
  handlers: {
    run: async (ctx: restate.Context) => {},
  },
  options: {
    // Specify your service options here
  }
});
```

<AccordionGroup>
  <Accordion title="Abort and inactivity timeout">
    If Restate doesn't receive new journal entries from a service for more than one minute (by default), it will automatically abort the invocation and retry it.

    However, some business logic can take longer to complete—for example, an LLM call that takes up to 3 minutes to respond.

    In such cases, you can adjust the service’s [abort timeout](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#aborttimeout) and [inactivity timeout](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#inactivitytimeout) settings to accommodate longer execution times.

    For more information, see the [error handling guide](/guides/error-handling).

    ```json  {CODE_LOAD::ts/src/develop/my_advanced_service.ts#timeout}
options: {
    abortTimeout: { minutes: 15 },
    inactivityTimeout: { minutes: 15 }
}
```
  </Accordion>

  <Accordion title="Idempotency retention">
    Restate allows you to [add an idempotency key](/invoke/http#invoke-a-handler-idempotently) to your request headers to ensure that duplicate requests are processed only once.

    You can configure how long idempotency keys are retained using the [service’s options](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#idempotencyretention). 

    ```json  {CODE_LOAD::ts/src/develop/my_advanced_service.ts#idempotency}
options: {
    idempotencyRetention: { days: 3 }
}
```
  </Accordion>

  <Accordion title="Hiding services from external access">
    You can hide a service from external access by marking it as [**private** in the service options](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#ingressprivate).

    This prevents the service from being exposed through the ingress to external callers, while still allowing other Restate services to invoke it internally.
    

    ```json  {CODE_LOAD::ts/src/develop/my_advanced_service.ts#private}
options: {
    ingressPrivate: true
}
```
  </Accordion>

  <Accordion title="Journal retention">
    By default, Restate discards the invocation journal after an invocation completes to save storage space.

    However, for certain handlers, such as workflows or AI agent runs, it can be useful to be able to inspect the journal after the invocation has finished.

    In this case, you can specify the journal retention in the [service options](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ServiceOptions#journalretention). 

    ```json  {CODE_LOAD::ts/src/develop/my_advanced_service.ts#journal}
options: {
    journalRetention: { days: 7 }
}
```
  </Accordion>

  <Accordion title="Mapping errors to terminal errors">
    Have a look at the [error handling docs](/develop/ts/error-handling#mapping-errors-to-terminalerror).
  </Accordion>
</AccordionGroup>