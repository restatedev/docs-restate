---
title: "Services"
description: "Implementing Restate services with the TypeScript SDK."
icon: "brackets-curly"
---


The Restate TypeScript SDK is open source and available on [GitHub](https://github.com/restatedev/sdk-typescript).

<Note>
**Prerequisites:**  
- [NodeJS](https://nodejs.org/en/) >= v18.17.1 or [Bun](https://bun.sh/docs/installation) or [Deno](https://deno.land/#installation)  
- [npm CLI](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) >= 9.6.7
</Note>

## Getting started 
<Tip>
    Get started quickly with the [TypeScript Quickstart](/get_started/quickstart?sdk=ts).
</Tip>

Add the [`@restatedev/restate-sdk`](https://www.npmjs.com/package/@restatedev/restate-sdk) dependency to your project to start developing Restate services.

The Restate SDK lets you implement **handlers**. Handlers can be part of a **Service**, a **Virtual Object**, or a **Workflow**. This page introduces each concept and shows how to define them.


## Services

Services are the fundamental units in Restate. They group related **handlers** and expose them as callable endpoints.

Here’s a basic example of a service:

```ts {CODE_LOAD::ts/src/develop/my_service.ts} 
import * as restate from "@restatedev/restate-sdk";

const myService = restate.service({
  name: "MyService",
  handlers: {
    myHandler: async (ctx: restate.Context, greeting: string) => {
      return `${greeting}!`;
    },
  },
});

export const MyService: typeof myService = { name: "MyService" };

restate.endpoint().bind(myService).listen();
```


* Define a service using [`restate.service`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.service).
* Set a `name` for the service. Its handlers become accessible at:
  `http://<RESTATE_INGRESS_URL>/<ServiceName>/<HandlerName>`
* Handlers:

  * Are functions mapped to names (e.g., `myHandler`)
  * Accept a [`Context`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context) as the first argument.
  * May take one optional input and return any JSON-serializable value.
    See [Serialization](/develop/ts/serialization) for advanced types (e.g., Zod)
* Export the service definition to be able to call it with typed clients from other services. See [Service Communication](/develop/ts/service-communication).
* Use [`endpoint().bind(...).listen()`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.RestateEndpoint) to expose the service over HTTP (port `9080` by default).

## Virtual Objects

Virtual Objects are like services, but stateful and key-addressable — each object instance has a unique ID and persistent state.

```ts {CODE_LOAD::ts/src/develop/my_virtual_object.ts} 
import * as restate from "@restatedev/restate-sdk";

const myObject = restate.object({
  name: "MyObject",
  handlers: {
    myHandler: async (ctx: restate.ObjectContext, greeting: string) => {
      return `${greeting} ${ctx.key}!`;
    },
    myConcurrentHandler: restate.handlers.object.shared(
      async (ctx: restate.ObjectSharedContext, greeting: string) => {
        return `${greeting} ${ctx.key}!`;
      }
    ),
  },
});

export const MyObject: typeof myObject = { name: "MyObject" };

restate.endpoint().bind(myObject).listen();
```

* Define a Virtual Object using [`restate.object(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.object)
* Each instance is identified by a `key` (accessible via `ctx.key`) and can store persistent K/V state.
* Virtual Objects can have [exclusive and shared handlers](/develop/ts/overview#exclusive-vs-shared-handlers). 
* Exclusive handlers receive an [`ObjectContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectContext), allowing:
  * Read/write access to object state
  * Access to the object key (`ctx.key`)
* Only one exclusive handler runs at a time per object for consistency ([learn more](/develop/ts/overview#exclusive-vs-shared-handlers)).
* Use [`handlers.object.shared(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.handlers.object.shared) to define **concurrent** read-only handlers with [`ObjectSharedContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.ObjectSharedContext)


## Workflows

Workflows are long-lived processes with a defined lifecycle. They run once per key and are ideal for orchestrating multi-step operations, which require external interaction via signals and queries.

```ts {CODE_LOAD::ts/src/develop/workflow.ts} 
import * as restate from "@restatedev/restate-sdk";

const myWorkflow = restate.workflow({
  name: "MyWorkflow",
  handlers: {
    run: async (ctx: restate.WorkflowContext, req: string) => {
      // implement workflow logic here

      return "success";
    },

    interactWithWorkflow: async (ctx: restate.WorkflowSharedContext) => {
      // implement interaction logic here
      // e.g. resolve a promise that the workflow is waiting on
    },
  },
});

export const MyWorkflow: typeof myWorkflow = { name: "MyWorkflow" };

restate.endpoint().bind(myWorkflow).listen();
```

* Define a workflow with [`restate.workflow(...)`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.workflow)
* Every workflow **must** include a `run` handler:

  * This is the main orchestration entry point
  * It runs exactly once per workflow execution and uses [`WorkflowContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.WorkflowContext)
  * Use `ctx.key` to access the workflow's unique ID
  * Compose logic from SDK actions (e.g., [`sleep`](/develop/ts/durable-timers), [`run block`](/develop/ts/journaling-results#journaled-actions), [set K/V state](/develop/ts/state#setting-state) or service calls)
* Additional handlers must use the [`WorkflowSharedContext`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.WorkflowSharedContext) and can:

  * Query workflow state
  * Send signals
  * Run concurrently with the `run` handler and even after it finishes ([learn more](/develop/ts/overview#exclusive-vs-shared-handlers))

Learn more in the [Workflows guide](/develop/ts/workflows).

## Exclusive vs. shared handlers

Virtual Objects and Workflows can have two types of handlers: **exclusive** handlers and **shared** handlers:

### Exclusive handlers
* Use `ObjectContext` or `WorkflowContext`.
* Can **read and write** state (`ctx.set`, `ctx.clear`, etc.).
* Only **one exclusive handler** can run at a time per Virtual Object key or Workflow execution.
* Calls to exclusive handlers are **queued** and executed sequentially to ensure state consistency.
* This serialization guarantees that concurrent writes don't conflict or overwrite each other.
  If two exclusive handlers were allowed to run concurrently, Restate couldn't safely determine which write is the final one.
### Shared handlers
* Use `ObjectSharedContext` or `WorkflowSharedContext`.
* Can **only read** state—**no write access**.
* Do **not block** or queue—they can run concurrently with other handlers, including an ongoing exclusive handler.
- Useful for **interacting with long-running exclusive handlers** without blocking or waiting.
  For example, a dashboard can read the K/V state of a long-running workflow via a shared handler. 

## Configuring services

[Visit the service configuration page](/operate/configuration/services) to learn more about the various settings that control service behavior.