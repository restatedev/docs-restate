---
title: "Service Communication"
sidebarTitle: "Communication"
description: "Call other services from your handler."
icon: "comment"
---

Your Restate handler can call other handlers in three ways:

- **[Request-response calls](/develop/ts/service-communication#request-response-calls)**: Call and wait for a response
- **[One-way messages](/develop/ts/service-communication#sending-messages)**: Send a message and continue
- **[Delayed messages](/develop/ts/service-communication#delayed-messages)**: Send a message after a delay

<Info>
    This page describes how to call a service **from within a Restate handler**, with access to the Restate Context.
    To call a service from an external application, see the [HTTP](/operate/invocation/http), [Kafka](/operate/invocation/kafka), or [SDK Clients](/operate/invocation/clients) documentation.
</Info>

## Why use Restate for this?

Restate makes service calls reliable without extra infrastructure:

- **Automatic retries**: Failed calls are retried until they succeed
- **No duplicates**: Same call won't execute twice  
- **Survives failures**: Calls continue after crashes or restarts
- **Full observability**: See all calls in the UI
- **No queues needed**: Restate handles message delivery

## Export service definition
To call a service, ensure [its definition is exported](/develop/ts/overview#services):
 ```typescript {"CODE_LOAD::ts/src/develop/my_service.ts#api_export"} 
export const MyService: typeof myService = { name: "MyService" };
```
Then, import this definition into the handler that will make the call.

## Request-response calls

Call a Restate handler and wait for its result.

Use [`serviceClient`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#serviceclient), [`objectClient`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#objectclient), or [`workflowClient`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#workflowclient). Virtual Objects and Workflows need an ID.

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#request_response"} 
// To call a Service:
const svcResponse = await ctx.serviceClient(MyService).myHandler("Hi");

// To call a Virtual Object:
const objResponse = await ctx
  .objectClient(MyObject, "Mary")
  .myHandler("Hi");
  
// To call a Workflow:
// `run` handler — can only be called once per workflow ID
const wfResponse = await ctx
  .workflowClient(MyWorkflow, "wf-id")
  .run("Hi");
// Other handlers can be called anytime within workflow retention
const result = await ctx
  .workflowClient(MyWorkflow, "wf-id")
  .interactWithWorkflow();
```

Use [`ctx.genericCall`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#genericcall) when you don't have the service definition or need dynamic service names:

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#generic_call"} 
const response = await ctx.genericCall({
  service: "MyObject",
  method: "myHandler",
  parameter: "Hi",
  key: "Mary", // drop this for Service calls
  inputSerde: restate.serde.json,
  outputSerde: restate.serde.json,
});
```

<Accordion title={"Workflow retention"}>
After a workflow's run handler completes, other handlers can still be called for up to 24 hours (default).
Update this via the [service configuration](/operate/configuration/services).
</Accordion>

<Note>
Request-response calls between [exclusive handlers](/develop/ts/overview#exclusive-vs-shared-handlers) of Virtual Objects may lead to deadlocks:
- Cross deadlock: A → B and B → A (same keys).
- Cycle deadlock: A → B → C → A.

Use the UI or CLI to [cancel](/operate/invocation#cancelling-invocations) and unblock deadlocked invocations.
</Note>

## Sending messages

Send a message to another Restate handler without waiting for a response.

Restate handles message delivery and retries, so the handler can complete and return without waiting for the message to be processed.

Use [`serviceSendClient`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#servicesendclient), [`objectSendClient`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#objectsendclient), or [`workflowSendClient`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#workflowsendclient). Virtual Objects and Workflows need an ID.

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#one_way"} 
// To message a Service:
ctx.serviceSendClient(MyService).myHandler("Hi");

// To message a Virtual Object:
ctx.objectSendClient(MyObject, "Mary").myHandler("Hi");

// To message a Workflow:
// `run` handler — can only be called once per workflow ID
ctx.workflowSendClient(MyWorkflow, "wf-id").run("Hi");
// Other handlers can be called anytime within workflow retention
ctx.workflowSendClient(MyWorkflow, "wf-id").interactWithWorkflow();
```


Use [`ctx.genericSend`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#genericsend) when you don't have the service definition:

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#generic_send"} 
ctx.genericSend({
  service: "MyService",
  method: "myHandler",
  parameter: "Hi",
  inputSerde: restate.serde.json,
});
```

<Info>
    Calls to a Virtual Object execute in order of arrival, serially.
    Example:

    ```typescript {"CODE_LOAD::ts/src/develop/service_communication.ts#ordering"} 
ctx.objectSendClient(MyObject, "Mary").myHandler("I'm call A");
ctx.objectSendClient(MyObject, "Mary").myHandler("I'm call B");
```

    Call A is guaranteed to execute before B. However, other invocations may interleave between A and B.
</Info>

## Delayed messages

Send a message after a delay.

Use the same send methods with a delay option in [`sendOpts`](https://docs.restate.dev/tsdocs/types/_restatedev_restate-sdk.ClientSendOptions).


```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#delayed"} 
// To message a Service with a delay:
ctx
  .serviceSendClient(MyService)
  .myHandler("Hi", restate.rpc.sendOpts({ delay: { seconds: 5 } }));

// To message a Virtual Object with a delay:
ctx
  .objectSendClient(MyObject, "Mary")
  .myHandler("Hi", restate.rpc.sendOpts({ delay: { seconds: 5 } }));

// To message a Workflow with a delay:
ctx
  .workflowSendClient(MyWorkflow, "Mary")
  .run("Hi", restate.rpc.sendOpts({ delay: { seconds: 5 } }));
```

Use [`ctx.genericSend`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#genericsend) with a delay when you don't have the service definition:

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#generic_delayed"} 
ctx.genericSend({
  service: "MyService",
  method: "myHandler",
  parameter: "Hi",
  inputSerde: restate.serde.json,
  delay: { seconds: 5 },
});
```

<Info>
    Learn [how this is different](/develop/ts/durable-timers#scheduling-async-tasks) from sleeping and then sending a message.
</Info>

## Using an idempotency key

Prevent duplicate executions of the same call.

Add an idempotency key via [`restate.rpc.opts`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.rpc.opts) or [`restate.rpc.sendOpts`](https://docs.restate.dev/tsdocs/functions/_restatedev_restate-sdk.rpc.sendOpts).

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#idempotency_key"} 
// For request-response
const response = await ctx.serviceClient(MyService).myHandler(
  "Hi",
  restate.rpc.opts({
    idempotencyKey: "my-idempotency-key",
  })
);
// For sending a message
ctx.serviceSendClient(MyService).myHandler(
  "Hi",
  restate.rpc.sendOpts({
    idempotencyKey: "my-idempotency-key",
  })
);
```

Note: Restate automatically deduplicates calls made during the same handler execution, so there's no need to provide an idempotency key in that case.
However, if multiple handlers might call the same service independently, you can use an idempotency key to ensure deduplication across those calls.

## Attach to an invocation

Wait for or get the result of a previously sent message.

Use [`ctx.attach`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#attach) with the invocation ID.

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#attach"} 
const handle = ctx.serviceSendClient(MyService).myHandler(
  "Hi",
  restate.rpc.sendOpts({
    idempotencyKey: "my-idempotency-key",
  })
);
const invocationId = await handle.invocationId;

// Later...
const response = ctx.attach(invocationId);
```

- With an idempotency key: Wait for completion and retrieve the result.
- Without an idempotency key: Can only wait, not retrieve the result.


## Cancel an invocation

Cancel a running handler.

Use [`ctx.cancel`](https://docs.restate.dev/tsdocs/interfaces/_restatedev_restate-sdk.Context#cancel) with the invocation ID:

```ts {"CODE_LOAD::ts/src/develop/service_communication.ts#cancel"} 
const handle = ctx.serviceSendClient(MyService).myHandler("Hi");
const invocationId = await handle.invocationId;

// Cancel the invocation
ctx.cancel(invocationId);
```

## See also

- **[SDK Clients](/develop/ts/clients)**: Call Restate services from external applications
- **[Error Handling](/develop/ts/error-handling)**: Handle failures and terminal errors in service calls
- **[Durable Timers](/develop/ts/durable-timers)**: Implement timeouts for your service calls
- **[Serialization](/develop/ts/serialization)**: Customize how data is serialized between services
- **[Sagas](/guides/sagas)**: Roll back or compensate for canceled service calls.
