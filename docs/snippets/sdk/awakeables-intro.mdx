Sometimes your handlers need to pause and wait for external processes to complete. This is common in:

- **Human-in-the-loop workflows** (approvals, reviews, manual steps)
- **External system integration** (waiting for webhooks, async APIs)
- **AI agent patterns** (tool execution, human oversight)

This pattern is also known as the **callback** or **task token** pattern.

## Two Approaches

Restate provides two primitives for handling external events:

| Primitive | Use Case | Key Feature |
|-----------|----------|--------------|
| **Awakeables** | Services & Virtual Objects | Unique ID-based completion |
| **Durable Promises** | Workflows only | Named promises for simpler signaling |

## How it works

Implementing this pattern in a distributed system is tricky, since you need to ensure that the handler can recover from failures and resume waiting for the external event.

Restate makes promises are durable and distributed. They survive crashes and can be resolved or rejected by any handler in the workflow.

To save costs on FaaS deployments, Restate lets the handler [suspend](/basics/key-concepts#suspensions-on-faas) while awaiting the promise, and invokes it again when the result is available.

## Awakeables

**Best for:** Services and Virtual Objects where you need to coordinate with external systems.