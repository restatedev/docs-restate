---
title: "Sessions and context"
description: "Build persistent chat sessions that survive interruptions and maintain conversation state."
tags: ["recipe"]
---

import StartExample from "/snippets/ai-guides/start-example.mdx";

Build persistent, stateful chat sessions that handle long-running conversations across multiple interactions and users.

In many scenarios, you have long-running multi-turn conversations with agents. A user might start a conversation now, respond hours later, and return again after a few days. Multiple users may be having separate conversations going on, and a single conversation may be open in multiple browser windows.

## How does Restate help?

To implement stateful entities like chat sessions, or stateful agents, Restate provides Virtual Objects.
Each Virtual Object instance maintains isolated state and is identified by a unique key.
Virtual Objects let you build durable chat sessions that maintain conversation state across multiple interactions, survive process restarts, and handle concurrent messages gracefully.

<img src="/img/ai/patterns/chat_objects.png" alt="Chat playground"/>

Restate provides:
- **Durable state**: Conversation history persists across failures and restarts
- **Session isolation**: Each chat gets isolated state with automatic concurrency control
- Works with **any AI SDK** (OpenAI, LangChain, Pydantic AI, LiteLLM, etc.) and **any programming language** supported by Restate (TypeScript, Python, Go, etc.)
- **Message ordering**: Concurrent messages are queued and processed sequentially

<img src="/img/ai/patterns/chat_queue.png" alt="Chat playground"/>

## Example

Use Virtual Objects to create persistent chat sessions. Each session is identified by a key (user_id or session_id) and maintains conversation state across multiple interactions.

<CodeGroup>

```ts TypeScript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/ai-examples/refs/heads/typescript_patterns/typescript-patterns/src/chat.ts#here"} 
async function onMessage(ctx: ObjectContext, { message }: { message: string }) {
  const messages = (await ctx.get<Array<ModelMessage>>("memory")) ?? [];
  messages.push({ role: "user", content: message });

  const result = await ctx.run("LLM call", async () => llmCall(messages));

  messages.push({ role: "assistant", content: result });
  ctx.set("memory", messages);

  return result;
}

export default restate.object({
  name: "Chat",
  handlers: {
    message: restate.createObjectHandler(
      { input: zodPrompt(examplePrompt) },
      onMessage,
    ),
  },
});
```

```python Python {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/ai-examples/refs/heads/typescript_patterns/python-patterns/app/chat.py?collapse_prequel"} 
chat = restate.VirtualObject("Chat")


@chat.handler()
async def on_message(ctx: restate.ObjectContext, message: ChatMessage) -> str | None:
    """A long-lived stateful chat session that allows for ongoing conversation."""

    # Retrieve conversation memory from Restate
    memory = await ctx.get("memory", type_hint=list[dict]) or []
    memory.append({"role": "user", "content": message.message})

    result = await ctx.run_typed(
        "LLM call",
        llm_call,
        RunOptions(max_attempts=3),
        messages=memory,
    )

    # Update conversation memory in Restate
    memory.append({"role": "assistant", "content": result.content})
    ctx.set("memory", memory)

    return result.content
```

</CodeGroup>

View on GitHub: [TS](https://github.com/restatedev/ai-examples/blob/typescript_patterns/typescript-patterns/src/chat.ts) /
[Python](https://github.com/restatedev/ai-examples/blob/main/python-patterns/app/chat.py)


Virtual Objects guarantee that a single instance exists per key, queue interactions, and store transactional state. They offer a convenient way to store the message history and other data, like the last agent who the user talked to.

<Tip>
    This pattern is complementary to AI memory solutions like mem0 or graffiti. You can use Virtual Objects to enforce session concurrency and queueing while storing the agent's memory in specialized memory systems.
</Tip>

<Tip>
    This pattern is implementable with any of our SDKs and any AI SDK.
    If you need help with a specific SDK, please reach out to us via [Discord](https://discord.com/invite/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA).
</Tip>

## Running the example

<Steps>
<StartExample/>
<Step title="Send messages to a chat session">

    <Tabs>
    <Tab title="UI">
        In the UI (`http://localhost:9070`), click on the `on_message` handler of the `Chat` service to open the playground.
        Enter a key for the chat session (e.g., `session123`) and send messages to start a conversation.

        <img src="/img/ai/patterns/chat-playground.png" alt="Chat playground"/>

    </Tab>
        <Tab title="curl">
            Send a request to the service:

    <CodeGroup>
    ```shell TypeScript
    curl localhost:8080/Chat/user123/onMessage \
      --json '{"message": "Write a poem about Durable Execution?"}'
    ```
    ```shell Python
    curl http://localhost:8080/Chat/user123/on_message \
      --json '{"message": "Write a poem about Durable Execution?"}'
    ```
    </CodeGroup>
        </Tab>
    </Tabs>

    The session state (conversation history) is automatically persisted and maintained across calls.
    Send additional messages with the same session ID to see how the conversation context is preserved. For example, ask to shorten the poem.

</Step>

<Step title="Check the Restate UI">

    In the State Tab, you can view what is stored in Restate for each chat session:
    <img src="/img/ai/patterns/chat-state.png" alt="Chat session state - UI"/>

</Step>
</Steps>