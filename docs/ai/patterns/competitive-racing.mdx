---
title: "Competitive Racing"
sidebarTitle: "Competitive Racing"
description: "Run agents in parallel, return the fastest response and cancel the others."
tags: ["recipe"]
---

import StartExample from "/snippets/ai-guides/start-example.mdx";

Execute multiple AI approaches or strategies simultaneously and return the result from whichever completes first successfully. This pattern is ideal when you have multiple ways to solve the same problem and want to minimize latency by racing them against each other.

Useful for:
- Querying multiple AI models (e.g., GPT-4, Claude, Gemini) and returning the fastest response
- Running different agents, prompts or strategies in parallel and using the first successful outcome

## How does Restate help?

The benefits of using Restate for competitive racing patterns are:
- **First-to-succeed optimization**: Restate lets you race multiple approaches and automatically return the first successful result
- **Durable coordination**: Restate turns Promises/Futures into durable, distributed constructs that persist across failures and process restarts
- **Cancel slow tasks**: Failed or slower approaches can be cancelled, preventing resource waste
- **Serverless scaling**: Deploy racing strategies on serverless infrastructure for automatic scaling while the main process remains suspended
- Works with **any AI SDK** (OpenAI, LangChain, Vercel AI SDK, LiteLLM, etc.) and **any programming language** supported by Restate (TypeScript, Python, Go, etc.)

## Example

When you need a quick response and have access to multiple AI models, race them against each other to get the fastest result:

<CodeGroup>
```ts TypeScript {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/ai-examples/refs/heads/typescript_patterns/typescript-patterns/src/racing-agents.ts#here"} 
async function run(
  ctx: Context,
  { message }: { message: string },
): Promise<string> {
  // Start both service calls concurrently
  const slowCall = ctx.serviceClient(racingAgent).thinkLonger({ message });
  const slowResponse = slowCall.map((res) => ({ tag: "slow", res }));

  const fastCall = ctx.serviceClient(racingAgent).respondQuickly({ message });
  const fastResponse = fastCall.map((res) => ({ tag: "fast", res }));

  const pending = [slowResponse, fastResponse];

  // Wait for the first one to complete
  const { tag, res } = await RestatePromise.any(pending);

  if (tag === "fast") {
    console.log("Quick response won the race!");
    const slowInvocationId = await slowCall.invocationId;
    ctx.cancel(slowInvocationId);
  } else {
    console.log("Deep analysis won the race!");
    const quickInvocationId = await fastCall.invocationId;
    ctx.cancel(quickInvocationId);
  }

  return res ?? "LLM gave no response";
}
```
```python Python {"CODE_LOAD::https://raw.githubusercontent.com/restatedev/ai-examples/refs/heads/typescript_patterns/python-patterns/app/racing_agents.py?collapse_prequel"} 
racing_agent = Service("RacingAgent")


@racing_agent.handler()
async def run(ctx: Context, query: Question):
    """Run two approaches in parallel and return the fastest response."""
    # Start both service calls concurrently
    slow_response = ctx.service_call(think_longer, arg=query)
    quick_response = ctx.service_call(respond_quickly, arg=query)

    done, pending = await restate.wait_completed(slow_response, quick_response)

    # cancel the pending calls
    for f in pending:
        call_future = typing.cast(RestateDurableCallFuture, f)
        ctx.cancel_invocation(await call_future.invocation_id())

    # return the fastest result
    return await done[0]




@racing_agent.handler()
async def think_longer(ctx: Context, req: Question) -> str:
    output = await ctx.run_typed(
        "Deep analysis",
        llm_call,
        RunOptions(max_attempts=3),
        prompt=f"Analyze this thoroughly: {req}",
    )
    return output.content


@racing_agent.handler()
async def respond_quickly(ctx: Context, req: Question) -> str:
    output = await ctx.run_typed(
        "Quick response",
        llm_call,
        RunOptions(max_attempts=3),
        prompt=f"Quick answer: {req}",
    )
    return output.content
```
</CodeGroup>

View on GitHub: [TS](https://github.com/restatedev/ai-examples/blob/typescript_patterns/typescript-patterns/src/racing-agents.ts) /
[Python](https://github.com/restatedev/ai-examples/blob/main/python-patterns/app/racing_agents.py)

In the Restate UI, you can see how multiple approaches are started simultaneously, with the first successful result being returned while other tasks are automatically cancelled:

<img src="/img/ai/patterns/racing.png" alt="Competitive racing execution - UI"/>

<Accordion title="Run the example">
    <Steps>
        <StartExample/>

        <Step title="Send a request">
        In the UI (`http://localhost:9070`), click on the `run` handler of the `RacingAgent` service to open the playground and send a prompt to race multiple models:
        <img src="/img/ai/patterns/racing_playground.png" alt="Agent racing - UI"/>
        </Step>

        <Step title="Check the Restate UI">
        In the UI, you can see how multiple models are queried simultaneously, with the fastest response winning the race:

        <img src="/img/ai/patterns/racing.png" alt="Competitive racing execution - UI"/>
        </Step>

    </Steps>
</Accordion>