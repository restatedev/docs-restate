---
title: "Workflows"
description: "Build resilient, low-latency workflows with code, not configuration."
icon: "diagram-subtask"
---

## Why Restate for Workflows?

Traditional workflow orchestrators require you to learn new DSLs, manage complex infrastructure, and work around platform limitations. Restate takes a different approach: **write workflows as regular code** in your preferred programming language, with automatic durability and resilience built in.

### Code-First Approach

Write workflows using familiar programming constructs instead of YAML or JSON configurations:

```typescript
export const orderProcessing = restate.workflow({
  name: "order-processing",
  handlers: {
    run: async (ctx: WorkflowContext, order: Order) => {
      // Use regular if/else, loops, and functions
      if (order.amount > 1000) {
        await ctx.run("fraud-check", () => checkForFraud(order));
      }
      
      // Parallel execution with Promise.all equivalent
      const [payment, inventory] = await RestatePromise.all([
        ctx.run("charge", () => chargePayment(order)),
        ctx.run("reserve", () => reserveInventory(order))
      ]);
      
      return { success: payment.success && inventory.success };
    }
  }
});
```

**Benefits:**
- No need to learn a new DSL or configuration language
- Use your familiar libraries
- Test and debug workflows with standard tools

### Low-Latency Performance

Restate is built from the ground up for low-latency workflow execution. Unlike traditional orchestrators that add significant overhead, Restate workflows can be placed directly in the latency-sensitive path of user interactions:

- **Lightweight execution**: Workflows run like regular functions with minimal overhead
- **Event-driven foundation**: Built in Rust for high-performance, low-latency operations
- **No coordination delays**: Direct workflow execution via a push-based model

<Info>
[Benchmark results Restate v1.2](https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/#some-performance-numbers)
</Info>

### Simple deployment model

Unlike other orchestrators that require separate worker pools, message queues, and databases, Restate packages everything in a single binary that runs alongside your existing services:

- **No external dependencies**: Single binary deployment with built-in persistence
- **No worker management**: Deploy workflows like regular HTTP services
- **No message queues**: Built-in reliable messaging and state management
- **No separate databases**: Automatic state persistence

### Developer Experience Focused

**Familiar Programming Model**
- Implement RPC-style services with workflow-like resiliency.
- Gives workflow semantics to any function: automatic retries, recovery of progress, and distributed coordination.
- Get distributed, durable versions of familiar programming building blocks: promises, timers, state, and events.

**Flexible Deployment**
- Works with your existing deployment pipeline
- Supports containers, Kubernetes, serverless functions
- No platform-specific configurations required

**Natural Error Handling**
- Use try/catch blocks instead of learning error handling DSLs
- Automatic retries with customizable policies
- Natural support for saga patterns and compensating transactions

**Built-in Observability**
- View workflow execution traces in the Restate UI
- Step-by-step debugging without external tools
- Real-time state inspection and querying

## Key Workflow Patterns

### Flexible Activity Execution

Restate gives you the flexibility to structure your workflows however makes sense for your application. You can execute steps inline within the workflow or split them out into separate services that can scale independently or are owned by different teams:

```typescript
export const userSignup = restate.workflow({
  name: "user-signup", 
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      // Move user DB interaction to dedicated service
      const success = await ctx
        .serviceClient(userService)
        .createUser({ userId, user });
      if (!success) return { success };

      // Execute other steps inline
      await ctx.run("activate", () => activateUser(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));
      
      return { success: true };
    }
  }
});
```

### Durable State and Queries
Store workflow state that survives crashes and can be queried from external systems:

```typescript
// Store intermediate results
ctx.set("payment-status", "completed");
ctx.set("order-details", order);

// Query from external handler
getOrderStatus: async (ctx) => {
  return {
    payment: await ctx.get("payment-status"),
    order: await ctx.get("order-details")
  };
}
```

### Event-Driven Coordination
Handle external events and signals without complex event sourcing infrastructure:

```typescript
// Wait for external approval
const approval = await ctx.promise<boolean>("manager-approval");

// External system resolves the promise
approve: async (ctx, decision: boolean) => {
  await ctx.promise<boolean>("manager-approval").resolve(decision);
}
```

### Durable Timers and Scheduling
Long-running processes with built-in timer management:

```typescript
// Wait for user action with timeout
const userAction = ctx.promise<string>("user-response");
const timeout = ctx.sleep({ hours: 24 });

const result = await RestatePromise.race([userAction, timeout]);
if (result === timeout) {
  // Handle timeout scenario
}
```

## When to Choose Restate

**âœ… Choose Restate when you need:**
- **Low-latency workflows** - Place workflows in latency-sensitive user interactions
- **Familiar programming model** - Use promises, timers, and control flow you already know
- **Flexible architecture** - Mix inline execution with separate services as needed
- **Operational simplicity** - Focus on business logic, not managing complex infrastructure
- **Language flexibility** - Use TypeScript, Python, Go, Java, Kotlin, or Rust
- **Serverless compatibility** - Run long workflows on FaaS platforms cost-effectively
- **Testing and debugging** - Standard development tools and practices
- **Gradual adoption** - Start with simple workflows, extend to other services over time

<Info>
    Evaluating Restate and missing a feature? Contact us on [Discord](https://discord.com/invite/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA).
</Info>

## Comparison with Other Solutions

| Feature | Restate                                    | Traditional Orchestrators |
|---------|--------------------------------------------|--------------------------|
| **Performance** | Low-latency, lightweight execution         | High overhead, poll-for-work delays |
| **Language** | Native code (TS, Python, Go, Java, Kotlin, Rust)   | DSLs, YAML, or proprietary languages |
| **Development** | Standard IDE, testing, debugging           | Platform-specific tooling |
| **Infrastructure** | Single binary, no dependencies             | Separate databases and queues |
| **Service Deployment** | Any platform (containers, serverless, K8s) | Worker-based deployment models |
| **State Management** | Built-in K/V state store                     | External state stores required |
| **Observability** | Automatic tracing and debugging            | Additional monitoring setup |

## Getting Started

Ready to build workflows with Restate? Here are your next steps:

<CardGroup cols={2}>
  <Card title="Hands-on Tutorial" icon="play" href="/tour/workflows">
    Follow our interactive workflow tour with real code examples
  </Card>
  <Card title="Error Handling Guide" icon="shield-exclamation" href="/guides/error-handling">  
    Learn about retries, saga patterns, and failure recovery
  </Card>
  <Card title="SDK Documentation" icon="code" href="/develop/ts/workflows">
    Dive into SDK-specific workflow features and patterns
  </Card>
  <Card title="Deployment Options" icon="rocket" href="/deploy">
    Deploy workflows on your preferred platform
  </Card>
</CardGroup>

## Real-World Examples

Explore workflow patterns for common use cases:

- **E-commerce**: [Order processing with payments and inventory](/examples/order-processing)
- **User Onboarding**: [Multi-step signup with email verification](/tour/workflows)  
- **Data Processing**: [ETL pipelines with error recovery](/guides/sagas)
- **Approval Workflows**: [Human-in-the-loop processes](/develop/ts/service-communication)