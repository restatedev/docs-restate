---
title: "Workflows"
description: "Build resilient, low-latency workflows with code, not configuration."
icon: "diagram-subtask"
---

## Why Restate for Workflows?

Traditional workflow orchestrators require you to learn new DSLs, manage complex infrastructure, and work around platform limitations. Restate takes a different approach: **write workflows as regular code** in your preferred programming language, with automatic durability and resilience built in.

### Code-First Development

Write workflows using familiar programming constructs instead of YAML or JSON configurations:

```typescript {"CODE_LOAD::ts/src/use-cases/order-processing.ts#here"} 
export const orderProcessing = restate.workflow({
  name: "order-processing",
  handlers: {
    run: async (ctx: WorkflowContext, order: Order) => {
      // Use regular if/else, loops, and functions
      if (order.amount > 1000) {
        await ctx.run("fraud-check", () => checkForFraud(order));
      }

      // Parallel execution with Promise.all equivalent
      const [payment, inventory] = await RestatePromise.all([
        ctx.run("charge", () => chargePayment(order)),
        ctx.run("reserve", () => reserveInventory(order)),
      ]);

      return { success: payment.success && inventory.success };
    },
  },
});
```

**Familiar Programming Model:**
- Use standard language constructs (if/else, loops, promises) instead of DSLs
- Handle errors naturally with try/catch blocks and automatic retries
- Test and debug with your existing IDE and tools
- Deploy workflows like regular HTTP services
- Available in TypeScript, Python, Go, Java, Kotlin, and Rust

### Low-Latency Performance

Restate is built from the ground up for low-latency workflow execution. Unlike traditional orchestrators that add significant overhead, Restate workflows can be placed directly in the latency-sensitive path of user interactions:

- **Lightweight execution**: Workflows run like regular functions with minimal overhead
- **Event-driven foundation**: Built in Rust for high-performance, low-latency operations
- **No coordination delays**: Direct workflow execution via a push-based model

<Info>
[Benchmark results Restate v1.2](https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/#some-performance-numbers)
</Info>

### Simple Deployment Model

<img src="/img/tour/app_layout.svg" alt="Application Structure"/>
**Restate Server**: Unlike other orchestrators that require separate worker pools, message queues, and databases, Restate packages everything in a single binary with built-in persistence and messaging.

**Service Deployment**:
- Deploy your workflows using your existing deployment pipeline: containers, Kubernetes, serverless functions, or any HTTP-capable platform.
- No platform-specific configurations or worker management required.
- Deploy on FaaS and use Restate's smart suspension mechanism to avoid paying for wait/idle time.


## Key Workflow Patterns

### Flexible Activity Execution

Restate gives you the flexibility to structure your workflows however makes sense for your application. You can execute steps inline within the workflow or split them out into separate services that can scale independently or are owned by different teams:

```typescript {"CODE_LOAD::ts/src/use-cases/signup.ts#here"} 
export const userSignup = restate.workflow({
  name: "user-signup",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key;

      // Move user DB interaction to dedicated service
      const success = await ctx
        .serviceClient(userService)
        .createUser({ userId, user });
      if (!success) return { success };

      // Execute other steps inline
      await ctx.run("activate", () => activateUser(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));

      return { success: true };
    },
  },
});
```

### Durable State and Queries
Store workflow state that survives crashes and can be queried from external systems:

```typescript {"CODE_LOAD::ts/src/use-cases/workflow-actions.ts#state"} 
// Store intermediate results
ctx.set("payment-status", "completed");
ctx.set("order-details", order);
```

```typescript {"CODE_LOAD::ts/src/use-cases/workflow-actions.ts#state_get"} 
// Query from external handler
getOrderStatus: async (ctx: restate.WorkflowSharedContext) => {
  return {
    payment: await ctx.get("payment-status"),
    order: await ctx.get("order-details"),
  };
},
```

### Event-Driven Coordination
Handle external events and signals without complex event sourcing infrastructure:

```typescript {"CODE_LOAD::ts/src/use-cases/workflow-actions.ts#approval"} 
// Wait for external approval
const approval = await ctx.promise<boolean>("manager-approval");
```
```typescript {"CODE_LOAD::ts/src/use-cases/workflow-actions.ts#approve"} 
// External system resolves the promise
approve: async (ctx: restate.WorkflowSharedContext, decision: boolean) => {
  await ctx.promise<boolean>("manager-approval").resolve(decision);
},
```

### Durable Timers and Scheduling
Long-running processes with built-in timer management:

```typescript {"CODE_LOAD::ts/src/use-cases/workflow-actions.ts#timers"} 
// Wait for user action with timeout
try {
  const userAction = ctx
    .promise<string>("user-response")
    .get()
    .orTimeout({ hours: 24 });
} catch (error) {
  if (error instanceof restate.TimeoutError) {
    // Handle timeout
  }
  // Handle other errors
}
```

## When to Choose Restate

**âœ… Choose Restate when you need:**
- **Low-latency workflows**: Place workflows in latency-sensitive user interactions
- **Familiar programming model**: Use promises, timers, and control flow you already know
- **Flexible architecture**: Mix inline execution with separate services as needed
- **Operational simplicity**: Focus on business logic, not managing complex infrastructure
- **Language flexibility**: Use TypeScript, Python, Go, Java, Kotlin, or Rust
- **Serverless compatibility**: Run long workflows on FaaS platforms cost-effectively
- **Testing and debugging**: Standard development tools and practices
- **Gradual adoption**: Start with simple workflows, extend to your entire microservices application over time

<Info>
    Evaluating Restate and missing a feature? Contact us on [Discord](https://discord.com/invite/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA).
</Info>

## Comparison with Other Solutions

| Feature | Restate                                    | Traditional Orchestrators |
|---------|--------------------------------------------|--------------------------|
| **Performance** | Low-latency, lightweight execution         | High overhead, poll-for-work delays |
| **Language** | Native code (TS, Python, Go, Java, Kotlin, Rust)   | DSLs, YAML, or proprietary languages |
| **Development** | Standard IDE, testing, debugging           | Platform-specific tooling |
| **Infrastructure** | Single binary, no dependencies             | Separate databases and queues |
| **Service Deployment** | Any platform (containers, serverless, K8s) | Worker-based deployment models |
| **State Management** | Built-in K/V state store                     | External state stores required |

## Getting Started

Ready to build workflows with Restate? Here are your next steps:

<CardGroup cols={3}>
  <Card title="Quickstart" icon="rocket" href="/guides/error-handling">
    Run your first Restate service
  </Card>
  <Card title="Hands-on Tutorial" icon="pen" href="/tour/workflows">
    Explore the APIs to build workflows with Restate
  </Card>
  <Card title="Need help?" icon="thought-bubble">
    Discuss your use case with us via <strong>[Discord](https://discord.gg/skW3AZ6uGd)</strong> or <strong>[Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA)</strong>.
  </Card>
</CardGroup>

## Examples

Explore workflow patterns for common use cases:

- **E-commerce**: Order processing with payments and inventory
- **Human-in-the-loop workflows**: [Multi-step signup with email verification](/tour/workflows)
- **Infrastructure provisioning**: Retry until resources are up, handle timeouts, rollbacks, etc.
- **[AI workflows](https://github.com/restatedev/ai-examples) and [Workflow interpreters](https://github.com/restatedev/examples/tree/main/typescript/end-to-end-applications/ai-image-workflows)**: Dynamically follow different paths based on LLM decisions or external data