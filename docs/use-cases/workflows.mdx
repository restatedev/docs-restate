---
title: "Workflows"
description: "Build resilient, low-latency workflows with code."
icon: "diagram-subtask"
---

Restate lets you **write workflows as regular code** in your preferred programming language, with automatic resilience.


## Low-Latency Workflows

Restate is built from the ground up for low-latency workflow execution. Restate workflows can be placed directly in the latency-sensitive path of user interactions:

- **Lightweight execution**: Workflows run like regular functions with minimal overhead
- **Event-driven foundation**: Built in Rust for high-performance, low-latency operations
- **No coordination delays**: Immediate workflow execution via a push-based model

<Info>
    [Benchmark results Restate v1.2](https://restate.dev/blog/building-a-modern-durable-execution-engine-from-first-principles/#some-performance-numbers)
</Info>

## Familiar Programming Model

Write resilient workflows using familiar programming constructs:
- Automatically retry transient errors like infrastructure crashes and network failures
- Use standard language constructs (if/else, loops) and durable versions of familiar building blocks (e.g., timers, promises)
- Handle errors naturally with try/catch blocks and automatic retries
- Test and debug with your existing IDE and standard development tools

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/workflows/simple-signup.ts#here"} 
export const userSignup = restate.workflow({
  name: "user-signup",
  handlers: {
    run: async (ctx: WorkflowContext, user: User) => {
      const userId = ctx.key; // unique workflow key

      // Use regular if/else, loops, and functions
      const success = await ctx.run("create", () => createUser(userId, user));
      if (!success) return { success };

      // Execute durable steps
      await ctx.run("activate", () => activateUser(userId));
      await ctx.run("welcome", () => sendWelcomeEmail(user));

      return { success: true };
    },
  },
});
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/workflows/UserSignup.java#here"} 
@Workflow
public class UserSignup {

  @Workflow
  public boolean run(WorkflowContext ctx, User user) {
    String userId = ctx.key(); // unique workflow key

    // Use regular if/else, loops, and functions
    boolean success = ctx.run("create", Boolean.class, () -> createUser(userId, user));
    if (!success) {
      return false;
    }

    // Execute durable steps
    ctx.run("activate", () -> activateUser(userId));
    ctx.run("welcome", () -> sendWelcomeEmail(user));

    return true;
  }
}
```

```python Python {"CODE_LOAD::python/src/usecases/workflows/signup.py#here"} 
user_signup = restate.Workflow("user-signup")


@user_signup.main()
async def run(ctx: restate.WorkflowContext, user: User) -> Dict[str, bool]:
    # Unique workflow key
    user_id = ctx.key()

    # Use regular if/else, loops, and functions
    success = await ctx.run_typed("create", create_user, user_id=user_id, user=user)
    if not success:
        return {"success": False}

    # Execute durable steps
    await ctx.run_typed("activate", activate_user, user_id=user_id)
    await ctx.run_typed("welcome", send_welcome_email, user=user)

    return {"success": True}
```

```go Go {"CODE_LOAD::go/usecases/workflows/signup.go#here"} 
type UserSignup struct{}

func (UserSignup) Run(ctx restate.WorkflowContext, user User) (bool, error) {
  // unique workflow key
  userID := restate.Key(ctx)

  // Use regular if/else, loops, and functions
  success, err := restate.Run(ctx, func(ctx restate.RunContext) (bool, error) {
    return CreateUser(userID, user)
  })
  if err != nil || !success {
    return false, err
  }

  // Execute durable steps
  _, err = restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return ActivateUser(userID)
  })
  if err != nil {
    return false, err
  }

  _, err = restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return SendWelcomeEmail(user)
  })
  if err != nil {
    return false, err
  }

  return true, nil
}
```
</CodeGroup>

## Simple Deployment Model

<img src="/img/tour/app_layout.svg" alt="Application Structure"/>
**Restate Server**: Restate is packaged as a single binary with built-in persistence and messaging. Run it as a single instance or in a high-availability cluster.

**Service Deployment**: Deploy your workflows using your existing deployment pipeline: containers, Kubernetes, serverless functions, or any HTTP-capable platform.

On FaaS, Restate's suspends workflows while they are waiting (e.g. timer) to reduce costs.



## Key Workflow Patterns

<CardGroup cols={3}>
    <Card title="Query Workflow State" icon="database" href={"/tour/workflows#querying-workflow-state"}>
        Store workflow state that survives crashes and can be queried from external systems
    </Card>
    <Card title="Event-Driven Coordination" icon="bolt" href={"/tour/workflows#signaling"}>
        Handle external events and signals without complex event sourcing infrastructure
    </Card>
    <Card title="Durable Timers and Scheduling" icon="clock" href={"/tour/workflows#timers-and-scheduling"}>
        Long-running processes with built-in timer management and timeout handling
    </Card>
    <Card title="Flexible Activity Execution" icon="code-branch" href={"/tour/workflows#in-line-steps-vs-separate-activities"}>
        Execute steps inline within the workflow or split them out into separate services
    </Card>
    <Card title="Parallelize Work" icon="arrows-split-up-and-left" href="/guides/parallelizing-work">
        Speed up multi-step workflows with recoverable parallel tasks
    </Card>
    <Card title="Resilient rollback" icon="backward" href="/guides/sagas">
        Automatically undo previous actions when later steps fail
    </Card>
</CardGroup>

## Comparison with Other Solutions

| Feature | Restate                                    | Traditional Orchestrators |
|---------|--------------------------------------------|--------------------------|
| **Performance** | Low-latency, lightweight execution         | High overhead, poll-for-work delays |
| **Language** | Native code (TS, Python, Go, Java, Kotlin, Rust)   | DSLs or YAML |
| **Development** | Standard IDE, testing, debugging           | Platform-specific tooling |
| **Infrastructure** | Single binary, no dependencies             | Separate databases and queues |
| **Service Deployment** | Any platform (containers, serverless, K8s) | Worker-based deployment models |
| **State Management** | Built-in K/V state store                     | External state stores required |

## Getting Started

Ready to build workflows with Restate? Here are your next steps:


<CardGroup cols={3}>
  <Card title="Quickstart" icon="rocket" href="/guides/error-handling">
    Run your first Restate service
  </Card>
  <Card title="Hands-on Tutorial" icon="pen" href="/tour/workflows">
    Explore the APIs to build workflows with Restate
  </Card>
  <Card title="Examples" icon="code" href="https://github.com/restatedev/examples">
     Explore templates, patterns, and end-to-end applications
  </Card>
</CardGroup>

<Info>
    Evaluating Restate and missing a feature? Contact us on [Discord](https://discord.com/invite/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA).
</Info>