---
title: "Microservice Orchestration"
description: "Build resilient, distributed microservices with durable execution, sagas, and reliable service communication."
icon: "circle-nodes"
---

Traditional microservice orchestration requires complex infrastructure: message brokers, workflow engines, state stores, and retry mechanisms. Restate simplifies this by providing **durable execution primitives** that make distributed systems resilient by default, without the operational overhead.

### Durable Execution

Build microservices that automatically recover from failures without losing progress:

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/order-service.ts#here"} 
export const orderService = restate.service({
  name: "OrderService",
  handlers: {
    process: async (ctx: restate.Context, order: Order) => {
      // Each step is automatically durable and resumable
      const paymentId = ctx.rand.uuidv4();

      await ctx.run(() => chargePayment(order.creditCard, paymentId));

      for (const item of order.items) {
        await ctx.run(() => reserveInventory(item.id, item.quantity));
      }
      return { success: true, paymentId };
    },
  },
});
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/OrderService.java#here"} 
@Service
public class OrderService {
  
  @Handler
  public OrderResult process(Context ctx, Order order) {
    // Each step is automatically durable and resumable
    String paymentId = UUID.randomUUID().toString();

    ctx.run(() -> chargePayment(order.creditCard, paymentId));

    for (var item : order.items) {
      ctx.run(() -> reserveInventory(item.id, item.quantity));
    }
    
    return new OrderResult(true, paymentId);
  }
}
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/order_service.py#here"} 
order_service = restate.Service("OrderService")


@order_service.handler()
async def process(ctx: restate.Context, order: Order):
    # Each step is automatically durable and resumable
    payment_id = str(uuid.uuid4())

    await ctx.run_typed(
        "charge", charge_payment, credit_card=order.credit_card, payment_id=payment_id
    )

    for item in order.items:
        await ctx.run_typed(
            f"reserve_{item.id}", reserve, item_id=item.id, amount=item.amount
        )

    return {"success": True, "payment_id": payment_id}
```

```go Go {"CODE_LOAD::go/usecases/microservices/orderservice.go#here"} 
type OrderService struct{}

func (OrderService) Process(ctx restate.Context, order Order) (OrderResult, error) {
  // Each step is automatically durable and resumable
  paymentID := restate.Rand(ctx).UUID().String()

  _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return ChargePayment(order.CreditCard, paymentID)
  })
  if err != nil {
    return OrderResult{}, err
  }

  for _, item := range order.Items {
    _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
      return ReserveInventory(item.ID, item.Quantity)
    })
    if err != nil {
      return OrderResult{}, err
    }
  }

  return OrderResult{Success: true, PaymentID: paymentID}, nil
}
```
</CodeGroup>

**Key Benefits:**
- **Automatic recovery**: Services resume exactly where they left off after failures
- **Zero message loss**: All service communication is durably logged
- **No external dependencies**: Built-in persistence and messaging
- **Standard development**: Write services like regular HTTP APIs

### Resilient Service Communication

Flexible communication patterns with strong delivery guarantees:

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/service-actions.ts#communication"} 
// Request-response: Wait for result
const result = await ctx.serviceClient(inventoryService).checkStock(item);

// Fire-and-forget: Guaranteed delivery without waiting
ctx.serviceSendClient(emailService).sendConfirmation(order);

// Delayed execution: Schedule for later
ctx
  .serviceSendClient(reminderService)
  .sendReminder(order, sendOpts({ delay: { days: 7 } }));
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/ServiceActions.java#communication"} 
// Request-response: Wait for result
var result = InventoryServiceClient.fromContext(ctx)
    .checkStock(item);

// Fire-and-forget: Guaranteed delivery without waiting
EmailServiceClient.fromContext(ctx)
    .send()
    .sendConfirmation(order);

// Delayed execution: Schedule for later
ReminderServiceClient.fromContext(ctx)
    .send()
    .sendReminder(order, Duration.ofDays(7));
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/service_actions.py#communication"} 
# Request-response: Wait for result
result = await ctx.service_call(check_stock, item)

# Fire-and-forget: Guaranteed delivery without waiting
ctx.service_send(send_confirmation_email, order)

# Delayed execution: Schedule for later
ctx.service_send(send_reminder, order, send_delay=timedelta(days=7))
```

```go Go {"CODE_LOAD::go/usecases/microservices/serviceactions.go#communication"} 
// Request-response: Wait for result
result, err := restate.Service[InventoryService](ctx, "InventoryService").CheckStock(item)
if err != nil {
  return err
}
_ = result

// Fire-and-forget: Guaranteed delivery without waiting
restate.ServiceSend(ctx, restate.Service[EmailService](ctx, "EmailService")).SendConfirmation(order)

// Delayed execution: Schedule for later
restate.ServiceSendWithDelay(ctx, restate.Service[ReminderService](ctx, "ReminderService"), 7*24*time.Hour).SendReminder(order)
```
</CodeGroup>

**Communication Guarantees:**
- **Exactly-once delivery**: Messages are never lost or duplicated
- **Built-in retries**: Automatic exponential backoff for transient failures  
- **Request deduplication**: Idempotency keys prevent duplicate processing

### State Management

Manage stateful entities without external databases or complex consistency mechanisms:

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/user-account.ts#here"} 
export default restate.object({
  name: "UserAccount",
  handlers: {
    updateBalance: async (ctx: restate.ObjectContext, amount: number) => {
      const balance = (await ctx.get<number>("balance")) ?? 0;
      const newBalance = balance + amount;

      if (newBalance < 0) {
        throw new TerminalError("Insufficient funds");
      }

      ctx.set("balance", newBalance);
      return newBalance;
    },

    getBalance: shared(async (ctx: restate.ObjectSharedContext) => {
      return (await ctx.get<number>("balance")) ?? 0;
    }),
  },
});
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/UserAccount.java#here"} 
@VirtualObject
public class UserAccount {
  private static final StateKey<Double> BALANCE = StateKey.of("balance", Double.class);

  @Handler
  public double updateBalance(ObjectContext ctx, double amount) {
    double balance = ctx.get(BALANCE).orElse(0.0);
    double newBalance = balance + amount;

    if (newBalance < 0) {
      throw new TerminalException("Insufficient funds");
    }

    ctx.set(BALANCE, newBalance);
    return newBalance;
  }

  @Shared
  public double getBalance(SharedObjectContext ctx) {
    return ctx.get(BALANCE).orElse(0.0);
  }
}
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/user_account.py#here"} 
user_account = restate.VirtualObject("UserAccount")


@user_account.handler()
async def update_balance(ctx: restate.ObjectContext, amount: float):
    balance = await ctx.get("balance") or 0.0
    new_balance = balance + amount

    if new_balance < 0:
        raise TerminalError("Insufficient funds")

    ctx.set("balance", new_balance)
    return new_balance


@user_account.handler(kind="shared")
async def get_balance(ctx: restate.ObjectSharedContext):
    return await ctx.get("balance") or 0.0
```

```go Go {"CODE_LOAD::go/usecases/microservices/useraccount.go#here"} 
type UserAccount struct{}

func (UserAccount) UpdateBalance(ctx restate.ObjectContext, amount float64) (float64, error) {
  balance, err := restate.Get[float64](ctx, "balance")
  if err != nil {
    return 0, err
  }

  currentBalance := 0.0
  if balance != nil {
    currentBalance = balance
  }

  newBalance := currentBalance + amount

  if newBalance < 0 {
    return 0, restate.TerminalError(errors.New("insufficient funds"))
  }

  restate.Set(ctx, "balance", newBalance)
  return newBalance, nil
}

func (UserAccount) GetBalance(ctx restate.ObjectSharedContext) (float64, error) {
  balance, err := restate.Get[float64](ctx, "balance")
  if err != nil {
    return 0, err
  }

  if balance == nil {
    return 0.0, nil
  }

  return balance, nil
}
```
</CodeGroup>

**State Guarantees:**
- **Strict consistency**: Single-writer semantics prevent race conditions
- **Durable persistence**: State survives crashes and deployments
- **Horizontal scaling**: Different entity keys process independently
- **Built-in querying**: Access state via UI and APIs

## Key Orchestration Patterns

### Saga Pattern Implementation

Implement resilient rollback logic for non-transient failures (e.g. flight fully booked):

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/booking-service.ts#here"} 
const bookingService = restate.service({
  name: "BookingService",
  handlers: {
    reserve: async (ctx: restate.Context, request: BookingRequest) => {
      const compensations = [];

      try {
        // Reserve hotel
        compensations.push(() => cancelHotel(request.hotelId));
        await ctx.run(() => bookHotel(request));

        // Reserve flight
        compensations.push(() => cancelFlight(request.flightId));
        await ctx.run(() => bookFlight(request));

        return { success: true };
      } catch (error) {
        // Run compensations in reverse order
        for (const compensation of compensations.reverse()) {
          await ctx.run(() => compensation());
        }
        throw error;
      }
    },
  },
});
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/BookingService.java#here"} 
@Service
public class BookingService {
  
  @Handler
  public BookingResult reserve(Context ctx, BookingRequest request) {
    List<Runnable> compensations = new ArrayList<>();

    try {
      // Reserve hotel
      compensations.add(() -> cancelHotel(request.hotelId));
      ctx.run("book-hotel", () -> bookHotel(request));

      // Reserve flight  
      compensations.add(() -> cancelFlight(request.flightId));
      ctx.run("book-flight", () -> bookFlight(request));

      return new BookingResult(true);
    } catch (Exception error) {
      // Run compensations in reverse order
      Collections.reverse(compensations);
      for (Runnable compensation : compensations) {
        ctx.run("compensation", compensation::run);
      }
      throw error;
    }
  }

  private Void cancelHotel(String hotelId) {
    // Simulate hotel cancellation
    return null;
  }

  private Void bookHotel(BookingRequest request) {
    // Simulate hotel booking
    return null;
  }

  private Void cancelFlight(String flightId) {
    // Simulate flight cancellation
    return null;
  }

  private Void bookFlight(BookingRequest request) {
    // Simulate flight booking
    return null;
  }
}
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/booking_service.py#here"} 
booking_service = restate.Service("BookingService")


@booking_service.handler()
async def reserve(ctx: restate.Context, request: BookingRequest):
    compensations = []

    try:
        # Reserve hotel
        compensations.append(lambda: cancel_hotel(request.hotel_id))
        await ctx.run_typed("book_hotel", book_hotel, request=request)

        # Reserve flight
        compensations.append(lambda: cancel_flight(request.flight_id))
        await ctx.run_typed("book_flight", book_flight, request=request)

        return {"success": True}
    except Exception as error:
        # Run compensations in reverse order
        for i, compensation in enumerate(reversed(compensations)):
            await ctx.run_typed(f"compensation_{i}", compensation)
        raise error
```

```go Go {"CODE_LOAD::go/usecases/microservices/bookingservice.go#here"} 
type BookingService struct{}

func (BookingService) Reserve(ctx restate.Context, request BookingRequest) (BookingResult, error) {
  var compensations []func() error

  defer func() {
    if r := recover(); r != nil {
      // Run compensations in reverse order
      for i := len(compensations) - 1; i >= 0; i-- {
        restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
          compensations[i]()
          return restate.Void{}, nil
        })
      }
      panic(r)
    }
  }()

  // Reserve hotel
  compensations = append(compensations, func() error { return CancelHotel(request.HotelID) })
  _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return restate.Void{}, BookHotel(request)
  })
  if err != nil {
    // Run compensations in reverse order
    for i := len(compensations) - 1; i >= 0; i-- {
      restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
        compensations[i]()
        return restate.Void{}, nil
      })
    }
    return BookingResult{}, err
  }

  // Reserve flight
  compensations = append(compensations, func() error { return CancelFlight(request.FlightID) })
  _, err = restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return restate.Void{}, BookFlight(request)
  })
  if err != nil {
    // Run compensations in reverse order
    for i := len(compensations) - 1; i >= 0; i-- {
      restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
        compensations[i]()
        return restate.Void{}, nil
      })
    }
    return BookingResult{}, err
  }

  return BookingResult{Success: true}, nil
}
```
</CodeGroup>

### Event-Driven Coordination  

Wait for external events and webhooks with promises that survive crashes:

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/service-actions.ts#awakeables"} 
// Wait for external payment confirmation
const confirmation = ctx.awakeable<PaymentResult>();
await ctx.run(() => startPayment(order, confirmation.id));
await confirmation.promise.orTimeout({ minutes: 30 });
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/ServiceActions.java#awakeables"} 
// Wait for external payment confirmation
var confirmation = ctx.<PaymentResult>awakeable(PaymentResult.class);
ctx.run("start-payment", () -> startPayment(order, confirmation.id()));
confirmation.await(Duration.ofMinutes(30));
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/service_actions.py#awakeables"} 
# Wait for external payment confirmation
confirmation_id, confirmation_promise = ctx.awakeable()
await ctx.run_typed(
    "start_payment", start_payment, order=order, confirmation_id=confirmation_id
)
await confirmation_promise
```

```go Go {"CODE_LOAD::go/usecases/microservices/serviceactions.go#awakeables"} 
// Wait for external payment confirmation
confirmation := restate.Awakeable[PaymentResult](ctx)
_, err = restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
  return restate.Void{}, StartPayment(order, confirmation.Id())
})
if err != nil {
  return err
}

_, err = confirmation.Result(ctx, 30*time.Minute)
if err != nil {
  return err
}
```
</CodeGroup>

Resolve them from another handler via the SDK or via HTTP.

### Parallel Processing

Execute independent operations concurrently while maintaining durability:

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/service-actions.ts#parallel"} 
// Process all items in parallel
const itemPromises = order.items.map((item) =>
  ctx.run(() => processItem(item))
);

await RestatePromise.all(itemPromises);
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/ServiceActions.java#parallel"} 
// Process all items in parallel
List<DurableFuture<?>> itemFutures = new ArrayList<>();
for (Item item : order.items) {
  itemFutures.add(ctx.runAsync( () -> processItem(item)));
}

DurableFuture.all(itemFutures).await();
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/service_actions.py#parallel"} 
# Process all items in parallel
item_promises = [
    ctx.run_typed(f"process_item_{item['id']}", process_item, item=item)
    for item in order.items
]

await restate.gather(*item_promises)
```

```go Go {"CODE_LOAD::go/usecases/microservices/serviceactions.go#parallel"} 
// Process all items in parallel
var wg sync.WaitGroup
errChan := make(chan error, len(order.Items))

for _, item := range order.Items {
  wg.Add(1)
  go func(item Item) {
    defer wg.Done()
    _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
      return restate.Void{}, ProcessItem(item)
    })
    if err != nil {
      errChan <- err
    }
  }(item)
}

wg.Wait()
close(errChan)

for err := range errChan {
  if err != nil {
    return err
  }
}
```
</CodeGroup>

## When to Choose Restate

**✅ Choose Restate when you need:**

- **Fault-tolerant systems**: Automatic recovery from service failures
- **Reliable microservice communication**: Guaranteed delivery without extra infrastructure
- **Distributed transaction handling**: Implement sagas without complex state machines  
- **Consistent, stateful services**: Stateful objects with a simple concurrency model
- **Workflow orchestration**: Coordinate long-running business processes
- **Event-driven architectures**: Handle webhooks and external events reliably
- **Operational simplicity**: Reduce infrastructure complexity (no need for queues + state stores + schedulers, etc.). A single binary including everything you need.
- **Gradual adoption**: Integrate with existing services incrementally

<Info>
    Evaluating Restate and missing a feature? Contact us on [Discord](https://discord.com/invite/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA).
</Info>

## Comparison with Other Solutions

| Feature | Restate | Traditional Orchestration                         |
|---------|---------|---------------------------------------------------|
| **Infrastructure** | Single binary deployment | Message brokers + workflow engines + state stores             |
| **Service Communication** | Built-in reliable messaging | External message queues required                  |
| **State Management** | Integrated durable state | External state stores + locks                     |
| **Failure Recovery** | Automatic progress recovery | Manual checkpoint/restart logic                   |
| **Deployment Model** | Standard HTTP services | Standard HTTP services                            |
| **Development Experience** | Regular code + IDE support | Regular code + IDE support                        |
| **Observability** | Built-in UI & execution tracing | Manual setup                                      |

## Getting Started

Ready to build resilient microservices with Restate? Here are your next steps:

<CardGroup cols={3}>
  <Card title="Quickstart" icon="rocket" href="/quickstart">
    Run your first Restate service
  </Card>
  <Card title="Hands-on Tutorial" icon="play" href="/tour/microservice-orchestration">
    Learn orchestration patterns with interactive examples
  </Card>
  <Card title="Need help?" icon="thought-bubble">
    Discuss your use case on [Discord](https://discord.gg/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA)
  </Card>
</CardGroup>

## Implementation Guides

Explore specific patterns and best practices:

- **Service Communication**: Reliable RPC and messaging patterns ([TS](/develop/ts/service-communication)/[Python](/develop/python/service-communication)/[Go](/develop/go/service-communication)/[Java/Kotlin](/develop/java/service-communication)/[Rust](https://docs.rs/restate-sdk/latest/restate_sdk/context/trait.ContextClient.html))
- **[Error Handling](/guides/error-handling)**: Retries, timeouts, and saga compensation
- **[Stateful Entities](/foundations/services#virtual-object)**: Virtual Objects and consistency patterns
- **Event Processing**: Webhooks, external events, and awakeables ([TS](/develop/ts/external-events)/[Python](/develop/python/external-events)/[Go](/develop/go/external-events)/[Java/Kotlin](/develop/java/external-events)/[Rust](https://docs.rs/restate-sdk/latest/restate_sdk/context/trait.ContextClient.html))
- **[Saga pattern](/guides/sagas)**: Implement resilient rollback of distributed operations
- **Concurrent tasks**: Execute multiple tasks concurrently and gather results ([TS](/develop/ts/concurrent-tasks)/[Python](/develop/python/concurrent-tasks)/[Go](/develop/go/concurrent-tasks)/[Java/Kotlin](/develop/java/concurrent-tasks)/[Rust](https://docs.rs/restate-sdk/latest/restate_sdk/macro.select.html))