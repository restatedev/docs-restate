---
title: "Microservice Orchestration"
description: "Build resilient, distributed microservices with durable execution, sagas, and reliable service communication."
icon: "circle-nodes"
---

Traditional microservice orchestration requires complex infrastructure: message brokers, workflow engines, state stores, and retry mechanisms. Restate simplifies this by providing **durable execution primitives** that make distributed systems resilient by default, without the operational overhead.

### Durable Execution

Build microservices that automatically recover from failures without losing progress:

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/order-service.ts#here"} 
export const orderService = restate.service({
  name: "OrderService",
  handlers: {
    process: async (ctx: restate.Context, order: Order) => {
      // Each step is automatically durable and resumable
      const paymentId = ctx.rand.uuidv4();

      await ctx.run(() => chargePayment(order.creditCard, paymentId));

      for (const item of order.items) {
        await ctx.run(() => reserveInventory(item.id, item.quantity));
      }
      return { success: true, paymentId };
    },
  },
});
```

```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/OrderService.java#here"} 
@Service
public class OrderService {

  @Handler
  public OrderResult process(Context ctx, Order order) {
    // Each step is automatically durable and resumable
    String paymentId = UUID.randomUUID().toString();

    ctx.run(() -> chargePayment(order.creditCard, paymentId));

    for (var item : order.items) {
      ctx.run(() -> reserveInventory(item.id, item.quantity));
    }

    return new OrderResult(true, paymentId);
  }
}
```

```python Python {"CODE_LOAD::python/src/usecases/microservices/order_service.py#here"} 
order_service = restate.Service("OrderService")


@order_service.handler()
async def process(ctx: restate.Context, order: Order):
    # Each step is automatically durable and resumable
    payment_id = str(uuid.uuid4())

    await ctx.run_typed(
        "charge", charge_payment, credit_card=order.credit_card, payment_id=payment_id
    )

    for item in order.items:
        await ctx.run_typed(
            f"reserve_{item.id}", reserve, item_id=item.id, amount=item.amount
        )

    return {"success": True, "payment_id": payment_id}
```

```go Go {"CODE_LOAD::go/usecases/microservices/orderservice.go#here"} 
type OrderService struct{}

func (OrderService) Process(ctx restate.Context, order Order) (OrderResult, error) {
  // Each step is automatically durable and resumable
  paymentID := restate.Rand(ctx).UUID().String()

  _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
    return ChargePayment(order.CreditCard, paymentID)
  })
  if err != nil {
    return OrderResult{}, err
  }

  for _, item := range order.Items {
    _, err := restate.Run(ctx, func(ctx restate.RunContext) (restate.Void, error) {
      return ReserveInventory(item.ID, item.Quantity)
    })
    if err != nil {
      return OrderResult{}, err
    }
  }

  return OrderResult{Success: true, PaymentID: paymentID}, nil
}
```
</CodeGroup>

**Key Benefits:**
- **Automatic recovery**: Services resume exactly where they left off after failures
- **Zero message loss**: All service communication is durably logged
- **No external dependencies**: Built-in persistence and messaging
- **Standard development**: Write services like regular HTTP APIs

### Resilient Service Communication

Flexible communication patterns with strong delivery guarantees:
- **Exactly-once delivery**: Messages are never lost or duplicated
- **Built-in retries**: Automatic exponential backoff for transient failures  
- **Request deduplication**: Idempotency keys prevent duplicate processing

<Accordion title="Code example">
    <CodeGroup>
        ```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/service-actions.ts#communication"}
        // Request-response: Wait for result
        const result = await ctx.serviceClient(inventoryService).checkStock(item);

        // Fire-and-forget: Guaranteed delivery without waiting
        ctx.serviceSendClient(emailService).sendConfirmation(order);

        // Delayed execution: Schedule for later
        ctx
        .serviceSendClient(reminderService)
        .sendReminder(order, sendOpts({ delay: { days: 7 } }));
        ```

        ```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/ServiceActions.java#communication"}
        // Request-response: Wait for result
        var result = InventoryServiceClient.fromContext(ctx).checkStock(item);

        // Fire-and-forget: Guaranteed delivery without waiting
        EmailServiceClient.fromContext(ctx).send().sendConfirmation(order);

        // Delayed execution: Schedule for later
        ReminderServiceClient.fromContext(ctx).send().sendReminder(order, Duration.ofDays(7));
        ```

        ```python Python {"CODE_LOAD::python/src/usecases/microservices/service_actions.py#communication"}
        # Request-response: Wait for result
        result = await ctx.service_call(check_stock, item)

        # Fire-and-forget: Guaranteed delivery without waiting
        ctx.service_send(send_confirmation_email, order)

        # Delayed execution: Schedule for later
        ctx.service_send(send_reminder, order, send_delay=timedelta(days=7))
        ```

        ```go Go {"CODE_LOAD::go/usecases/microservices/serviceactions.go#communication"}
        // Request-response: Wait for result
        result, err := restate.Service[StockResult](ctx, "InventoryService", "checkStock").Request(item)
        if err != nil {
        return err
    }
        _ = result

        // Fire-and-forget: Guaranteed delivery without waiting
        restate.ServiceSend(ctx, "EmailService", "sendConfirmation").Send(order)

        // Delayed execution: Schedule for later
        restate.ServiceSend(ctx, "ReminderService", "sendReminder").Send(order, restate.WithDelay(7*24*time.Hour))
        ```
    </CodeGroup>

</Accordion>

### State Management

Manage stateful entities without external databases or complex consistency mechanisms:

- **Strict consistency**: Single-writer semantics prevent race conditions
- **Durable persistence**: State survives crashes and deployments
- **Horizontal scaling**: Different entity keys process independently
- **Built-in querying**: Access state via UI and APIs

<Accordion title="Code example">
    <CodeGroup>
        ```typescript TypeScript {"CODE_LOAD::ts/src/usecases/microservices/user-account.ts#here"}
        export default restate.object({
        name: "UserAccount",
        handlers: {
        updateBalance: async (ctx: restate.ObjectContext, amount: number) => {
        const balance = (await ctx.get<number>("balance")) ?? 0;
        const newBalance = balance + amount;

        if (newBalance < 0) {
        throw new TerminalError("Insufficient funds");
    }

        ctx.set("balance", newBalance);
        return newBalance;
    },

        getBalance: shared(async (ctx: restate.ObjectSharedContext) => {
        return (await ctx.get<number>("balance")) ?? 0;
    }),
    },
    });
        ```

        ```java Java {"CODE_LOAD::java/src/main/java/usecases/microservices/UserAccount.java#here"}
        @VirtualObject
        public class UserAccount {
        private static final StateKey<Double> BALANCE = StateKey.of("balance", Double.class);

        @Handler
        public double updateBalance(ObjectContext ctx, double amount) {
        double balance = ctx.get(BALANCE).orElse(0.0);
        double newBalance = balance + amount;

        if (newBalance < 0) {
        throw new TerminalException("Insufficient funds");
    }

        ctx.set(BALANCE, newBalance);
        return newBalance;
    }

        @Shared
        public double getBalance(SharedObjectContext ctx) {
        return ctx.get(BALANCE).orElse(0.0);
    }
    }
        ```

        ```python Python {"CODE_LOAD::python/src/usecases/microservices/user_account.py#here"}
        user_account = restate.VirtualObject("UserAccount")


        @user_account.handler()
        async def update_balance(ctx: restate.ObjectContext, amount: float):
        balance = await ctx.get("balance") or 0.0
        new_balance = balance + amount

        if new_balance < 0.0:
        raise TerminalError("Insufficient funds")

        ctx.set("balance", new_balance)
        return new_balance


        @user_account.handler(kind="shared")
        async def get_balance(ctx: restate.ObjectSharedContext):
        return await ctx.get("balance") or 0.0
        ```

        ```go Go {"CODE_LOAD::go/usecases/microservices/useraccount.go#here"}
        type UserAccount struct{}

        func (UserAccount) UpdateBalance(ctx restate.ObjectContext, amount float64) (float64, error) {
        balance, err := restate.Get[float64](ctx, "balance")
        if err != nil {
        return 0.0, err
    }

        newBalance := balance + amount
        if newBalance < 0.0 {
        return 0.0, restate.TerminalError(errors.New("insufficient funds"))
    }

        restate.Set(ctx, "balance", newBalance)
        return newBalance, nil
    }

        func (UserAccount) GetBalance(ctx restate.ObjectSharedContext) (float64, error) {
        return restate.Get[float64](ctx, "balance")
    }
        ```
    </CodeGroup>

</Accordion>

## Key Orchestration Patterns

<CardGroup cols={3}>
    <Card title="Sagas" icon="backward" href="/guides/sagas">
        Implement resilient rollback logic for non-transient failures.
    </Card>
    <Card title="Event-Driven Coordination" icon="messages" href="/tour/ai-agents#advanced-patterns">
        Wait for external events and webhooks with promises that survive crashes
    </Card>
    <Card title="Parallel Processing" icon="grip-lines" href="/tour/ai-agents#error-handling">
        Execute independent operations concurrently while maintaining durability
    </Card>
</CardGroup>


## When to Choose Restate

**✅ Choose Restate when you need:**

- **Fault-tolerant systems**: Automatic recovery from service failures
- **Reliable microservice communication**: Guaranteed delivery without extra infrastructure
- **Distributed transaction handling**: Implement sagas without complex state machines  
- **Consistent, stateful services**: Stateful objects with a simple concurrency model
- **Workflow orchestration**: Coordinate long-running business processes
- **Event-driven architectures**: Handle webhooks and external events reliably
- **Operational simplicity**: Reduce infrastructure complexity (no need for queues + state stores + schedulers, etc.). A single binary including everything you need.
- **Gradual adoption**: Integrate with existing services incrementally

<Info>
    Evaluating Restate and missing a feature? Contact us on [Discord](https://discord.com/invite/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA).
</Info>

## Comparison with Other Solutions

| Feature | Restate | Traditional Orchestration                         |
|---------|---------|---------------------------------------------------|
| **Infrastructure** | Single binary deployment | Message brokers + workflow engines + state stores             |
| **Service Communication** | Built-in reliable messaging | External message queues required                  |
| **State Management** | Integrated durable state | External state stores + locks                     |
| **Failure Recovery** | Automatic progress recovery | Manual checkpoint/restart logic                   |
| **Deployment Model** | Standard HTTP services | Standard HTTP services                            |
| **Development Experience** | Regular code + IDE support | Regular code + IDE support                        |
| **Observability** | Built-in UI & execution tracing | Manual setup                                      |

## Getting Started

Ready to build resilient microservices with Restate? Here are your next steps:

<CardGroup cols={3}>
  <Card title="Quickstart" icon="rocket" href="/quickstart">
    Run your first Restate service
  </Card>
  <Card title="Hands-on Tutorial" icon="play" href="/tour/microservice-orchestration">
    Learn orchestration patterns with interactive examples
  </Card>
  <Card title="Need help?" icon="thought-bubble">
    Discuss your use case on [Discord](https://discord.gg/skW3AZ6uGd) or [Slack](https://join.slack.com/t/restatecommunity/shared_invite/zt-2v9gl005c-WBpr167o5XJZI1l7HWKImA)
  </Card>
</CardGroup>

## Implementation Guides

Explore specific patterns and best practices:

- **Service Communication**: Reliable RPC and messaging patterns ([TS](/develop/ts/service-communication)/[Python](/develop/python/service-communication)/[Go](/develop/go/service-communication)/[Java/Kotlin](/develop/java/service-communication)/[Rust](https://docs.rs/restate-sdk/latest/restate_sdk/context/trait.ContextClient.html))
- **[Error Handling](/guides/error-handling)**: Retries, timeouts, and saga compensation
- **[Stateful Entities](/foundations/services#virtual-object)**: Virtual Objects and consistency patterns
- **Event Processing**: Webhooks, external events, and awakeables ([TS](/develop/ts/external-events)/[Python](/develop/python/external-events)/[Go](/develop/go/external-events)/[Java/Kotlin](/develop/java/external-events)/[Rust](https://docs.rs/restate-sdk/latest/restate_sdk/context/trait.ContextClient.html))
- **[Saga pattern](/guides/sagas)**: Implement resilient rollback of distributed operations
- **Concurrent tasks**: Execute multiple tasks concurrently and gather results ([TS](/develop/ts/concurrent-tasks)/[Python](/develop/python/concurrent-tasks)/[Go](/develop/go/concurrent-tasks)/[Java/Kotlin](/develop/java/concurrent-tasks)/[Rust](https://docs.rs/restate-sdk/latest/restate_sdk/macro.select.html))