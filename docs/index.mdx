---
title: "Overview"
description: "Build reliable apps that handle failures automatically"
icon: "book-open"
---

Restate provides durable building blocks that makes building resilient applications simple. Write normal code while Restate handles failures, coordination, and state consistency automatically.

## Why Restate?

Building reliable distributed systems is hard.
Systems can fail in so many ways: infrastructure failures, network partitions, timeouts, race conditions, corrupted state, etc. Traditional approaches require extensive error handling, state management, and retry logic scattered throughout your codebase.

Restate eliminates this complexity.

## What is Restate?

Restate is a system that makes your applications durable, reliable, and stateful. It turns regular functions into fault-tolerant building blocks that can survive failures, restarts, and infrastructure issues without losing progress or duplicating work.

Instead of building complex retry logic, state management, and coordination mechanisms, you write straightforward business logic. Restate handles all the reliability concerns behind the scenes.

## Key capabilities

**Durable execution**: Functions automatically retry and resume from exactly where they left off after failures, without re-executing completed work.

**Built-in K/V state**: Store and retrieve data directly in your functions without external databases, with strong consistency guarantees.

**Reliable communication**: Call functions across services with automatic retries, exactly-once delivery, and durable execution.

**Time-based coordination**: Sleep, schedule, and wait for external events with durable timers that survive restarts.

**Workflows**: Coordinate long-running processes, human approvals, and external system integrations with ease.

## How it works

Restate tracks every operation your functions perform in a durable log. When failures occur, functions resume using this log to skip already-completed work and continue from the exact failure point.

<CodeGroup>
```typescript TypeScript
    export const processOrder = async (ctx: Context, order: Order) => {
    // This validation runs once, even on retry
    const validation = await ctx.run("validate", () => validateOrder(order));

    // This call happens once, even on retry
    const payment = await ctx.serviceCall(PaymentService).charge(order.total);

    // This completes the order
    return { orderId: order.id, paymentId: payment.id };
};
```

```java Java
@Handler
public OrderResult processOrder(Context ctx, Order order) {
    // This validation runs once, even on retry
    ValidationResult validation = ctx.run("validate", () -> validateOrder(order));

    // This call happens once, even on retry
    PaymentResult payment = PaymentServiceClient.fromContext(ctx)
    .charge(order.getTotal()).await();

    // This completes the order
    return new OrderResult(order.getId(), payment.getId());
}
```

```python Python
@order_service.handler()
async def process_order(ctx: Context, order: Order):
    # This validation runs once, even on retry
    validation = await ctx.run("validate", lambda: validate_order(order))

    # This call happens once, even on retry
    payment = await PaymentServiceClient.from_context(ctx).charge(order.total)

    # This completes the order
    return {"order_id": order.id, "payment_id": payment.id}
```
</CodeGroup>

If the payment service call fails, Restate automatically retries the function but skips the validation step since it already completed successfully.

## Service types

Restate supports three types of services, each optimized for different use cases:

**[Basic Services](/build/services/basic-service)**: Stateless functions that process requests independently. Perfect for data processing, validation, and external API calls.

**[Virtual Objects](/build/services/virtual-object)**: Stateful functions with isolated storage per object instance and single-writer semantics. Ideal for user accounts, shopping carts, and entity management.

**[Workflows](/build/services/workflow)**: Long-running coordination processes that can wait for external events and human input. Great for approval processes, multi-step operations, and complex business logic.

## Common use cases

**Microservice orchestration**: Coordinate calls across multiple services with automatic retries and failure handling.

**Workflow automation**: Build approval processes, multi-step operations, and business workflows that survive failures.

**AI agent coordination**: Manage stateful AI agents with reliable tool usage and long-running conversations.

**Payment processing**: Handle complex payment flows with automatic retries and consistency guarantees.

**User onboarding**: Create multi-step onboarding sequences with delays, notifications, and conditional logic.

**Event processing**: Process events with exactly-once guarantees and automatic retry handling.

## Getting started

1. **[Quickstart](/get-started/quickstart)**: Build your first Restate service in minutes
2. **[Concepts](/get-started/concepts)**: Understand core Restate concepts and terminology
3. **[Architecture](/architecture)**: Learn how Restate works under the hood
4. **[Use Cases](/use-cases/payment-processing)**: Explore real-world examples and patterns

Restate transforms distributed system complexity into simple, reliable code that just works.