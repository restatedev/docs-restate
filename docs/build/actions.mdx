---
title: "Actions"
description: "A comprehensive guide to all actions and capabilities available through the Restate context."
---

The Restate context (`ctx`) provides a rich set of actions for building resilient applications. This guide covers all the key capabilities you can use to develop your applications.

## State Management

### **ctx.set(key, value)**
Store data in the service's durable state:

```ts
// Store simple values
await ctx.set("userId", "user123");
await ctx.set("orderStatus", "processing");

// Store complex objects
await ctx.set("orderDetails", {
  id: "order456",
  items: ["item1", "item2"],
  total: 99.99
});

// Store arrays
await ctx.set("orderHistory", [
  { id: "order1", amount: 50 },
  { id: "order2", amount: 75 }
]);
```

### **ctx.get(key)**
Retrieve data from durable state:

```ts
// Get simple values
const userId = await ctx.get("userId");
const status = await ctx.get("orderStatus");

// Get complex objects
const orderDetails = await ctx.get("orderDetails");
const orderHistory = await ctx.get("orderHistory") || [];

// Type-safe retrieval
const user: User | null = await ctx.get("user");
```

### **ctx.del(key)**
Remove data from durable state:

```ts
// Delete specific keys
await ctx.del("temporaryData");
await ctx.del("sessionToken");

// Clean up after processing
await ctx.del("order_123");
await ctx.del("payment_123");
```

## Service Communication

### **ctx.call(service, method, input)**
Invoke other services synchronously:

```ts
// Call other Restate services
const paymentResult = await ctx.call(paymentService.process, {
  amount: 100,
  currency: "USD"
});

const inventoryResult = await ctx.call(inventoryService.reserve, {
  items: ["item1", "item2"],
  orderId: "order123"
});

// Call with complex inputs
const enrichedData = await ctx.call(customerService.enrich, {
  customerId: "cust123",
  profile: customerProfile,
  preferences: userPreferences
});
```

### **ctx.run(service, method, input)**
Invoke other services asynchronously (fire-and-forget):

```ts
// Fire-and-forget notifications
await ctx.run(notificationService.sendEmail, {
  to: "user@example.com",
  subject: "Order Confirmed",
  template: "order-confirmation"
});

// Background processing
await ctx.run(analyticsService.track, {
  event: "purchase_completed",
  userId: "user123",
  data: purchaseData
});
```

## Time and Scheduling

### **ctx.sleep(duration)**
Pause execution for a specified duration:

```ts
// Sleep for specific time periods
await ctx.sleep({ seconds: 30 });
await ctx.sleep({ minutes: 5 });
await ctx.sleep({ hours: 2 });
await ctx.sleep({ days: 1 });

// Wait before retrying
await ctx.sleep({ milliseconds: 1000 });

// Exponential backoff
const delay = Math.pow(2, retryCount) * 1000;
await ctx.sleep({ milliseconds: delay });
```

### **ctx.awakeable&lt;T&gt;(id)**
Wait for external events or signals:

```ts
// Wait for external confirmation
const confirmation = await ctx.awakeable<string>("order-confirmation");

// Wait for user approval
const approval = await ctx.awakeable<ApprovalData>("user-approval");

// Wait for payment confirmation
const paymentResult = await ctx.awakeable<PaymentResult>("payment-confirmation");

// Type-safe awakeables
interface OrderConfirmation {
  orderId: string;
  status: "approved" | "rejected";
  reason?: string;
}

const confirmation: OrderConfirmation = await ctx.awakeable<OrderConfirmation>("order-confirmation");
```

## Error Handling and Control Flow

### **ctx.retry(promise, options?)**
Retry operations with configurable policies:

```ts
// Simple retry
const result = await ctx.retry(
  externalApi.call(),
  { maxRetries: 3 }
);

// Retry with custom delay
const result = await ctx.retry(
  paymentService.process(payment),
  {
    maxRetries: 5,
    delay: { seconds: 2 }
  }
);

// Retry with exponential backoff
const result = await ctx.retry(
  inventoryService.reserve(items),
  {
    maxRetries: 3,
    backoff: "exponential"
  }
);
```

### **ctx.oneWayCall(service, method, input)**
Make one-way calls that don't return results:

```ts
// Send notifications without waiting
await ctx.oneWayCall(notificationService.sendSMS, {
  phone: "+1234567890",
  message: "Your order is ready!"
});

// Log events
await ctx.oneWayCall(loggingService.log, {
  level: "info",
  message: "Order processed successfully",
  orderId: "order123"
});
```

## Data Processing and Transformation

### **ctx.map(array, callback)**
Process arrays with automatic checkpointing:

```ts
// Process items in parallel
const results = await ctx.map(orderItems, async (item) => {
  return await ctx.call(inventoryService.checkAvailability, item);
});

// Transform data
const transformedData = await ctx.map(rawData, async (item) => {
  return {
    id: item.id,
    processed: true,
    timestamp: new Date().toISOString()
  };
});
```

### **ctx.forEach(array, callback)**
Execute side effects for each array element:

```ts
// Send notifications to multiple users
await ctx.forEach(users, async (user) => {
  await ctx.run(notificationService.sendEmail, {
    to: user.email,
    subject: "System Update",
    template: "system-notification"
  });
});

// Process items sequentially
await ctx.forEach(items, async (item) => {
  await ctx.call(processorService.process, item);
});
```

## Advanced Patterns

### **Conditional Execution**
```ts
// Conditional service calls
if (order.amount > 1000) {
  await ctx.call(approvalService.requireApproval, order);
}

// Conditional state updates
const status = await ctx.get("status");
if (status === "pending") {
  await ctx.set("status", "processing");
  await ctx.call(processorService.start, order);
}
```

### **State Machines**
```js
// Implement state machines
const currentState = await ctx.get("state") || "initial";

switch (currentState) {
  case "initial":
    await ctx.set("state", "processing");
    await ctx.call(processorService.start, data);
    break;
    
  case "processing":
    const result = await ctx.call(processorService.check, data);
    if (result.complete) {
      await ctx.set("state", "completed");
      await ctx.call(notificationService.notify, result);
    }
    break;
    
  case "completed":
    // Final state, no further actions
    break;
}
```

### **Saga Pattern**
```js
// Implement saga pattern with compensation
try {
  // Step 1: Reserve inventory
  await ctx.call(inventoryService.reserve, { items: order.items });
  
  // Step 2: Process payment
  await ctx.call(paymentService.process, { amount: order.total });
  
  // Step 3: Confirm order
  await ctx.call(orderService.confirm, { orderId: order.id });
  
} catch (error) {
  // Compensation: Release inventory
  await ctx.call(inventoryService.release, { orderId: order.id });
  
  // Compensation: Refund payment
  await ctx.call(paymentService.refund, { orderId: order.id });
  
  throw error;
}
```

### **Event Sourcing**
```js
// Record events in state
const events = await ctx.get("events") || [];
events.push({
  type: "order_created",
  timestamp: new Date().toISOString(),
  data: order
});
await ctx.set("events", events);

// Rebuild state from events
const events = await ctx.get("events") || [];
const orderState = events.reduce((state, event) => {
  switch (event.type) {
    case "order_created":
      return { ...state, status: "created", ...event.data };
    case "payment_processed":
      return { ...state, status: "paid", paymentId: event.data.paymentId };
    case "shipped":
      return { ...state, status: "shipped", trackingId: event.data.trackingId };
    default:
      return state;
  }
}, {});
```

## Best Practices

### **State Management**
- Use descriptive key names for state
- Clean up temporary state when no longer needed
- Consider state size and retention policies
- Use state for correlation, not as a primary database

### **Service Communication**
- Use `ctx.call` for synchronous operations that need results
- Use `ctx.run` for fire-and-forget operations
- Use `ctx.oneWayCall` for logging and notifications
- Handle errors appropriately in service calls

### **Error Handling**
- Use `ctx.retry` for transient failures
- Implement proper compensation logic
- Log errors for debugging
- Use appropriate retry policies

### **Performance**
- Batch operations when possible
- Use appropriate timeouts for external calls
- Monitor execution times and optimize slow operations
- Consider using `ctx.run` for non-critical operations

## Next Steps

- Learn about [state management](/develop/ts/state) for advanced patterns
- Explore [error handling](/develop/ts/error-handling) for robust applications
- See [service communication](/develop/ts/service-communication) for microservice integration
- Understand [awakeables](/develop/ts/awakeables) for external event integration