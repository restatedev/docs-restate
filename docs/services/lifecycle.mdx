---
title: "Lifecycle"
description: "Lifecycle of a Restate invocation"
icon: "arrows-spin"
---

When you send a request to a service, Restate initializes an entity called _Invocation_ with its own unique ID and lifecycle.

You can list invocations, introspect their status and progress, execute operations on them such as cancel/kill.

{/* Image of UI invocations page with few invocations in different statuses */}

## Invocation ID

_Invocations_ have a unique **Invocation ID** starting with `inv_`. You can find this ID in every place where an invocation is mentioned:

- The [Restate UI](/installation#restate-ui) _Invocations_ page
- Logs and traces (`restate.invocation.id`), both in Restate and SDKs
- In CLI commands such as `restate invocation ls`

## Invocation Lifecycle

Invocations follow a well-defined lifecycle:

<img src="/img/invocation_lifecycle.png" alt="Invocation lifecycle" />

{/* this is roughy the graph nik should create here */}

{/*
@startuml

Scheduled: Waiting delay timer
Pending: Enqueued in Virtual Object
Running: Invocation is executing making progress
Paused: Invocation is waiting to be manually resumed after too many retries
BackingOff: Attempt failed, waiting to retry
Suspended: Invocation is waiting for events to resume
Completed: Invocation completed (succeeded or failed), retained for observability
'Maybe split Completed in Failed and succeeded, as this is how it shows in UI?
'From any invocation you can cancel/kill. Shall we add this to the graph or it overloads it?

[*] --> Scheduled: Delayed request
Scheduled --> Pending
Scheduled --> Running

[*] --> Pending: Virtual object request
Pending --> Running

[*] --> Running

Running --> BackingOff: Transient failure
Running --> Paused: Retries exhausted
BackingOff --> Running: Retry timer fired
BackingOff --> Running: Manually resumed

Running --> Suspended: No progress can be made
Suspended --> Running: Received a new event

Paused --> Running: Manually resumed

Running --> Completed
Running --> [*]: If journal/idempotency retention disabled

Completed --> [*]: Retention timer expired
Completed --> [*]: Manually purged

@enduml
*/}

## Cancel

At any point in time during the lifecycle, you can cancel an invocation. Cancellation:

- Frees held resources
- Cooperates with your handler code to roll back any changes made so far
- Allows proper cleanup

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations cancel inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk cancel, e.g. per service
    restate invocations cancel Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/cancel
    ```
</CodeGroup>

Cancellation is non-blocking. The API call may return before cancellation completes. In rare cases, cancellation may not take effect - retry the operation if needed.

<Info>
    For proper rollback, handlers must include compensation logic to maintain service state consistency. Check the [sagas guide](/guides/sagas).
</Info>

<Accordion title="How Cancellation Works">

    When an invocation is canceled, Restate propagates the cancellation recursively through the call graph:

    1. **Propagate to leaves**: Cancellation first reaches the leaves of the call graph. Restate interrupts any ongoing sleeps, awakeables, or other context actions at those points.
    2. **Throw terminal error**: At the cancellation point, Restate throws a terminal error, signaling that normal execution cannot continue.
    3. **Run compensation**: The handler runs its defined compensation logic to undo or mitigate side effects.
    4. **Propagate upward**: The cancellation response then flows back up the call graph, ensuring that each parent invocation also executes its compensation logic if defined.

</Accordion>

## Kill

Use kill when cancellation fails (e.g., when endpoints are permanently unavailable).

Killing immediately stops all calls in the invocation tree **without executing compensation logic**. This may leave your service in an inconsistent state. Only use as a last resort after trying other fixes.

Note that one-way calls and delayed calls are not killed because they're detached from the originating call tree.

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations kill inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk kill, e.g. per service
    restate invocations kill Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/kill
    ```
</CodeGroup>

## Resume / Retry now

If an invocation retries for too many times, Restate will _Pause_ it.

When an invocation is paused, you need to resume it manually:

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations resume inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk resume, e.g. per service
    restate invocations resume Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/resume
    ```
</CodeGroup>

Check out the [service configuration docs](/services/configuration) to tune the invocation retry policy,
including the retry interval and how many attempts to perform before pausing.

<Accordion title="Resuming on a different deployment">
    When resuming, the invocation will run on the same deployment where it started.

    If the invocation failed due to some bug you fixed on a new/different deployment,
    you can override on which deployment the invocation should be resumed:

    <CodeGroup>
        {/* TODO add UI example */}
        ```shell curl
        curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/resume\?deployment=dp_17sztQp4gnEC1L0OCFM9aEh
        ```
    </CodeGroup>

    Be aware that if the business logic/flow between the old and the new deployment code differ, once resumed the invocation will start fail with **non-determinism errors**!
</Accordion>

## Purge

After an invocation completes, it will be retained by Restate for some time, in order to introspect it and, in case of idempotent requests, to perform deduplication.

Check out the [service configuration docs](/services/configuration) to tune the retention time.

You can also manually purge completed invocations if you need to free up disk space:

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations purge inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk purge, e.g. per service
    restate invocations purge Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/purge
    ```
</CodeGroup>

## Restart as new

Invocations, once completed, can be **restarted as new invocations**:

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations restart-as-new inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk restart as new, e.g. per service
    restate invocations restart-as-new Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/restart-as-new
    ```
</CodeGroup>

The new invocation will have a different invocation ID, but the input and headers of the original request.
The old invocation will be left untouched.

Keep in mind that when restarting an invocation as new, no partial progress will be kept, meaning all the operations the service executed will be executed again.
