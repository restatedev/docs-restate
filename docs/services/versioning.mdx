---
title: "Versioning"
description: "Understand deployments, registration, and versioning in Restate."
icon: "send-backward"
---

For durable execution to work correctly, Restate must know exactly which version of your code to use for each request. This requires understanding three key concepts: **deployments**, **registration**, and **versioning**.

## What is a Deployment?

A deployment in Restate is a specific, versioned instance of your service code—whether running as an HTTP endpoint, a Lambda function, or another supported environment.

Each deployment is immutable: once registered, its code and endpoint must not change.

An invocation is bound to a specific deployment — it starts and completes within that same deployment. This ensures that in-flight requests always see the code they started with, preserving correctness and determinism.

## Registering a Deployment

After deploying your service, you must register it with Restate so it can be discovered and invoked.

**You can register a deployment using:**
- The [Restate UI](/installation#restate-ui) (recommended for most users)
- The CLI:
  ```bash
  restate deployments register http://localhost:9080
  ```
- The Admin API:
  ```bash
  curl localhost:9070/deployments --json '{"uri": "http://localhost:9080"}'
  ```

**Note:**
 - For AWS Lambda, use the function ARN instead of a URL (e.g., `arn:aws:lambda:region:account-id:function:function-name:version`).
 - If running Restate in Docker, use `host.docker.internal` instead of `localhost`.

### Deployments supporting only HTTP1.1
Some deployments only support HTTP/1.1, and not HTTP/2.
This means Restate cannot use bidirectional streaming of journal entries and needs to communicate with the service in request-response mode ([learn more](/guides/request-lifecycle#request-response-deployment-targets)).

To register such deployments, you need to specify using HTTP/1.1 during registration:
<CodeGroup>
```shell CLI
restate deployments register http://localhost:9080 --use-http1.1
```
```bash curl
curl localhost:9070/deployments --json '{"uri": "http://localhost:9080", "use_http_11": true}'
```
</CodeGroup>

When registering deployments via the UI, you can select the HTTP/1.1 checkbox.


## Deploying new service versions

Since deployments are immutable, updates require creating new deployments:

<Steps>
    <Step title="Deploy new version">
        Deploy your updated service code to a new endpoint (e.g., `http://greeter-v2/`).
    </Step>
    <Step title="Register the new deployment">
        Then register it with Restate:
        <CodeGroup>
        ```shell CLI
        restate deployments register http://greeter-v2/
        ```
        ```shell curl
        curl localhost:9070/deployments --json '{"uri": "http://greeter-v2/"}'
        ```
        </CodeGroup>
        Restate automatically routes new requests to the latest deployment. Existing requests continue on the original deployment.
    </Step>
    <Step title="Wait for old deployment to drain">
        Ensure the old deployment remains available until all in-flight invocations complete.

        Check for in-flight invocations on this deployment [via the UI](https://restate.dev/blog/announcing-restate-ui/#an-aid-for-versioning) or CLI.

        ```shell CLI
        # Find the deployment ID of your service
        restate services list
        # Then, check the number of active invocations for the deployment
        restate deployments list
        # Or check the deployment details
        restate deployment describe <deployment_id>
        ```
    </Step>
    <Step title="Remove old deployment">
        Once all invocations are complete, you can safely remove the old deployment.
        Use the CLI or UI to remove it.
        <CodeGroup>
            ```shell CLI
            restate deployments remove dp_14LsPzGz9HBxXIeBoH5wYUh
            ```
            ```bash curl
            curl -X DELETE localhost:9070/deployments/dp_14LsPzGz9HBxXIeBoH5wYUh
            ```
        </CodeGroup>
        If the deployment isn't drained yet, but you still want to remove it, use the `--force` flag in CLI, or `?force=true` for curl.
    </Step>
</Steps>


<Note title="State compatibility">
    Virtual Object state persists across versions. Ensure your state schema remains backward compatible.
</Note>

## Removing a service

Restate does not support removing individual services directly. Instead, you must remove the deployment that contains the service.

To do this safely, follow the steps below:

1. Ensure no other handlers or services have business logic that calls the service you're removing.
2. If several services are bundled in the same deployment, you can't remove only one of them. You have to remove the whole deployment.
So make sure that you first deploy the services you want to keep in a separate new deployment.
4. [Make the service private](/services/security#private-services) to avoid accepting new HTTP requests.
5. Check whether the service has pending invocations by filtering the invocations on deployment ID in the [UI](/installation#restate-ui) or via `restate services status`, and wait until the service is drained (i.e. no ongoing invocations).

**When all prerequisites are fulfilled**, you can remove the deployment containing the service via the [UI](/installation#restate-ui) or via:

<CodeGroup>
    ```shell CLI
    restate deployments remove dp_14LsPzGz9HBxXIeBoH5wYUh
    ```
    ```bash curl
    curl -X DELETE localhost:9070/deployments/dp_14LsPzGz9HBxXIeBoH5wYUh
    ```
</CodeGroup>
If the deployment isn't drained yet but you still want to remove it, use the `--force` flag in CLI, or `?force=true` for curl.


## Advanced: Updating deployments in-place

While deployments should be immutable, critical bugs sometimes require updating deployed code to fix stuck invocations.

### When This is Needed
If a bug (like a null pointer exception) occurs mid-execution, registering a new deployment only fixes new invocations. Existing stuck invocations need the original deployment fixed.

### Two Approaches

1. **Update underlying code** at the same URI (works for K8s, not Lambda)
2. **Update deployment endpoint** to point to a patched version:
   ```shell
   curl -X PUT localhost:9070/deployments/dp_14LsPzGz9HBxXIeBoH5wYUh \
     --json '{"uri": "http://greeter-patched/"}'
   ```

### Common Scenarios

<AccordionGroup>
<Accordion title="Scenario 1: Invocations failing on the active deployment">

The current deployment handling new invocations has bugs:

1. Develop a fix, based on the current deployed version, that resolves the failing invocations.
Care should be taken to ensure that the new version has the same behaviour as the old version, for any code paths that in-flight invocations have successfully completed (ie, any changes must be from the point of failure onwards).
2. By updating the underlying code or with the update deployment API, change the active deployment to include the fix. Verify that this resolves the issue both for new invocations, and for those already failing.

</Accordion>
<Accordion title="Scenario 2: Failing invocations on a previous (draining) deployment">

It's common to notice failing invocations because they are preventing an old deployment from fully draining. In this case there are several concerns; the failing invocations on deployment 1, any failing invocations on deployment 2,
and the potential for new failing invocations to occur on deployment 2 as well. The following steps should be taken:
1. Develop a fix as above, based on the version backing deployment 1.
2. By updating the underlying code or with the update deployment API, change deployment 1 to include the fix. Verify that this resolves the failing invocations on this deployment.
3. Rebase the fix onto the version backing deployment 2.
4. By updating the underlying code or with the update deployment API, change deployment 2 to include the fix. Verify that this resolves any failing invocations, if any, new invocations.

<Info title={"Updating a deployment to use a conflicting endpoint"}>
    It is possible to use the update deployment API to give a deployment the same URI/ARN as another deployment. This is useful where the an appropriate fix for a drained deployment has already been registered as a new deployment.
    If this is done, there will be two deployments with the same endpoint, which is otherwise not allowed. It is strongly recommended that you delete one of the two deployments when the failing invocations have been resolved.
</Info>
</Accordion>
</AccordionGroup>

## See also

- [Solving durable execution’s immutability problem](https://restate.dev/blog/solving-durable-executions-immutability-problem/)
- [Code that sleeps for a month](https://restate.dev/blog/code-that-sleeps-for-a-month/)
- [Announcing Restate UI](https://restate.dev/blog/announcing-restate-ui/)
