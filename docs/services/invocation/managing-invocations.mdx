---
title: "Managing Invocations"
sidebarTitle: "Managing Invocations"
description: "Understand the lifecycle of a Restate invocation and how to manage it."
---
An invocation is a request to execute a handler. Each invocation has its own unique ID and lifecycle.


<Frame>
    <img src="/img/tour/agents/exclusive-handlers.png" alt="Conversation State Management" />
</Frame>

## Invocation ID

_Invocations_ have a unique **Invocation ID** starting with `inv_`. You can find this ID in every place where an invocation is mentioned:

- The invocations page of the [Restate UI](/installation#restate-ui)
- Logs and traces (`restate.invocation.id`), both in Restate and SDKs
- In CLI commands such as `restate invocation ls`

## Lifecycle
Invocations follow a well-defined lifecycle:

<img src="/img/services/invocation/invocation_lifecycle.png" alt="Invocation lifecycle" />

This page describes how to manage invocations in different states.

## Cancel

You can cancel an invocation at any point in its lifecycle. 

Cancellation has the following characteristics:

- Frees held resources
- Cooperates with your handler code to roll back any changes made so far
- Allows proper cleanup

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations cancel inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk cancel, e.g. per service or handler
    restate invocations cancel Greeter
    restate invocations cancel Greeter/greet
    restate invocations cancel CartObject/cart55/add
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/cancel
    ```
</CodeGroup>

Cancellation is non-blocking. The API call may return before cancellation completes. In rare cases, cancellation may not take effect - retry the operation if needed.

<Info>
    For proper rollback, handlers must include compensation logic to maintain service state consistency. Check the [sagas guide](/guides/sagas).
</Info>

<Accordion title="How Cancellation Works">

    ### Requirements

    For cancellation to work, the invocation must reach the deployment (the service endpoint must be reachable).

    If the deployment is not reachable, cancellation will not work. In this case, use [kill](#kill) instead.

    ### Cancellation Flow

    When an invocation is canceled:

    1. **User sends cancellation request** to the Restate runtime
    2. **Runtime forwards cancellation** to the SDK eagerly
    3. **SDK surfaces cancellation** at the next await point in your handler code

    The cancellation exception (`TerminalError` in TypeScript/Python, `TerminalException` in Java/Kotlin) is thrown at the next **await point** - operations that wait for a result:
    - `ctx.run()` / `ctx.runAsync().await()`
    - Service calls (`ctx.serviceClient(...).call()`)
    - `ctx.sleep()`
    - `ctx.awakeable()` resolution
    - Promise combinators (e.g., `Promise.all()`)

    Operations that are **not** await points will continue to execute and ignore cancellation:
    - `ctx.set()` / `ctx.get()`
    - `ctx.send()` (one-way calls)
    - `ctx.sendDelayed()` (delayed calls)
    - `ctx.uuid()`
    - Other non-blocking context operations

    <Note>
        One-way calls (`ctx.send()`) and delayed calls (`ctx.sendDelayed()`) are detached from the call tree. They will be scheduled and execute fully even if the originating invocation is cancelled.
    </Note>

    ### Example

    ```typescript
    async function processOrder(ctx: Context, order: Order) {
      // This executes - not an await point
      ctx.set("status", "processing");
      
      try {
        // If cancelled before this await, ctx.run won't execute
        // If cancelled during execution, exception thrown here
        const payment = await ctx.run(() => processPayment(order));
        
        // These one-way calls execute even if cancellation happens after
        ctx.send(notificationService).notify(order.userId, "Payment processed");
        
        // If cancelled, exception thrown at this await point
        await ctx.run(() => shipOrder(order));
        
      } catch (error) {
        if (error instanceof TerminalError) {
          // Cancellation detected - run compensation
          await ctx.run(() => refundPayment(order));
          throw error; // Re-throw to propagate cancellation
        }
      }
    }
    ```

    ### Call Graph Propagation

    Cancellation propagates recursively through the call graph:

    1. **Propagate to leaves**: Cancellation first reaches the leaves of the call graph
    2. **Throw at await points**: Each handler receives the cancellation exception at its next await point
    3. **Run compensation**: Handlers execute their compensation logic (if defined)
    4. **Propagate upward**: Cancellation flows back up the call graph, allowing each parent to compensate

</Accordion>

## Kill

Use kill when cancellation fails (e.g., when endpoints are permanently unavailable).

Killing immediately stops all calls in the invocation tree **without executing compensation logic**. This may leave your service in an inconsistent state. Only use as a last resort after trying other fixes.

Note that one-way calls and delayed calls are not killed because they're detached from the originating call tree.

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations kill inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk kill, e.g. per service
    restate invocations kill Greeter
    restate invocations kill Greeter/greet
    restate invocations kill CartObject/cart55/add
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/kill
    ```
</CodeGroup>

## Resume

If an invocation retries for too many times, Restate will pause it.

When an invocation is paused, you need to resume it manually:

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations resume inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk resume, e.g. per service
    restate invocations resume Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/resume
    ```
</CodeGroup>

Check out the [service configuration docs](/services/configuration#retries) to tune the invocation retry policy,
including the retry interval and how many attempts to perform before pausing.

You can also resume an invocation that is waiting on a retry timer, instructing Restate to retry immediately.

<Accordion title="Resuming on a different deployment">
    When resuming, the invocation will run on the same deployment where it started.

    If the invocation failed due to some bug you fixed on a new/different deployment,
    you can override on which deployment the invocation should be resumed:

    <CodeGroup>
        {/* TODO add UI example */}
        ```shell curl
        curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/resume\?deployment=dp_17sztQp4gnEC1L0OCFM9aEh
        ```
    </CodeGroup>

    Be aware that if the business logic/flow between the old and the new deployment code differ, once resumed the invocation will start fail with **non-determinism errors**!
</Accordion>

## Purge

After an invocation completes, it will be retained by Restate for some time, in order to introspect it and, in case of idempotent requests, to perform deduplication.

Check out the [service configuration docs](/services/configuration#retention-of-completed-invocations) to tune the retention time.

You can also manually purge completed invocations if you need to free up disk space:

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations purge inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk purge, e.g. per service
    restate invocations purge Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/purge
    ```
</CodeGroup>

## Restart as new

Invocations, once completed, can be **restarted as new invocations**:

<CodeGroup>
    {/* TODO add UI example */}
    ```shell CLI
    restate invocations restart-as-new inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz

    # Or bulk restart as new, e.g. per service
    restate invocations restart-as-new Greeter
    ```
    ```shell curl
    curl -X PATCH http://localhost:9070/invocations/inv_1gdJBtdVEcM942bjcDmb1c1khoaJe11Hbz/restart-as-new
    ```
</CodeGroup>

The new invocation will have a different invocation ID, but the input and headers of the original request.
The old invocation will be left untouched.

Keep in mind that when restarting an invocation as new, no partial progress will be kept, meaning all the operations the service executed will be executed again.

This feature is not available for workflows.