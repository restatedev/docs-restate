---
title: Actions
description: Essential context actions for building reliable functions
icon: "gear"
---

Context actions are methods available on the Restate Context object (`ctx`) that provide Restate's core capabilities.
These actions enable durable execution, state management, service communication, and timing control.

### Durable steps

Use `ctx.run` to safely wrap any non-deterministic operation, like HTTP calls or database responses, and have Restate persist its result.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#durable_steps"} 
// External API call
const apiResult = await ctx.run("fetch-data", async () => {
  const response = await fetch("https://api.example.com/data");
  return response.json();
});

// Database operation
const dbResult = await ctx.run("update-user", () => {
  return updateUserDatabase(userId, { name: "John" });
});

// Idempotency key generation
const id = ctx.rand.uuidv4();
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#durable_steps"} 
# External API call
api_result = await ctx.run_typed(
    "fetch-data", fetch_url, url="https://api.example.com/data"
)

# Database operation
db_result = await ctx.run_typed(
    "update-user", update_user_database, id=user_id, data={"name": "John"}
)

# Idempotency key generation
id = ctx.uuid()
```

</CodeGroup>

Without `ctx.run()`, these operations would produce different results during replay, breaking deterministic recovery.

## State management

Available in Virtual Object and Workflow functions for persistent key-value storage.

### Get

Retrieve stored state by key.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#state_get"} 
// Get with type and default value
const profile = await ctx.get<UserProfile>("profile");
const count = (await ctx.get<number>("count")) ?? 0;
const cart = (await ctx.get<ShoppingCart>("cart")) ?? [];
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#state_get"} 
# Get with type and default value
profile = await ctx.get("profile", type_hint=UserProfile)
count = await ctx.get("count", type_hint=int) or 0
cart = await ctx.get("cart", type_hint=ShoppingCart) or ShoppingCart()
```

</CodeGroup>

### Set

Store state that persists across function invocations.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#state_set"} 
// Store simple values
ctx.set("lastLogin", ctx.date.toJSON());
ctx.set("count", count + 1);

// Store complex objects
ctx.set("profile", {
  name: "John Doe",
  email: "john@example.com",
});
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#state_set"} 
# Store simple values
ctx.set("lastLogin", ctx.request().headers.get("date"))
ctx.set("count", count + 1)

# Store complex objects
ctx.set("profile", UserProfile(name="John Doe", email="john@example.com"))
```
</CodeGroup>

### Clear

State is retained indefinitely for Virtual Objects, or for the configured retention period for Workflows.

To clear state:

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#state_clear"} 
// Clear specific keys
ctx.clear("shoppingCart");
ctx.clear("sessionToken");

// Clear all user data
ctx.clearAll();
```



```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#state_clear"} 
# Clear specific keys
ctx.clear("shoppingCart")
ctx.clear("sessionToken")

# Clear all user data
ctx.clear_all()
```

</CodeGroup>


##  Service communication

### Request-response calls

Make request-response calls to other services. Your function waits for the result.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#service_calls"} 
// Call another service
const validation = await ctx.serviceClient(ValidationService).validateOrder(order);

// Call Virtual Object function
const profile = await ctx.objectClient(UserAccount, userId).getProfile();

// Submit Workflow
const result = await ctx.workflowClient(OrderWorkflow, orderId).run(order);
```

```java Java
// Call another service
ValidationResult validation = ValidationServiceClient.fromContext(ctx)
.validateOrder(order).await();

// Call Virtual Object function
ProfileResult profile = UserAccountClient.fromContext(ctx, userId)
.getProfile().await();
```



```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#service_calls"} 
# Call another service
validation = await ctx.service_call(validation_service.validate_order, order)

# Call Virtual Object function
profile = await ctx.object_call(user_account.get_profile, key=user_id)

# Submit Workflow
result = await ctx.workflow_call(order_workflow.run, key=order_id, arg=order)
```

</CodeGroup>


### Sending messages

Make one-way calls that don't return results. Your function continues immediately.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#sending_messages"} 
// Fire-and-forget notification
ctx.serviceSendClient(NotificationService).sendEmail({ userId, message: "Welcome!" });

// Background analytics
ctx.serviceSendClient(AnalyticsService).recordEvent({ kind: "user_signup", userId });

// Cleanup task
ctx.objectSendClient(ShoppingCartObject, userId).emtpyExpiredCart();
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#sending_messages"} 
# Fire-and-forget notification
ctx.service_send(
    notification_service.send_email, {"userId": user_id, "message": "Welcome!"}
)

# Background analytics
ctx.service_send(
    analytics_service.record_event, {"kind": "user_signup", "userId": user_id}
)

# Cleanup task
ctx.object_send(shopping_cart_object.empty_expired_cart, key=user_id)
```

</CodeGroup>

### Delayed messages

Schedule functions to run in the future.

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#delayed_messages"} 
// Schedule reminder for tomorrow
ctx.serviceSendClient(ReminderService).sendReminder(
  { userId, message },
  sendOpts({
    delay: { days: 1 },
  })
);
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#delayed_messages"} 
# Schedule reminder for tomorrow
ctx.service_send(
    reminder_service.send_reminder,
    {"userId": user_id, "message": message},
    send_delay=timedelta(days=1),
)
```
</CodeGroup>

## Durable timers and timeouts

Pause function execution for a specific duration.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#durable_timers"} 
// Sleep for specific duration
await ctx.sleep({ minutes: 5 }); // 5 minutes

// Wait for action or timeout
const result = await ctx
  .workflowClient(OrderWorkflow, orderId)
  .run(order)
  .orTimeout({ minutes: 5 });
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#durable_timers"} 
# Sleep for specific duration
await ctx.sleep(timedelta(minutes=5))  # 5 minutes

# Wait for action or timeout
match await restate.select(
    result=ctx.workflow_call(order_workflow.run, key=order_id, arg=order),
    timeout=ctx.sleep(timedelta(minutes=5)),
):
    case ["result", result]:
        return result
    case _:
        # Timeout occurred
        pass
```

</CodeGroup>


Functions consume no resources while sleeping and resume at exactly the right time, even across restarts ([see suspensions](/basics/key-concepts#suspensions-on-faas)).

## Workflow events

Use durable promises to wait for external events or human input in your workflows.

Create promises that external systems can resolve to send data to your workflow.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#workflow_promises"} 
// Wait for external event
const paymentResult = await ctx.promise<PaymentResult>("payment-completed");

// Wait for human approval
const approved = await ctx.promise<boolean>("manager-approval");

// Wait for multiple events
const [payment, inventory] = await Promise.all([
  ctx.promise<PaymentResult>("payment"),
  ctx.promise<InventoryResult>("inventory"),
]);
```


```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#workflow_promises"} 
# Wait for external event
payment_result = await ctx.promise("payment-completed").value()

# Wait for human approval
approved = await ctx.promise("manager-approval").value()

# Wait for multiple events using gather
payment_promise = ctx.promise("payment")
inventory_promise = ctx.promise("inventory")
payment, inventory = await restate.gather(
    payment_promise.value(), inventory_promise.value()
)
```
</CodeGroup>

Resolve promises from signal functions.

<CodeGroup>
```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#signal_functions"} 
// In a signal function
confirmPayment: async (ctx: WorkflowSharedContext, result: PaymentResult) => {
  await ctx.promise("payment-completed").resolve(result);
},

// In a signal function
approveRequest: async (ctx: WorkflowSharedContext, approved: boolean) => {
  await ctx.promise("manager-approval").resolve(approved);
},
```

```python Python {"CODE_LOAD::python/src/foundations/actions/actions.py#signal_functions"} 
# In a signal function
@workflow_example_workflow.handler()
async def confirm_payment(ctx: WorkflowSharedContext, result: PaymentResult) -> None:
    await ctx.promise("payment-completed").resolve(result)


# In a signal function
@workflow_example_workflow.handler()
async def approve_request(ctx: WorkflowSharedContext, approved: bool) -> None:
    await ctx.promise("manager-approval").resolve(approved)
```
</CodeGroup>

<Info>To implement a similar pattern in Basic Services or Virtual Objects, have a look at [awakeables](/awakeables).</Info>
