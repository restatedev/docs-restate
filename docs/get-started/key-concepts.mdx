---
title: Key Concepts
description: Core concepts of Restate applications
icon: "cube"
---

Restate gives applications innate resiliency.

## Application Structure

A Restate application consists of three main components that work together to provide reliable execution:

### Restate Services

Your business logic lives in **services** - regular applications that embed the Restate SDK. Services contain **functions** (called handlers) that process requests and execute business logic.

- **Deploy anywhere**: Services run in your infrastructure - containers, serverless functions, VMs, or Kubernetes pods
- **Any language**: TypeScript, Java, Kotlin, Python, Go, and Rust SDKs available
- **Standard patterns**: Services look and feel like normal applications with added reliability by using the Restate SDK

Services come in three types, each optimized for different use cases:
- **Services**: Stateless functions for processing and business logic
- **Virtual Objects**: Stateful entities with consistent state per object instance
- **Workflows**: Long-running coordination and orchestration

### Restate Server

The **Restate Server** sits in front of your services, acting as an intelligent proxy that provides reliability guarantees:

- **Request routing**: Directs incoming requests to the appropriate service handlers
- **Execution tracking**: Records each step in the durable journal
- **Failure recovery**: Automatically retries failed functions with replay protection
- **State management**: Handles persistent storage for Virtual Objects and Workflows

The server is a single binary written in Rust with a stream-processing architecture for **low latency and high throughput**.

### Invocations

An **invocation** represents a request to execute a handler. Restate tracks each invocation through completion, ensuring it runs exactly once regardless of failures.


## Durable Execution

Restate's core feature is **durable execution**: the ability to make any code execution reliable and fault-tolerant without changing how you write business logic.

### How it works

Restate tracks every step of your code execution in a **journal**. When you call external services, update databases, or perform any side-effecting operation, Restate records both the operation and its result. If your function crashes or fails, Restate replays the journal, skipping completed steps and resuming from exactly where it left off.

<img src="/img/concepts/durable_execution_microservices.gif" alt="Durable Execution"/>

In this example, if sending the receipt fails, Restate automatically retries the function but skips the payment processing since it already completed successfully. Each step is recorded in the journal and won't repeat on retry.

### Key benefits

- **Exactly-once execution**: Operations complete exactly once, even with failures and retries
- **Automatic recovery**: Functions resume from their last successful step after any failure
- **No mental model changes**: Existing business logic works without modification
- **Deterministic replay**: Functions produce the same results every time they run

### Unbreakable Resilience

Restate protects your applications from common failure scenarios:
- **Service crashes**: Functions automatically resume from their last completed step
- **Network failures**: Service-to-service calls are automatically retried with exactly-once guarantees
- **Infrastructure problems**: The Restate server handles routing and retry logic transparently
- **State inconsistencies**: All state changes are atomic - either all succeed or none do
- **Concurrency issues**: Virtual Objects provide single-writer guarantees per key

**What if Restate itself crashes?**
The Restate server is designed for high availability with persistent storage. All execution state and journals are durably stored, so the server can recover and continue processing from exactly where it left off.

## Resilient Communication

## Consistent State
## Suspensions on FaaS

When running on serverless platforms, Restate can suspend execution functions while they wait for external events (like user input or long-running tasks).


## Next Steps

Now that you understand the core concepts, dive deeper into how to build with Restate:

### Learn the Building Blocks

- **[Services](/basics/services)**: Understand the three service types - Services, Virtual Objects, and Workflows - and when to use each
- **[Functions](/basics/functions)**: Learn how to write functions that take advantage of durable execution
- **[Actions](/basics/actions)**: Master the context helpers for state management, service calls, and timing control

### Try Restate

- **[Quickstart](/get-started/quickstart)**: Build your first Restate application in 5 minutes
- **[Tour](/tour)**: Explore Restate's capabilities through interactive examples
