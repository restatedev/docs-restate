---
Title: "Deploying Restate on Kubernetes"
sidebarTitle: "Kubernetes"
description: "Deploy the Restate Server on Kubernetes."
---

This page describes how to deploy the Restate Server on [Kubernetes](https://kubernetes.io/).

## Helm Chart
The recommended Kubernetes deployment strategy is a one-replica StatefulSet. We recommend installing Restate in its own
namespace. The easiest way to do this is with our [Helm chart](https://github.com/restatedev/restate/tree/main/charts/restate-helm):

```shell
helm install restate oci://ghcr.io/restatedev/restate-helm --namespace restate --create-namespace
```

- Just a configuration file on how you can deploy Restate to Kubernetes.
- You install helm in your kubernetes. Then you install the helm chart. It helps you deploy other peoples manifests to your kubernetes cluster
- you install the CRD which is the schema of the resources that are needed
- our standard helm chart does not require anything extra outside of what is standardly provided by Kubernetes: containers and the ability to attach volumes to those containers
- to make changes you need to do that manually

Single node or cluster

## Restate Kubernetes Operator

If you want to run multiple Restate clusters in Kubernetes, or want advanced functionality like managing versions of Restate SDK services, you can also use the [Restate Operator](https://github.com/restatedev/restate-operator). Details
of how to install it and deploy a cluster can be found in the [README](https://github.com/restatedev/restate-operator/blob/main/README.md).


- Completely separate to the helm chart
- Makes available a new resource type called resource cluster and restate deployment
- cluster: more dynamic way of deploying a restate server with volumes etc.
- more abstracted version of deploying a restate server.
- you have less to think about doing things. The operator does some things a bit smarter for you. There is a rust reconciler that looks at the crd that the user deploys and turns that into the resources.
- you need to be an administrator to install it. you must be able to create namespaces and crds etc.
- each restate cluster is deployed in its own namespace
- the operator gets notified whenever the user deploys a crd which includes restate resources.
- the better choice if you have an operations team that deploys the operator. And then the separate teams that want to use Restate can deploy clusters in a slightly higher level way.

### How Restate Operator works together with service versioning

Restate operator manages multiple deployed versions of services:

- it creates a restatedeployment operator type
- a kubernetes deployment is a scalable deployment that sits behind a service
- a kubernetes service is a named ingress point in front of some computing service that accepts inbound requests. Itâ€™s an abstraction over a load balancer that routes traffic to one or more pods.
- a restate deployment is pretty similar to that. It has a named entry point and a container reference. A compute specification template that says how much cpu, memory etc. And since itâ€™s a stateless service it can scale without worrying about persistent volumes
- You can manage multiple versions of the deployment running over time.
- You can give it a specific version and it will deploy that and register it with a restate cluster by specifying a name and a namespace.
- The restate operator will repeatedly check for older versions whether they are drained and will then scales to zero when it sees there are no more ongoing invocations

example restate cluster: https://github.com/restatedev/restate-operator/blob/main/crd/examples/restatecluster.yaml

full spec: https://github.com/restatedev/restate-operator/blob/main/crd/restateclusters.yaml or https://github.com/restatedev/restate-operator/blob/main/crd/RestateCluster.pkl

example deployment: https://github.com/restatedev/restate-operator/blob/main/crd/examples/restatedeployment.yaml

full spec: https://github.com/restatedev/restate-operator/blob/main/crd/restatedeployments.yaml or https://github.com/restatedev/restate-operator/blob/main/crd/RestateDeployment.pkl


## Load balancing

## Backups & Snapshots

## Envoy/Nginx

## Guide: Deploy Restate Server with Restate Operator locally on kind

## Guide: Deploy Restate Server with Helm locally on kind

This tutorial will guide you through deploying a single-node Restate cluster on a local Kubernetes cluster using kind (Kubernetes in Docker) and Helm.


### What You'll Learn
- How to deploy Restate using Helm charts on a a local Kubernetes cluster (with kind)
- How to configure Restate for single-node operation
- How to deploy and register services with Restate
- How to verify and test your deployment

## Pre-requisites:
- [Docker](https://docs.docker.com/get-docker/)
- [kind](https://kind.sigs.k8s.io/docs/user/quick-start)
- [Helm](https://helm.sh/docs/intro/install/)
- [kubectl](https://kubernetes.io/docs/tasks/tools/)
- [Restate CLI](https://docs.restate.dev/installation#install-restate-server-%26-cli) and [`restatectl`](https://docs.restate.dev/installation#advanced%3A-installing-restatectl)


## Setting up a Kind Cluster

### Step 1: Create a Kind Configuration File

Create a file named `kind-config.yaml` with the following configuration:

```yaml
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
name: restate-cluster
nodes:
  - role: control-plane
    # Port mappings to expose services
    extraPortMappings:
      # Restate ingress port
      - containerPort: 30080
        hostPort: 8080
        protocol: TCP
      # Restate admin port
      - containerPort: 30070
        hostPort: 9070
        protocol: TCP
      # Restate NodeCtl port (metrics)
      - containerPort: 30122
        hostPort: 5122
        protocol: TCP
    # Extra mounts for persistence (optional)
    extraMounts:
      - hostPath: ./restate-data
        containerPath: /var/restate-data
```

### Step 2: Create the Kind Cluster

```bash
# Create the cluster with the configuration
kind create cluster --config kind-config.yaml

# Verify cluster is running
kubectl cluster-info --context kind-restate-cluster

# Check nodes are ready
kubectl get nodes
```

## Installing Restate with Helm

### Step 1: Create a Custom Values File

Create a file named `restate-values.yaml` to configure Restate for single-node operation:

```yaml
# Restate Helm Chart Values for Single-Node Deployment

# StatefulSet configuration
replicaCount: 1

# Service configuration
service:
  type: NodePort
  ingress:
    port: 8080
    nodePort: 30080
  admin:
    port: 9070
    nodePort: 30070
  metrics:
    port: 5122
    nodePort: 30122

# Persistence configuration
persistence:
  enabled: true
  size: 10Gi
  storageClassName: standard
  # For kind, we use the default storage class

# Resource limits and requests
resources:
  requests:
    memory: "512Mi"
    cpu: "500m"
  limits:
    memory: "2Gi"
    cpu: "2000m"

# Restate server configuration
config:
  # Single-node configuration
  cluster-name: "restate-single-node"
  node-name: "restate-0"

  # Replication factor for single node
  default-replication: 1

  # Auto-provision the cluster
  auto-provision: true

  # Number of partitions (can be adjusted based on workload)
  bootstrap-num-partitions: 4

  # Bifrost configuration for single node
  bifrost:
    default-provider: "replicated"

  # Metadata server configuration
  metadata-server:
    type: "replicated"

  # Admin server configuration
  admin:
    bind-address: "0.0.0.0:9070"

  # Ingress configuration
  ingress:
    bind-address: "0.0.0.0:8080"

# Service Account
serviceAccount:
  create: true
  name: restate

# Security Context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# Liveness and Readiness Probes
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: admin
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  enabled: true
  httpGet:
    path: /health
    port: admin
  initialDelaySeconds: 10
  periodSeconds: 5

# Optional: Enable ingress if you have an ingress controller
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: restate.local
      paths:
        - path: /
          pathType: Prefix
```

### Step 2: Install Restate Using Helm

```bash
# Create a namespace for Restate
kubectl create namespace restate

# Add the Restate Helm repository (if using OCI registry)
# Note: Restate uses OCI registry for Helm charts

# Install Restate with custom values
helm install restate \
  oci://ghcr.io/restatedev/restate-helm \
  --namespace restate \
  --values restate-values.yaml \
  --wait \
  --timeout 5m

# Alternatively, if you've cloned the repository:
# git clone https://github.com/restatedev/restate.git
# cd restate/charts/restate-helm
# helm install restate . --namespace restate --values ../../restate-values.yaml
```

### Step 3: Verify the Installation

```bash
# Check if the StatefulSet is running
kubectl get statefulset -n restate

# Check if the pod is running
kubectl get pods -n restate

# Check services
kubectl get svc -n restate

# View logs
kubectl logs -n restate restate-0

# Check PVC (Persistent Volume Claim)
kubectl get pvc -n restate
```

## Verifying the Installation

### Step 1: Port Forward to Access Restate UI

If NodePort is not working, you can use port-forward:

```bash
# Forward admin port
kubectl port-forward -n restate svc/restate 9070:9070 &

# Forward ingress port
kubectl port-forward -n restate svc/restate 8080:8080 &
```

### Step 2: Check Restate Status

Using the Restate CLI:

```bash
# Check cluster status
restate status

# Or using restatectl from inside the pod
kubectl exec -n restate restate-0 -- restatectl status

# Check nodes
kubectl exec -n restate restate-0 -- restatectl nodes list

# Check logs configuration
kubectl exec -n restate restate-0 -- restatectl logs list
```

### Step 3: Access Restate UI

Open your browser and navigate to:
- Admin UI: http://localhost:9070
- Ingress endpoint: http://localhost:8080

## Deploying a Sample Service

### Step 1: Create a Simple Greeter Service

Create a file named `greeter-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: greeter-service
  namespace: restate
spec:
  replicas: 1
  selector:
    matchLabels:
      app: greeter
  template:
    metadata:
      labels:
        app: greeter
    spec:
      containers:
        - name: greeter
          # Use your own service image or a sample from Restate examples
          image: ghcr.io/restatedev/examples-typescript-greeter:latest
          env:
            - name: PORT
              value: "9080"
          ports:
            - containerPort: 9080
              name: restate
---
apiVersion: v1
kind: Service
metadata:
  name: greeter-service
  namespace: restate
spec:
  selector:
    app: greeter
  ports:
    - port: 9080
      name: restate
  type: ClusterIP
```

Deploy the service:

```bash
kubectl apply -f greeter-deployment.yaml

# Verify the service is running
kubectl get pods -n restate | grep greeter
kubectl get svc -n restate | grep greeter
```

### Step 2: Register the Service with Restate

```bash
# Register the service endpoint
restate deployments register http://greeter-service.restate.svc.cluster.local:9080 \
  --yes

# Or using curl
curl -X POST http://localhost:9070/deployments \
  -H "Content-Type: application/json" \
  -d '{"uri": "http://greeter-service.restate.svc.cluster.local:9080"}'

# List registered deployments
restate deployments list
```

## Testing Your Setup

### Step 1: Invoke the Service

```bash
# Call the greeter service
curl http://localhost:8080/Greeter/greet \
  -H "Content-Type: application/json" \
  -d '"World"'

# Expected response: "Hello, World!"
```

### Step 2: Check Service Invocations

```bash
# List invocations
restate invocations list

# Get invocation details (replace with actual invocation ID)
restate invocations describe <invocation-id>
```

## Monitoring and Operations

### Metrics with Prometheus

Restate exposes metrics in Prometheus format at the NodeCtl endpoint:

```bash
# Get metrics
curl http://localhost:5122/metrics
```

### Setting up Prometheus (Optional)

Create `prometheus-config.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: restate
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
      - job_name: 'restate'
        static_configs:
          - targets: ['restate:5122']
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: restate
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
        - name: prometheus
          image: prom/prometheus:latest
          ports:
            - containerPort: 9090
          volumeMounts:
            - name: config
              mountPath: /etc/prometheus
      volumes:
        - name: config
          configMap:
            name: prometheus-config
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: restate
spec:
  selector:
    app: prometheus
  ports:
    - port: 9090
  type: NodePort
```

Deploy Prometheus:

```bash
kubectl apply -f prometheus-config.yaml

# Port forward to access Prometheus
kubectl port-forward -n restate svc/prometheus 9090:9090
```

## Troubleshooting

### Common Issues and Solutions

#### 1. Pod Not Starting

```bash
# Check pod status
kubectl describe pod -n restate restate-0

# Check logs
kubectl logs -n restate restate-0

# Check events
kubectl get events -n restate --sort-by='.lastTimestamp'
```

#### 2. Service Registration Fails

```bash
# Check if service is reachable from Restate pod
kubectl exec -n restate restate-0 -- curl http://greeter-service:9080

# Check service endpoints
kubectl get endpoints -n restate greeter-service
```

#### 3. Storage Issues

```bash
# Check PVC status
kubectl get pvc -n restate

# Check available storage
kubectl get storageclass
kubectl describe storageclass standard
```

#### 4. Connection Issues

```bash
# Test connectivity
kubectl exec -n restate restate-0 -- nc -zv greeter-service 9080

# Check network policies
kubectl get networkpolicies -n restate
```

### Viewing Logs

```bash
# Stream logs
kubectl logs -n restate restate-0 -f

# Get logs with timestamps
kubectl logs -n restate restate-0 --timestamps=true

# Get previous container logs (if crashed)
kubectl logs -n restate restate-0 --previous
```

## Next Steps

### 1. Scaling to Multi-Node (Future)

While this tutorial focuses on single-node deployment, Restate supports multi-node clusters. To scale:

1. Update the `replicaCount` in your Helm values
2. Configure proper replication factors
3. Set up a shared storage solution
4. Configure snapshot repository for state replication

### 2. Production Considerations

For production deployments, consider:

- **Persistence**: Use production-grade storage classes
- **Snapshots**: Configure external object storage (S3, MinIO)
- **Security**: Enable TLS, configure RBAC
- **Monitoring**: Set up comprehensive monitoring with Prometheus/Grafana
- **Backup**: Implement backup strategies for state data

### 3. Advanced Configuration

Explore additional Restate features:

- **Workflows**: Build complex orchestration workflows
- **Virtual Objects**: Manage stateful entities
- **Kafka Integration**: Connect with event streams
- **Service Versioning**: Implement zero-downtime deployments

### 4. Useful Resources

- [Restate Documentation](https://docs.restate.dev)
- [Restate GitHub Repository](https://github.com/restatedev/restate)
- [Restate Examples](https://github.com/restatedev/examples)
- [Restate Discord Community](https://discord.gg/restate)

## Cleanup

To remove the entire setup:

```bash
# Delete Restate deployment
helm uninstall restate -n restate

# Delete the namespace
kubectl delete namespace restate

# Delete the kind cluster
kind delete cluster --name restate-cluster

# Clean up local data (if created)
rm -rf ./restate-data
```

## Conclusion

You've successfully deployed a single-node Restate cluster on a kind Kubernetes cluster using Helm! This setup provides a solid foundation for:

- Local development and testing
- Learning Restate concepts
- Prototyping distributed applications
- Preparing for production deployments

The single-node configuration is perfect for development but can be easily scaled to multi-node deployments when needed. Restate's architecture ensures that even a single-node deployment provides durable execution and reliable state management for your services.

Remember that Restate handles:
- **Durable execution**: Automatic retries and recovery from failures
- **State management**: Built-in K/V store for your services
- **Service orchestration**: Workflows and virtual objects
- **Version management**: Safe deployments with the Kubernetes operator

Happy building with Restate! ðŸš€