---
title: Key Concepts
description: Core concepts of Restate applications
icon: "cube"
---

This page explains the key concepts and architecture that make Restate applications reliable and resilient.

## Application Structure

A Restate application consists of the following components:

<img src="/img/concepts/app_layout.svg" alt="Application Structure"/>

### Restate Services

Your business logic lives in **services**: regular applications that embed the Restate SDK. Services contain **functions** (called handlers) that process requests and execute business logic.

- **Deploy anywhere**: Services run in your infrastructure as containers, serverless functions, VMs, or Kubernetes pods
- **Familiar programming model**: Services look and feel like normal applications with added reliability by using the Restate SDK. Restate has SDKs for TypeScript, Java, Kotlin, Python, Go, and Rust.

### Restate Server

The **Restate Server** sits in front of your services, similar to a reverse proxy or message broker. It handles incoming requests, manages service discovery, and provides durable execution capabilities.

The server is a single binary written in Rust with a stream-processing architecture for **low latency and high throughput**.

It can be deployed in a high-availability cluster or as a single-node instance.

<Card title="Restate Cloud" href="https://restate.dev/cloud/" icon="cloud">
   Look at the options for Restate Cloud for a fully managed Restate deployment.
</Card>

### Invocations

An **invocation** represents a request to execute a handler. Restate tracks each invocation through completion, ensuring it runs exactly once regardless of failures.

You can invoke Restate handlers over HTTP, Kafka, or programmatically.

## Durable Execution

Restate's core feature is **durable execution**: the ability to make any code execution reliable and fault-tolerant without changing how you write business logic.

### How it works

Restate tracks every step of your code execution in a **journal**. When you call other services, update databases, set timers, or perform any side-effecting operation, Restate records both the operation and its result. If your function crashes or fails, Restate replays the journal, skipping completed steps and resuming from exactly where it left off.

<img src="/img/concepts/durable_execution_microservices.gif" alt="Durable Execution"/>

In this example, if sending the receipt fails, Restate automatically retries the function but skips the payment processing since it already completed successfully. Each step is recorded in the journal and won't repeat on retry.

<Info>
For a detailed technical walkthrough of the lifecycle of a request, read this **[guide](/guides/request-lifecycle)**.
</Info>

### What it covers

Restate's implementation of Durable Execution protects your applications from common failure scenarios:
<AccordionGroup>
    <Accordion title="Infrastructure failures (e.g. server crashes, VM restarts)">
        - **Service crashes or restarts**: Any ongoing executions are retried on new instances.
        - **Restate Server crashes or restarts**: The Restate Server can be deployed as a high-availability cluster, so if a node fails, others can take over without losing any execution state.
        If Restate is deployed as a single node, it can still recover from crashes by recovering from persistent disk.
    </Accordion>
    <Accordion title="API timeouts and downtime">
        If a handler calls an API that times out, Restate will retry the run action with exponential backoff.
    </Accordion>
    <Accordion title="Duplicate requests">
        If you add an idempotency key to your request headers, Restate will automatically ensure that requests are deduplicated.
        Duplicate requests will return the same result as the original request.
    </Accordion>
    <Accordion title="Network outages, partitions and zombie processes">
        - **Between Server and service**: If the service cannot send journal entries to the Restate Server, it will stop the handler execution. The Restate Server will retry the execution on another service instance.
        - **Between nodes in a Restate cluster**: Restate clusters rely on a consensus algorithm to accept new entries in the log. The consensus algorithm requires a majority of nodes to be available, so if a network partition occurs, the cluster will still be able to process requests as long as a majority can still communicate.
    </Accordion>
</AccordionGroup>

## Resilient Communication

Beyond executing individual handlers reliably, Restate also ensures that communication between services is resilient.

Restate proxies all communication towards and between services.
It provides a **resilient RPC framework** that allows you to call other services in a durable way, with or without waiting for a response.

The Restate UI gives you an introspection tool to see chains of calls and their results, so you can easily debug and understand the flow of your application.

## Consistent State

The Restate Server includes an embedded **key-value store** for persisting application state in Virtual Objects and Workflows.

Key characteristics:
- **Usage**: Implement consistent state machines, session state, or agent context and memory.
- **Scoped per entity**: Each Virtual Object and Workflow execution has its own isolated state.
- **Automatically journaled**: State updates are recorded alongside execution steps for consistency. State is never out of sync with the execution.
- **Single-writer guarantee**: Only one handler can modify state at a time, preventing race conditions.
- **Stateless services**: The Restate Server stores all state and execution history and supplies it together with the request to the handler. Your service deployments don't need to manage any state and can scale horizontally. This lets you run stateful logic on stateless platforms (e.g., serverless, FaaS).
- **Lifetime**: State is retained indefinitely for Virtual Objects, or for the configured retention period for Workflows.


<Info>
    Learn more about when to store state in Restate vs. in a database with [this guide](/guides/databases).
</Info>

## Suspensions on FaaS

When running handlers on function-as-a-service platforms (FaaS), like AWS Lambda, Restate can suspend execution functions while they wait for external events (like user input or long-running tasks).

For example, if a handler needs to wait for a user to approve an order, Restate can suspend the function until the user responds.

This lets you run long-running workflows on FaaS platforms **without paying for wait time**.

## Next Steps

Now that you understand the core concepts, dive deeper into how to build with Restate:

- **[Services](/basics/services)**: Understand the three service types and when to use each
- **[Functions](/basics/functions)**: Learn how to write functions that take advantage of durable execution
- **[Actions](/basics/actions)**: Master the context helpers for state management, service calls, and timing control
