---
title: Actions
description: Essential context actions for building reliable functions
icon: "gear"
---

Context actions are methods available on the Restate Context object (`ctx`) that provide Restate's core capabilities.
These actions enable durable execution, state management, service communication, and timing control.

### Durable steps

Use `ctx.run` to safely wrap any non-deterministic operation, like HTTP calls or database responses, and have Restate persist its result.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#durable_steps"} 
// External API call
const apiResult = await ctx.run("fetch-data", async () => {
  const response = await fetch("https://api.example.com/data");
  return response.json();
});

// Database operation
const dbResult = await ctx.run("update-user", () => {
  return updateUserDatabase(userId, { name: "John" });
});

// Idempotency key generation
const id = await ctx.run("generate-id", () => uuid());
```

</CodeGroup>

Without `ctx.run()`, these operations would produce different results during replay, breaking deterministic recovery.

## State management

Available in Virtual Object and Workflow functions for persistent key-value storage.

### Get

Retrieve stored state by key.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#state_get"} 
// Get with type and default value
const profile = await ctx.get<UserProfile>("profile");
const count = (await ctx.get<number>("count")) ?? 0;
const cart = (await ctx.get<ShoppingCart>("cart")) ?? [];
```

</CodeGroup>

### Set

Store state that persists across function invocations.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#state_set"} 
// Store simple values
ctx.set("lastLogin", ctx.date.toJSON());
ctx.set("count", count + 1);

// Store complex objects
ctx.set("profile", {
  name: "John Doe",
  email: "john@example.com",
});
```
</CodeGroup>

### Clear

State is retained indefinitely for Virtual Objects, or for the configured retention period for Workflows.

To clear state:

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#state_clear"} 
// Clear specific keys
ctx.clear("shoppingCart");
ctx.clear("sessionToken");

// Clear all user data
ctx.clearAll();
```

</CodeGroup>


##  Service communication

### Request-response calls

Make request-response calls to other services. Your function waits for the result.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#service_calls"} 
// Call another service
const validation = await ctx
  .serviceClient(ValidationService)
  .validateOrder(order);

// Call Virtual Object function
const profile = await ctx.objectClient(UserAccount, userId).getProfile();

// Call Workflow function
const status = await ctx
  .workflowClient(OrderWorkflow, orderId)
  .getStatus();
```

```java Java
// Call another service
ValidationResult validation = ValidationServiceClient.fromContext(ctx)
.validateOrder(order).await();

// Call Virtual Object function
ProfileResult profile = UserAccountClient.fromContext(ctx, userId)
.getProfile().await();
```

```python Python
# Call another service
validation = await ValidationServiceClient.from_context(ctx).validate_order(order)

# Call Virtual Object function
profile = await UserAccountClient.from_context(ctx, user_id).get_profile()
```

</CodeGroup>


### Sending messages

Make one-way calls that don't return results. Your function continues immediately.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#sending_messages"} 
// Fire-and-forget notification
ctx
  .serviceSendClient(NotificationService)
  .sendEmail({ userId, message: "Welcome!" });

// Background analytics
ctx
  .serviceSendClient(AnalyticsService)
  .recordEvent({ kind: "user_signup", userId });

// Cleanup task
ctx.objectSendClient(ShoppingCartObject, userId).emtpyExpiredCart();
```

```java Java
// Fire-and-forget calls
NotificationServiceClient.fromContext(ctx).send()
.sendEmail(userId, "Welcome!");

AnalyticsServiceClient.fromContext(ctx).send()
.recordEvent("user_signup", eventData);
```

</CodeGroup>

### Delayed messages

Schedule functions to run in the future.

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#delayed_messages"} 
// Schedule reminder for tomorrow
ctx.serviceSendClient(ReminderService).sendReminder(
  { userId, message },
  sendOpts({
    delay: { days: 1 },
  })
);
```

## Durable timers and timeouts

Pause function execution for a specific duration.

<CodeGroup>

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#durable_timers"} 
// Sleep for specific duration
await ctx.sleep({ minutes: 5 }); // 5 minutes

// Wait for action or timeout
const profile = await ctx
  .objectClient(UserAccount, userId)
  .getProfile()
  .orTimeout({ minutes: 1 });
```

```java Java
// Sleep for durations
ctx.sleep(Duration.ofSeconds(30));
ctx.sleep(Duration.ofMinutes(5));
ctx.sleep(Duration.ofHours(1));
```

```python Python
# Sleep with timedelta
await ctx.sleep(timedelta(seconds=30))
await ctx.sleep(timedelta(minutes=5))
await ctx.sleep(timedelta(hours=1))
```

</CodeGroup>


Functions consume no resources while sleeping and resume at exactly the right time, even across restarts ([see suspensions](/basics/key-concepts#suspensions-on-faas)).

## Workflow events

Use durable promises to wait for external events or human input in your workflows.

Create promises that external systems can resolve to send data to your workflow.

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#workflow_promises"} 
// Wait for external event
const paymentResult = await ctx.promise<PaymentResult>(
  "payment-completed"
);

// Wait for human approval
const approved = await ctx.promise<boolean>("manager-approval");

// Wait for multiple events
const [payment, inventory] = await Promise.all([
  ctx.promise<PaymentResult>("payment"),
  ctx.promise<InventoryResult>("inventory"),
]);
```

Resolve promises from signal functions.

```typescript TypeScript {"CODE_LOAD::ts/src/foundations/actions/actions.ts#signal_functions"} 
// In a signal function
confirmPayment: async (
  ctx: WorkflowSharedContext,
  result: PaymentResult
) => {
  await ctx.promise("payment-completed").resolve(result);
},

// In a signal function
approveRequest: async (ctx: WorkflowSharedContext, approved: boolean) => {
  await ctx.promise("manager-approval").resolve(approved);
},
```

<Info>To implement a similar pattern in Basic Services or Virtual Objects, have a look at [awakeables](/awakeables).</Info>
