---
title: Actions
description: Essential context actions for building reliable functions
icon: "gear"
---

Context helpers are methods available on the context object (`ctx`) that provide Restate's core capabilities. These helpers enable durable execution, state management, service communication, and timing control.

## Durable steps

### Run

The foundation of reliable external system integration. Wraps non-deterministic operations to make them safe for retries.

<CodeGroup>

```typescript TypeScript
// External API call
const apiResult = await ctx.run("fetch-data", async () => {
  const response = await fetch("https://api.example.com/data");
  return response.json();
});

// Database operation
const dbResult = await ctx.run("update-user", () => {
  return database.users.update(userId, { name: "John" });
});

// Random value generation
const randomId = await ctx.run("generate-id", () => {
  return Math.random().toString(36);
});
```

```java Java
// External API call
ApiResponse apiResult = ctx.run("fetch-data", () -> {
    HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());
    return objectMapper.readValue(response.body(), ApiResponse.class);
});

// Database operation
UserResult dbResult = ctx.run("update-user", () -> {
    return database.users().update(userId).setName("John").execute();
});
```

```python Python
# External API call
api_result = await ctx.run("fetch-data", lambda: requests.get("https://api.example.com/data").json())

# Database operation
db_result = await ctx.run("update-user", lambda: database.users.update(user_id, {"name": "John"}))
```
</CodeGroup>

Without `ctx.run()`, these operations would produce different results during replay, breaking consistency.

## State management

Available in Virtual Object and Workflow functions for persistent key-value storage.

### Get

Retrieve stored state by key.

<CodeGroup>

```typescript TypeScript
// Get with type and default value
const profile = await ctx.get<UserProfile>("profile");
const count = (await ctx.get<number>("count")) ?? 0;
const settings = await ctx.get<Settings>("settings") ?? defaultSettings;
```

```java Java
// Get with optional handling
UserProfile profile = ctx.get("profile", UserProfile.class);
Integer count = ctx.get("count", Integer.class).orElse(0);
Settings settings = ctx.get("settings", Settings.class).orElse(defaultSettings);
```

```python Python
# Get with default values
profile = await ctx.get("profile", UserProfile)
count = await ctx.get("count", int) or 0
settings = await ctx.get("settings", Settings) or default_settings
```
</CodeGroup>

### Set

Store state that persists across function invocations.

<CodeGroup>

```typescript TypeScript
// Store simple values
ctx.set("lastLogin", new Date().toISOString());
ctx.set("loginCount", loginCount + 1);

// Store complex objects
ctx.set("profile", {
  name: "John Doe",
  email: "john@example.com",
  preferences: { theme: "dark" }
});
```

```java Java
// Store values
ctx.set("lastLogin", Instant.now().toString());
ctx.set("loginCount", loginCount + 1);
ctx.set("profile", userProfile);
```

```python Python
# Store values
await ctx.set("lastLogin", datetime.now().isoformat())
await ctx.set("loginCount", login_count + 1)
await ctx.set("profile", user_profile)
```
</CodeGroup>

### Clear

Remove state keys completely.

<CodeGroup>
```typescript TypeScript
// Clear specific keys
ctx.clear("tempData");
ctx.clear("sessionToken");

// Clear all user data
ctx.clearAll();
```

</CodeGroup>

State changes are atomic - either all changes in a function are applied when it completes, or none are if it fails.

## Service communication

### Request-response calls

Make request-response calls to other services. Your function waits for the result.

<CodeGroup>

```typescript TypeScript
// Call another service
const validation = await ctx.serviceCall(ValidationService).validateOrder(order);

// Call Virtual Object function
const profile = await ctx.objectCall(UserAccount, userId).getProfile();

// Call Workflow function
const status = await ctx.workflowCall(OrderWorkflow, orderId).getStatus();
```

```java Java
// Call another service
ValidationResult validation = ValidationServiceClient.fromContext(ctx)
    .validateOrder(order).await();

// Call Virtual Object function
ProfileResult profile = UserAccountClient.fromContext(ctx, userId)
    .getProfile().await();
```

```python Python
# Call another service
validation = await ValidationServiceClient.from_context(ctx).validate_order(order)

# Call Virtual Object function
profile = await UserAccountClient.from_context(ctx, user_id).get_profile()
```
</CodeGroup>


### Sending messages

Make one-way calls that don't return results. Your function continues immediately.

<CodeGroup>

```typescript TypeScript
// Fire-and-forget notification
ctx.serviceSend(NotificationService).sendEmail(userId, "Welcome!");

// Background analytics
ctx.serviceSend(AnalyticsService).recordEvent("user_signup", { userId });

// Cleanup task
ctx.serviceSend(CleanupService).deleteExpiredData();
```

```java Java
// Fire-and-forget calls
NotificationServiceClient.fromContext(ctx).send()
    .sendEmail(userId, "Welcome!");

AnalyticsServiceClient.fromContext(ctx).send()
    .recordEvent("user_signup", eventData);
```
</CodeGroup>

### Delayed messages

Schedule functions to run in the future.

```typescript TypeScript
// Schedule reminder for tomorrow
ctx.serviceCall(ReminderService).sendReminder(userId, message, {
  delay: 24 * 60 * 60 * 1000 // 24 hours
});

// Schedule timeout check
ctx.serviceCall(TimeoutService).checkTimeout(requestId, {
  delay: 5 * 60 * 1000 // 5 minutes
});
```

## Durable timers

### Sleep

Pause function execution for a specific duration.

<CodeGroup>

```typescript TypeScript
// Sleep for 30 seconds
await ctx.sleep(30 * 1000);

// Sleep for specific duration
await ctx.sleep(5 * 60 * 1000); // 5 minutes

// Sleep until specific time
const targetTime = new Date('2024-12-25T09:00:00Z');
const delay = targetTime.getTime() - Date.now();
await ctx.sleep(delay);
```

```java Java
// Sleep for durations
ctx.sleep(Duration.ofSeconds(30));
ctx.sleep(Duration.ofMinutes(5));
ctx.sleep(Duration.ofHours(1));
```

```python Python
# Sleep with timedelta
await ctx.sleep(timedelta(seconds=30))
await ctx.sleep(timedelta(minutes=5))
await ctx.sleep(timedelta(hours=1))
```
</CodeGroup>


Functions consume no resources while sleeping and resume at exactly the right time, even across restarts.

## Workflow-specific actions

Available only in Workflow functions for coordination and external communication.

### Create Durable Promises

Create promises that external systems can resolve to send data to your workflow.

```typescript TypeScript
// Wait for external event
const paymentResult = await ctx.promise<PaymentResult>("payment-completed");

// Wait for human approval
const approved = await ctx.promise<boolean>("manager-approval");

// Wait for multiple events
const [payment, inventory] = await Promise.all([
  ctx.promise<PaymentResult>("payment"),
  ctx.promise<InventoryResult>("inventory")
]);
```

### Resolve Durable Promises

Resolve promises from signal functions.

```typescript TypeScript
// In a signal function
export const confirmPayment = async (ctx: WorkflowSharedContext, result: PaymentResult) => {
  ctx.promise("payment-completed").resolve(result);
};

// In a signal function
export const approveRequest = async (ctx: WorkflowSharedContext, approved: boolean) => {
  ctx.promise("manager-approval").resolve(approved);
};
```

## Context types summary

- **`Context`**: Service functions - stateless processing
- **`ObjectContext`**: Virtual Object functions - stateful with per-key storage
- **`WorkflowContext`**: Main workflow functions - long-running coordination
- **`WorkflowSharedContext`**: Workflow signals and queries - external interaction

Each context type provides the appropriate helpers for its service pattern, ensuring you have the right tools for building reliable, distributed applications.