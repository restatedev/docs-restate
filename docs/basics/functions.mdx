---
title: Functions
description: Learn how to create, invoke and manage functions in Restate services
icon: "brackets-curly"
---

Functions are the building blocks of Restate services. Export a function and Restate automatically makes it a durable handler.

## Writing functions

Functions receive a context (`ctx`) and optional input:

<CodeGroup>
```typescript TypeScript
export const myFunction = async (ctx: Context, input: MyInput) => {
  const result = await ctx.run("process", () => processData(input));
  return { success: true, result };
};
```

```java Java
@Handler
public MyResult myFunction(Context ctx, MyInput input) {
  String result = ctx.run("process", () -> processData(input));
  return new MyResult(true, result);
}
```

```python Python
async def my_function(ctx: Context, input: MyInput):
  result = await ctx.run("process", lambda: process_data(input))
  return {"success": True, "result": result}
```
</CodeGroup>

### Context types

The context type depends on your service type:

- **`Context`** - Services (stateless)
- **`ObjectContext`** - Virtual Objects (stateful, exclusive access)
- **`ObjectSharedContext`** - Virtual Objects (read-only, concurrent)
- **`WorkflowContext`** - Workflows (main handler)
- **`WorkflowSharedContext`** - Workflows (signals/queries)



## Invoking functions

### Over HTTP

```typescript TypeScript
export const getUserProfile = async (ctx: ObjectContext) => { /* ... */ };
export const processPayment = async (ctx: Context, payment: Payment) => { /* ... */ };
export const sendWelcomeEmail = async (ctx: Context, userId: string) => { /* ... */ };
```

When you register your service with Restate, these function names become the endpoints:
    - `POST /MyService/getUserProfile`
    - `POST /PaymentService/processPayment`
    - `POST /NotificationService/sendWelcomeEmail`

### Using typed clients

Functions can call other functions within the same service or across different services.

<CodeGroup>
```typescript TypeScript
export const processOrder = async (ctx: Context, order: Order) => {
    // Call function in same service
    const validation = await ctx.serviceCall(OrderService).validateOrder(order);

    // Call function in different service
    const inventory = await ctx.serviceCall(InventoryService).reserveItems(order.items);

    // Call Virtual Object function
    const profile = await ctx.objectCall(UserAccount, order.customerId).getProfile();
};
```

```java Java
@Handler
public OrderResult processOrder(Context ctx, Order order) {
    ValidationResult validation = OrderServiceClient.fromContext(ctx)
    .validateOrder(order).await();

    InventoryResult inventory = InventoryServiceClient.fromContext(ctx)
    .reserveItems(order.getItems()).await();

    ProfileResult profile = UserAccountClient.fromContext(ctx, order.getCustomerId())
    .getProfile().await();
}
```

```python Python
async def process_order(ctx: Context, order: Order):
    validation = await OrderServiceClient.from_context(ctx).validate_order(order)

    inventory = await InventoryServiceClient.from_context(ctx).reserve_items(order.items)

    profile = await UserAccountClient.from_context(ctx, order.customer_id).get_profile()
```
</CodeGroup>

[Learn more from the actions page](/basics/actions#service-communication)

## Exclusive vs. shared handlers

Virtual Objects and Workflows can have two types of handlers:

### Exclusive handlers
* Use `ObjectContext` or `WorkflowContext`
* Can **read and write** state (`ctx.set`, `ctx.clear`, etc.)

For Virtual Objects:
* Only **one exclusive handler** runs at a time per object key
* Calls are queued and executed sequentially to ensure consistency

### Shared handlers
* Use `ObjectSharedContext` or `WorkflowSharedContext`
* Can **only read** stateâ€”**no write access**
* Run concurrently without blocking other handlers
* Useful for interacting with long-running exclusive handlers without waiting

**Why both?** Exclusive handlers prevent concurrent writes from corrupting state, while shared handlers allow non-blocking read access during long-running operations. For example, a dashboard can query a workflow's status via a shared handler while the main exclusive handler is still processing.

