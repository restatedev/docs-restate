---
title: Functions
description: Learn how to create, invoke and manage functions in Restate services
icon: "brackets-curly"
---

Functions are the core building blocks of Restate services. Under the hood, Restate marks each function you export as a handlerâ€”i.e. the code that actually executes when a request comes in.

## Function basics

Every Restate function receives a context object (`ctx`) as its first parameter, followed by the input data. The context provides access to Restate's durable execution capabilities.

<CodeGroup>
    ```typescript TypeScript
    export const myFunction = async (ctx: Context, input: MyInput) => {
    // Your business logic here
    const result = await ctx.run("process", () => processData(input));

    return { success: true, result };
};
    ```

    ```java Java
    @Handler
    public MyResult myFunction(Context ctx, MyInput input) {
    // Your business logic here
    String result = ctx.run("process", () -> processData(input));

    return new MyResult(true, result);
}
    ```

    ```python Python
    async def my_function(ctx: Context, input: MyInput):
    # Your business logic here
    result = await ctx.run("process", lambda: process_data(input))

    return {"success": True, "result": result}
    ```
</CodeGroup>

Functions are automatically durable - they survive failures, retries, and restarts while maintaining exactly-once execution guarantees.

## Function types by service

Different service types provide different context objects with specialized capabilities:

### Basic Service functions

Basic Service functions use `Context` and are stateless. They process requests independently without storing data between calls.

<CodeGroup>
    ```typescript TypeScript
    export const processOrder = async (ctx: Context, order: Order) => {
    // Validate the order
    const validation = await ctx.run("validate", () => validateOrder(order));

    // Call payment service
    const payment = await ctx.serviceCall(PaymentService).processPayment(order.total);

    return { orderId: order.id, paymentId: payment.id };
};
    ```

    ```java Java
    @Handler
    public OrderResult processOrder(Context ctx, Order order) {
    ValidationResult validation = ctx.run("validate", () -> validateOrder(order));

    PaymentResult payment = PaymentServiceClient.fromContext(ctx)
    .processPayment(order.getTotal()).await();

    return new OrderResult(order.getId(), payment.getId());
}
    ```

    ```python Python
    async def process_order(ctx: Context, order: Order):
    validation = await ctx.run("validate", lambda: validate_order(order))

    payment = await PaymentServiceClient.from_context(ctx).process_payment(order.total)

    return {"order_id": order.id, "payment_id": payment.id}
    ```
</CodeGroup>

### Virtual Object functions

Virtual Object functions use `ObjectContext` and can store state per object key. Each object key processes requests sequentially.

<CodeGroup>
    ```typescript TypeScript
    export const updateBalance = async (ctx: ObjectContext, amount: number) => {
    // Get current balance
    const currentBalance = (await ctx.get<number>("balance")) ?? 0;

    // Update balance
    const newBalance = currentBalance + amount;
    ctx.set("balance", newBalance);

    return { balance: newBalance };
};
    ```

    ```java Java
    @Handler
    public BalanceResult updateBalance(ObjectContext ctx, Integer amount) {
    Integer currentBalance = ctx.get("balance", Integer.class).orElse(0);

    Integer newBalance = currentBalance + amount;
    ctx.set("balance", newBalance);

    return new BalanceResult(newBalance);
}
    ```

    ```python Python
    async def update_balance(ctx: ObjectContext, amount: int):
    current_balance = await ctx.get("balance", int) or 0

    new_balance = current_balance + amount
    await ctx.set("balance", new_balance)

    return {"balance": new_balance}
    ```
</CodeGroup>

### Workflow functions

Workflow functions use `WorkflowContext` for the main workflow, `WorkflowSharedContext` for signals and queries.

<CodeGroup>
    ```typescript TypeScript
    // Main workflow function
    export const processApproval = async (ctx: WorkflowContext, request: ApprovalRequest) => {
    ctx.set("status", "pending");

    // Wait for approval decision
    const approved = await ctx.promise<boolean>("approval-decision");

    ctx.set("status", approved ? "approved" : "rejected");
    return { approved };
};

    // Signal function
    export const approve = async (ctx: WorkflowSharedContext, decision: boolean) => {
    ctx.promise("approval-decision").resolve(decision);
};

    // Query function
    export const getStatus = async (ctx: WorkflowSharedContext) => {
    const status = await ctx.get<string>("status");
    return { status: status ?? "pending" };
};
    ```

    ```java Java
    // Main workflow function
    @Handler
    public ApprovalResult processApproval(WorkflowContext ctx, ApprovalRequest request) {
    ctx.set("status", "pending");

    Boolean approved = ctx.promise("approval-decision", Boolean.class).await();

    ctx.set("status", approved ? "approved" : "rejected");
    return new ApprovalResult(approved);
}

    // Signal function
    @Handler
    public void approve(WorkflowSharedContext ctx, Boolean decision) {
    ctx.promise("approval-decision").resolve(decision);
}

    // Query function
    @Handler
    public StatusResult getStatus(WorkflowSharedContext ctx) {
    String status = ctx.get("status", String.class).orElse("pending");
    return new StatusResult(status);
}
    ```

    ```python Python
    # Main workflow function
    async def process_approval(ctx: WorkflowContext, request: ApprovalRequest):
    await ctx.set("status", "pending")

    approved = await ctx.promise("approval-decision", bool)

    await ctx.set("status", "approved" if approved else "rejected")
    return {"approved": approved}

    # Signal function
    async def approve(ctx: WorkflowSharedContext, decision: bool):
    ctx.promise("approval-decision").resolve(decision)

    # Query function
    async def get_status(ctx: WorkflowSharedContext):
    status = await ctx.get("status", str) or "pending"
    return {"status": status}
    ```
</CodeGroup>

## Function naming and registration

Function names become part of your service's API. Choose descriptive names that clearly indicate what the function does.

```typescript TypeScript
// Good function names
export const getUserProfile = async (ctx: ObjectContext) => { /* ... */ };
export const processPayment = async (ctx: Context, payment: Payment) => { /* ... */ };
export const sendWelcomeEmail = async (ctx: Context, userId: string) => { /* ... */ };

// Less clear function names
export const handle = async (ctx: Context, data: any) => { /* ... */ };
export const process = async (ctx: Context, input: any) => { /* ... */ };
```

When you register your service with Restate, these function names become the endpoints:
    - `GET/POST /MyService/getUserProfile`
    - `POST /PaymentService/processPayment`
    - `POST /NotificationService/sendWelcomeEmail`

## Input and output

Functions can accept any JSON-serializable input and return any JSON-serializable output.

```typescript TypeScript
// Simple input/output
export const add = async (ctx: Context, numbers: { a: number, b: number }) => {
  return { sum: numbers.a + numbers.b };
};

// Complex objects
export const createUser = async (ctx: ObjectContext, user: {
  name: string;
  email: string;
  preferences: {
    theme: "light" | "dark";
    notifications: boolean;
  };
}) => {
  ctx.set("user", user);
  ctx.set("createdAt", new Date().toISOString());

  return {
    userId: ctx.key,
    user,
    createdAt: new Date().toISOString()
  };
};

// No input
export const generateReport = async (ctx: Context) => {
  const report = await ctx.run("generate", () => createReport());
  return { reportId: report.id, generatedAt: new Date().toISOString() };
};
```

## Function composition

Functions can call other functions within the same service or across different services.

<CodeGroup>
    ```typescript TypeScript
    export const processOrder = async (ctx: Context, order: Order) => {
    // Call function in same service
    const validation = await ctx.serviceCall(OrderService).validateOrder(order);

    // Call function in different service
    const inventory = await ctx.serviceCall(InventoryService).reserveItems(order.items);

    // Call Virtual Object function
    const profile = await ctx.objectCall(UserAccount, order.customerId).getProfile();

    return {
    orderId: order.id,
    validated: validation.isValid,
    reserved: inventory.reserved,
    customer: profile.name
};
};
    ```

    ```java Java
    @Handler
    public OrderResult processOrder(Context ctx, Order order) {
    ValidationResult validation = OrderServiceClient.fromContext(ctx)
    .validateOrder(order).await();

    InventoryResult inventory = InventoryServiceClient.fromContext(ctx)
    .reserveItems(order.getItems()).await();

    ProfileResult profile = UserAccountClient.fromContext(ctx, order.getCustomerId())
    .getProfile().await();

    return new OrderResult(order.getId(), validation.isValid(),
    inventory.isReserved(), profile.getName());
}
    ```

    ```python Python
    async def process_order(ctx: Context, order: Order):
    validation = await OrderServiceClient.from_context(ctx).validate_order(order)

    inventory = await InventoryServiceClient.from_context(ctx).reserve_items(order.items)

    profile = await UserAccountClient.from_context(ctx, order.customer_id).get_profile()

    return {
    "order_id": order.id,
    "validated": validation.is_valid,
    "reserved": inventory.reserved,
    "customer": profile.name
}
    ```
</CodeGroup>

Functions provide the fundamental building blocks for building reliable, distributed applications with Restate's durable execution guarantees.

For implementation patterns and advanced features, explore:
- **[Helpers](/build/helpers)**: Durable execution, state management, service communication, and timing patterns
- **[Error Handling](/build/error-handling)**: Terminal vs retryable errors, timeouts, and failure patterns